/*
 * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

&cci {

	actuator0: qcom,actuator@36 {
		cell-index = <1>;
		reg = <0x36>;
		compatible = "qcom,actuator";
		qcom,cci-master = <0>;
	};

	qcom,camera@20 {
		compatible = "qcom,imx135";
		reg = <0x20>;
		qcom,slave-id = <0x20 0x0016 0x0135>;
		qcom,csiphy-sd-index = <0>;
		qcom,csid-sd-index = <0>;
		qcom,mount-angle = <90>;
		qcom,sensor-name = "imx135";
		qcom,actuator-src = <&actuator0>;
		cam_vdig-supply = <&pma8084_l27>;
		cam_vio-supply = <&pma8084_lvs4>;
		cam_vana-supply = <&pma8084_l17>;
		cam_vaf-supply = <&pma8084_l23>;
		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
				     "cam_vaf";
		qcom,cam-vreg-type = <0 1 0 0>;
		qcom,cam-vreg-min-voltage = <1050000 0 2800000 2700000>;
		qcom,cam-vreg-max-voltage = <1050000 0 2800000 2700000>;
		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
		qcom,gpio-no-mux = <0>;
		gpios = <&msmgpio 15 0>,
			<&msmgpio 36 0>,
			<&msmgpio 35 0>;
		qcom,gpio-reset = <1>;
		qcom,gpio-standby = <2>;
		qcom,gpio-req-tbl-num = <0 1 2>;
		qcom,gpio-req-tbl-flags = <1 0 0>;
		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
					  "CAM_RESET1",
					  "CAM_STANDBY";
		qcom,gpio-set-tbl-num = <1 1>;
		qcom,gpio-set-tbl-flags = <0 2>;
		qcom,gpio-set-tbl-delay = <1000 30000>;
		qcom,csi-lane-assign = <0x4320>;
		qcom,csi-lane-mask = <0x1F>;
		qcom,sensor-position = <0>;
		qcom,sensor-mode = <0>;
	        qcom,sensor-type = <0>;
		qcom,cci-master = <0>;
		status = "ok";
	};

	qcom,camera@6d {
		compatible = "qcom,imx132";
		reg = <0x6d>;
		qcom,slave-id = <0x6c 0x0 0x0132>;
		qcom,csiphy-sd-index = <2>;
		qcom,csid-sd-index = <2>;
		qcom,mount-angle = <270>;
		qcom,sensor-name = "imx132";
        cam_vana-supply = <&pma8084_l17>;
		cam_vdig-supply = <&pma8084_l15>;
		cam_vio-supply = <&pma8084_lvs4>;
		qcom,cam-vreg-name =  "cam_vana", "cam_vdig", "cam_vio";
		qcom,cam-vreg-type = <0 0 1>;
		qcom,cam-vreg-min-voltage = <2800000 1200000 0>;
		qcom,cam-vreg-max-voltage = <2800000 1200000 0>;
		qcom,cam-vreg-op-mode = <80000 105000 0>;
		qcom,gpio-no-mux = <0>;
		gpios = <&msmgpio 17 0>,
			    <&msmgpio 25 0>;
		qcom,gpio-reset = <1>;
		qcom,gpio-req-tbl-num = <0 1>;
		qcom,gpio-req-tbl-flags = <1 0>;
		qcom,gpio-req-tbl-label = "CAMIF_MCLK2",
					  "CAM_XSHUTDOWN";
		qcom,gpio-set-tbl-num = <1 1>;
		qcom,gpio-set-tbl-flags = <0 2>;
		qcom,gpio-set-tbl-delay = <1000 4000>;
		qcom,csi-lane-assign = <0x4320>;
		qcom,csi-lane-mask = <0x7>;
		qcom,sensor-position = <1>;
		qcom,sensor-mode = <1>;
		qcom,cci-master = <0>;
		status = "ok";
	};

	qcom,camera@0 {
		cell-index = <0>;
		compatible = "qcom,camera";
		reg = <0x00>;
		qcom,csiphy-sd-index = <0>;
		qcom,csid-sd-index = <0>;
		qcom,actuator-src = <&actuator0>;
		qcom,mount-angle = <90>;
		cam_vdig-supply = <&pma8084_l27>;
		cam_vio-supply = <&pma8084_lvs4>;
		cam_vana-supply = <&pma8084_l17>;
		cam_vaf-supply = <&pma8084_l23>;
		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
				     "cam_vaf";
		qcom,cam-vreg-type = <0 1 0 0>;
		qcom,cam-vreg-min-voltage = <1050000 0 2800000 2700000>;
		qcom,cam-vreg-max-voltage = <1050000 0 2800000 2700000>;
		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
		qcom,gpio-no-mux = <0>;
		gpios = <&msmgpio 15 0>,
			<&msmgpio 36 0>,
			<&msmgpio 35 0>;
		qcom,gpio-reset = <1>;
		qcom,gpio-standby = <2>;
		qcom,gpio-req-tbl-num = <0 1 2>;
		qcom,gpio-req-tbl-flags = <1 0 0>;
		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
					  "CAM_RESET1",
					  "CAM_STANDBY";
		qcom,sensor-position = <0>;
		qcom,sensor-mode = <1>;
		qcom,cci-master = <0>;
		status = "ok";
	};

	qcom,camera@1 {
		cell-index = <1>;
		compatible = "qcom,camera";
		reg = <0x01>;
		qcom,slave-id = <0x6c 0x0 0x0132>;
		qcom,csiphy-sd-index = <2>;
		qcom,csid-sd-index = <2>;
		qcom,mount-angle = <270>;
		cam_vana-supply = <&pma8084_l17>;
		cam_vdig-supply = <&pma8084_l15>;
		cam_vio-supply = <&pma8084_lvs4>;
		qcom,cam-vreg-name =  "cam_vana", "cam_vdig", "cam_vio";
		qcom,cam-vreg-type = <0 0 1>;
		qcom,cam-vreg-min-voltage = <2850000 1225000 0>;
		qcom,cam-vreg-max-voltage = <2850000 1225000 0>;
		qcom,cam-vreg-op-mode = <80000 105000 0>;
		qcom,gpio-no-mux = <0>;
		gpios = <&msmgpio 17 0>,
			    <&msmgpio 25 0>;
		qcom,gpio-reset = <1>;
		qcom,gpio-req-tbl-num = <0 1>;
		qcom,gpio-req-tbl-flags = <1 0>;
		qcom,gpio-req-tbl-label = "CAMIF_MCLK2",
					  "CAM_XSHUTDOWN";
		qcom,sensor-position = <1>;
		qcom,sensor-mode = <1>;
		qcom,cci-master = <0>;
		status = "ok";
	};
};
/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <linux/module.h>
#include <linux/init.h>
#include <linux/firmware.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/device.h>
#include <linux/printk.h>
#include <linux/ratelimit.h>
#include <linux/debugfs.h>
#include <linux/mfd/wcd9xxx/core.h>
#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
#include <uapi/linux/mfd/wcd9xxx/wcd9320_registers.h>
#include <linux/mfd/wcd9xxx/wcd9330_registers.h>
#include <linux/mfd/wcd9xxx/pdata.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/tlv.h>
#include <linux/bitops.h>
#include <linux/delay.h>
#include <linux/pm_runtime.h>
#include <linux/kernel.h>
#include <linux/gpio.h>
#include "wcd9xxx-resmgr.h"
#include "msm8x10_wcd_registers.h"

static char wcd9xxx_event_string[][64] = {
	"WCD9XXX_EVENT_INVALID",

	"WCD9XXX_EVENT_PRE_RCO_ON",
	"WCD9XXX_EVENT_POST_RCO_ON",
	"WCD9XXX_EVENT_PRE_RCO_OFF",
	"WCD9XXX_EVENT_POST_RCO_OFF",

	"WCD9XXX_EVENT_PRE_MCLK_ON",
	"WCD9XXX_EVENT_POST_MCLK_ON",
	"WCD9XXX_EVENT_PRE_MCLK_OFF",
	"WCD9XXX_EVENT_POST_MCLK_OFF",

	"WCD9XXX_EVENT_PRE_BG_OFF",
	"WCD9XXX_EVENT_POST_BG_OFF",
	"WCD9XXX_EVENT_PRE_BG_AUDIO_ON",
	"WCD9XXX_EVENT_POST_BG_AUDIO_ON",
	"WCD9XXX_EVENT_PRE_BG_MBHC_ON",
	"WCD9XXX_EVENT_POST_BG_MBHC_ON",

	"WCD9XXX_EVENT_PRE_MICBIAS_1_OFF",
	"WCD9XXX_EVENT_POST_MICBIAS_1_OFF",
	"WCD9XXX_EVENT_PRE_MICBIAS_2_OFF",
	"WCD9XXX_EVENT_POST_MICBIAS_2_OFF",
	"WCD9XXX_EVENT_PRE_MICBIAS_3_OFF",
	"WCD9XXX_EVENT_POST_MICBIAS_3_OFF",
	"WCD9XXX_EVENT_PRE_MICBIAS_4_OFF",
	"WCD9XXX_EVENT_POST_MICBIAS_4_OFF",
	"WCD9XXX_EVENT_PRE_MICBIAS_1_ON",
	"WCD9XXX_EVENT_POST_MICBIAS_1_ON",
	"WCD9XXX_EVENT_PRE_MICBIAS_2_ON",
	"WCD9XXX_EVENT_POST_MICBIAS_2_ON",
	"WCD9XXX_EVENT_PRE_MICBIAS_3_ON",
	"WCD9XXX_EVENT_POST_MICBIAS_3_ON",
	"WCD9XXX_EVENT_PRE_MICBIAS_4_ON",
	"WCD9XXX_EVENT_POST_MICBIAS_4_ON",

	"WCD9XXX_EVENT_PRE_CFILT_1_OFF",
	"WCD9XXX_EVENT_POST_CFILT_1_OFF",
	"WCD9XXX_EVENT_PRE_CFILT_2_OFF",
	"WCD9XXX_EVENT_POST_CFILT_2_OFF",
	"WCD9XXX_EVENT_PRE_CFILT_3_OFF",
	"WCD9XXX_EVENT_POST_CFILT_3_OFF",
	"WCD9XXX_EVENT_PRE_CFILT_1_ON",
	"WCD9XXX_EVENT_POST_CFILT_1_ON",
	"WCD9XXX_EVENT_PRE_CFILT_2_ON",
	"WCD9XXX_EVENT_POST_CFILT_2_ON",
	"WCD9XXX_EVENT_PRE_CFILT_3_ON",
	"WCD9XXX_EVENT_POST_CFILT_3_ON",

	"WCD9XXX_EVENT_PRE_HPHL_PA_ON",
	"WCD9XXX_EVENT_POST_HPHL_PA_OFF",
	"WCD9XXX_EVENT_PRE_HPHR_PA_ON",
	"WCD9XXX_EVENT_POST_HPHR_PA_OFF",

	"WCD9XXX_EVENT_POST_RESUME",

	"WCD9XXX_EVENT_PRE_TX_1_3_ON",
	"WCD9XXX_EVENT_POST_TX_1_3_OFF",
	"WCD9XXX_EVENT_PRE_HPHL_PA_OFF",
	"WCD9XXX_EVENT_PRE_HPHR_PA_OFF",

	"WCD9XXX_EVENT_LAST",
};

#define WCD9XXX_RCO_CALIBRATION_RETRY_COUNT 5
#define WCD9XXX_RCO_CALIBRATION_DELAY_US 5000
#define WCD9XXX_USLEEP_RANGE_MARGIN_US 100
#define WCD9XXX_RCO_CALIBRATION_DELAY_INC_US 1000

struct wcd9xxx_resmgr_cond_entry {
	unsigned short reg;
	int shift;
	bool invert;
	enum wcd9xxx_resmgr_cond cond;
	struct list_head list;
};

static enum wcd9xxx_clock_type wcd9xxx_save_clock(struct wcd9xxx_resmgr
						  *resmgr);
static void wcd9xxx_restore_clock(struct wcd9xxx_resmgr *resmgr,
				  enum wcd9xxx_clock_type type);

const char *wcd9xxx_get_event_string(enum wcd9xxx_notify_event type)
{
	return wcd9xxx_event_string[type];
}

void wcd9xxx_resmgr_notifier_call(struct wcd9xxx_resmgr *resmgr,
				  const enum wcd9xxx_notify_event e)
{
	pr_debug("%s: notifier call event %d\n", __func__, e);
	blocking_notifier_call_chain(&resmgr->notifier, e, resmgr);
}

static void wcd9xxx_disable_bg(struct wcd9xxx_resmgr *resmgr)
{
	/* Notify bg mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_BG_OFF);
	/* Disable bg */
	snd_soc_update_bits(resmgr->codec, WCD9XXX_A_BIAS_CENTRAL_BG_CTL,
			    0x03, 0x00);
	usleep_range(100, 110);
	/* Notify bg mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_POST_BG_OFF);
}

/*
 * BG enablement should always enable in slow mode.
 * The fast mode doesn't need to be enabled as fast mode BG is to be driven
 * by MBHC override.
 */
static void wcd9xxx_enable_bg(struct wcd9xxx_resmgr *resmgr)
{
	struct snd_soc_codec *codec = resmgr->codec;

	/* Enable BG in slow mode and precharge */
	snd_soc_update_bits(codec, WCD9XXX_A_BIAS_CENTRAL_BG_CTL, 0x80, 0x80);
	snd_soc_update_bits(codec, WCD9XXX_A_BIAS_CENTRAL_BG_CTL, 0x04, 0x04);
	snd_soc_update_bits(codec, WCD9XXX_A_BIAS_CENTRAL_BG_CTL, 0x01, 0x01);
	usleep_range(1000, 1100);
	snd_soc_update_bits(codec, WCD9XXX_A_BIAS_CENTRAL_BG_CTL, 0x80, 0x00);
}

static void wcd9xxx_enable_bg_audio(struct wcd9xxx_resmgr *resmgr)
{
	/* Notify bandgap mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_BG_AUDIO_ON);
	wcd9xxx_enable_bg(resmgr);
	/* Notify bandgap mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_POST_BG_AUDIO_ON);
}

static void wcd9xxx_enable_bg_mbhc(struct wcd9xxx_resmgr *resmgr)
{
	struct snd_soc_codec *codec = resmgr->codec;

	/* Notify bandgap mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_BG_MBHC_ON);

	/*
	 * mclk should be off or clk buff source souldn't be VBG
	 * Let's turn off mclk always
	 */
	if (resmgr->codec_type != WCD9XXX_CDC_TYPE_HELICON)
		WARN_ON(snd_soc_read(codec, WCD9XXX_A_CLK_BUFF_EN2) & (1 << 2));

	wcd9xxx_enable_bg(resmgr);
	/* Notify bandgap mode change */
	wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_POST_BG_MBHC_ON);
}

static void wcd9xxx_disable_clock_block(struct wcd9xxx_resmgr *resmgr)
{
	struct snd_soc_codec *codec = resmgr->codec;

	pr_debug("%s: enter\n", __func__);
	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);

	/* Notify */
	if (resmgr->clk_type == WCD9XXX_CLK_RCO)
		wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_RCO_OFF);
	else
		wcd9xxx_resmgr_notifier_call(resmgr,
					     WCD9XXX_EVENT_PRE_MCLK_OFF);

	switch (resmgr->codec_type) {
	case WCD9XXX_CDC_TYPE_HELICON:
		break;
	case WCD9XXX_CDC_TYPE_TOMTOM:
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2, 0x04, 0x00);
		usleep_range(50, 55);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2, 0x02, 0x02);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1, 0x40, 0x40);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1, 0x40, 0x00);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1, 0x01, 0x00);
		break;
	default:
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2, 0x04, 0x00);
		usleep_range(50, 55);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2, 0x02, 0x02);
		snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1, 0x05, 0x00);
		break;
	}
	usleep_range(50, 55);
	/* Notify */
	if (resmgr->clk_type == WCD9XXX_CLK_RCO) {
		wcd9xxx_resmgr_notifier_call(resmgr,
					     WCD9XXX_EVENT_POST_RCO_OFF);
	} else {
		if (resmgr->codec_type == WCD9XXX_CDC_TYPE_HELICON)
			snd_soc_update_bits(codec,
				MSM8X10_WCD_A_CDC_CLK_PDM_CTL, 0x03, 0x00);

		wcd9xxx_resmgr_notifier_call(resmgr,
					     WCD9XXX_EVENT_POST_MCLK_OFF);
	}
	pr_debug("%s: leave\n", __func__);
}

static void wcd9xxx_resmgr_cdc_specific_get_clk(struct wcd9xxx_resmgr *resmgr,
						int clk_users)
{
	/* Caller of this funcion should have acquired
	 *  BG_CLK lock
	 */
	WCD9XXX_BG_CLK_UNLOCK(resmgr);
	if (clk_users) {
		if (resmgr->resmgr_cb &&
		    resmgr->resmgr_cb->cdc_rco_ctrl) {
			while (clk_users--)
				resmgr->resmgr_cb->cdc_rco_ctrl(resmgr->codec,
								true);
		}
	}
	/* Acquire BG_CLK lock before return */
	WCD9XXX_BG_CLK_LOCK(resmgr);
}

void wcd9xxx_resmgr_post_ssr(struct wcd9xxx_resmgr *resmgr)
{
	int old_bg_audio_users, old_bg_mbhc_users;
	int old_clk_rco_users, old_clk_mclk_users;

	pr_debug("%s: enter\n", __func__);

	WCD9XXX_BG_CLK_LOCK(resmgr);
	old_bg_audio_users = resmgr->bg_audio_users;
	old_bg_mbhc_users = resmgr->bg_mbhc_users;
	old_clk_rco_users = resmgr->clk_rco_users;
	old_clk_mclk_users = resmgr->clk_mclk_users;
	resmgr->bg_audio_users = 0;
	resmgr->bg_mbhc_users = 0;
	resmgr->bandgap_type = WCD9XXX_BANDGAP_OFF;
	resmgr->clk_rco_users = 0;
	resmgr->clk_mclk_users = 0;
	resmgr->clk_type = WCD9XXX_CLK_OFF;

	if (old_bg_audio_users) {
		while (old_bg_audio_users--)
			wcd9xxx_resmgr_get_bandgap(resmgr,
						  WCD9XXX_BANDGAP_AUDIO_MODE);
	}

	if (old_bg_mbhc_users) {
		while (old_bg_mbhc_users--)
			wcd9xxx_resmgr_get_bandgap(resmgr,
						  WCD9XXX_BANDGAP_MBHC_MODE);
	}

	if (old_clk_mclk_users) {
		while (old_clk_mclk_users--)
			wcd9xxx_resmgr_get_clk_block(resmgr, WCD9XXX_CLK_MCLK);
	}

	if (resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) {
		wcd9xxx_resmgr_cdc_specific_get_clk(resmgr, old_clk_rco_users);
	} else if (old_clk_rco_users) {
		while (old_clk_rco_users--)
			wcd9xxx_resmgr_get_clk_block(resmgr,
					WCD9XXX_CLK_RCO);
	}
	WCD9XXX_BG_CLK_UNLOCK(resmgr);
	pr_debug("%s: leave\n", __func__);
}

/*
 * wcd9xxx_resmgr_get_bandgap : Vote for bandgap ref
 * choice : WCD9XXX_BANDGAP_AUDIO_MODE, WCD9XXX_BANDGAP_MBHC_MODE
 */
void wcd9xxx_resmgr_get_bandgap(struct wcd9xxx_resmgr *resmgr,
				const enum wcd9xxx_bandgap_type choice)
{
	enum wcd9xxx_clock_type clock_save = WCD9XXX_CLK_OFF;

	pr_debug("%s: enter, wants %d\n", __func__, choice);

	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);
	switch (choice) {
	case WCD9XXX_BANDGAP_AUDIO_MODE:
		resmgr->bg_audio_users++;
		if (resmgr->bg_audio_users == 1 && resmgr->bg_mbhc_users) {
			/*
			 * Current bg is MBHC mode, about to switch to
			 * audio mode.
			 */
			WARN_ON(resmgr->bandgap_type !=
				WCD9XXX_BANDGAP_MBHC_MODE);

			/* BG mode can be changed only with clock off */
			if (resmgr->codec_type != WCD9XXX_CDC_TYPE_TOMTOM)
				clock_save = wcd9xxx_save_clock(resmgr);
			/* Swtich BG mode */
			wcd9xxx_disable_bg(resmgr);
			wcd9xxx_enable_bg_audio(resmgr);
			/* restore clock */
			if (resmgr->codec_type != WCD9XXX_CDC_TYPE_TOMTOM)
				wcd9xxx_restore_clock(resmgr, clock_save);
		} else if (resmgr->bg_audio_users == 1) {
			/* currently off, just enable it */
			WARN_ON(resmgr->bandgap_type != WCD9XXX_BANDGAP_OFF);
			wcd9xxx_enable_bg_audio(resmgr);
		}
		resmgr->bandgap_type = WCD9XXX_BANDGAP_AUDIO_MODE;
		break;
	case WCD9XXX_BANDGAP_MBHC_MODE:
		resmgr->bg_mbhc_users++;
		if (resmgr->bandgap_type == WCD9XXX_BANDGAP_MBHC_MODE ||
		    resmgr->bandgap_type == WCD9XXX_BANDGAP_AUDIO_MODE)
			/* do nothing */
			break;

		/* bg mode can be changed only with clock off */
		clock_save = wcd9xxx_save_clock(resmgr);
		/* enable bg with MBHC mode */
		wcd9xxx_enable_bg_mbhc(resmgr);
		/* restore clock */
		wcd9xxx_restore_clock(resmgr, clock_save);
		/* save current mode */
		resmgr->bandgap_type = WCD9XXX_BANDGAP_MBHC_MODE;
		break;
	default:
		pr_err("%s: Error, Invalid bandgap settings\n", __func__);
		break;
	}

	pr_debug("%s: bg users audio %d, mbhc %d\n", __func__,
		 resmgr->bg_audio_users, resmgr->bg_mbhc_users);
}

/*
 * wcd9xxx_resmgr_put_bandgap : Unvote bandgap ref that has been voted
 * choice : WCD9XXX_BANDGAP_AUDIO_MODE, WCD9XXX_BANDGAP_MBHC_MODE
 */
void wcd9xxx_resmgr_put_bandgap(struct wcd9xxx_resmgr *resmgr,
				enum wcd9xxx_bandgap_type choice)
{
	enum wcd9xxx_clock_type clock_save;

	pr_debug("%s: enter choice %d\n", __func__, choice);

	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);
	switch (choice) {
	case WCD9XXX_BANDGAP_AUDIO_MODE:
		if (--resmgr->bg_audio_users == 0) {
			if (resmgr->bg_mbhc_users) {
				/* bg mode can be changed only with clock off */
				clock_save = wcd9xxx_save_clock(resmgr);
				/* switch to MBHC mode */
				wcd9xxx_enable_bg_mbhc(resmgr);
				/* restore clock */
				wcd9xxx_restore_clock(resmgr, clock_save);
				resmgr->bandgap_type =
				    WCD9XXX_BANDGAP_MBHC_MODE;
			} else {
				/* turn off */
				wcd9xxx_disable_bg(resmgr);
				resmgr->bandgap_type = WCD9XXX_BANDGAP_OFF;
			}
		}
		break;
	case WCD9XXX_BANDGAP_MBHC_MODE:
		WARN(resmgr->bandgap_type == WCD9XXX_BANDGAP_OFF,
		     "Unexpected bandgap type %d\n", resmgr->bandgap_type);
		if (--resmgr->bg_mbhc_users == 0 &&
		    resmgr->bandgap_type == WCD9XXX_BANDGAP_MBHC_MODE) {
			wcd9xxx_disable_bg(resmgr);
			resmgr->bandgap_type = WCD9XXX_BANDGAP_OFF;
		}
		break;
	default:
		pr_err("%s: Error, Invalid bandgap settings\n", __func__);
		break;
	}

	pr_debug("%s: bg users audio %d, mbhc %d\n", __func__,
		 resmgr->bg_audio_users, resmgr->bg_mbhc_users);
}

void wcd9xxx_resmgr_enable_rx_bias(struct wcd9xxx_resmgr *resmgr, u32 enable)
{
	struct snd_soc_codec *codec = resmgr->codec;

	if (enable) {
		resmgr->rx_bias_count++;
		if (resmgr->rx_bias_count == 1)
			snd_soc_update_bits(codec, WCD9XXX_A_RX_COM_BIAS,
					    0x80, 0x80);
	} else {
		resmgr->rx_bias_count--;
		if (!resmgr->rx_bias_count)
			snd_soc_update_bits(codec, WCD9XXX_A_RX_COM_BIAS,
					    0x80, 0x00);
	}
}

int wcd9xxx_resmgr_enable_config_mode(struct wcd9xxx_resmgr *resmgr, int enable)
{
	struct snd_soc_codec *codec = resmgr->codec;

	pr_debug("%s: enable = %d\n", __func__, enable);
	if (enable) {
		snd_soc_update_bits(codec, WCD9XXX_A_RC_OSC_FREQ, 0x10, 0);
		/* bandgap mode to fast */
		snd_soc_write(codec, WCD9XXX_A_BIAS_OSC_BG_CTL, 0x17);
		usleep_range(5, 10);
		snd_soc_update_bits(codec, WCD9XXX_A_RC_OSC_FREQ, 0x80, 0x80);
		snd_soc_update_bits(codec, WCD9XXX_A_RC_OSC_TEST, 0x80, 0x80);
		usleep_range(10, 20);
		snd_soc_update_bits(codec, WCD9XXX_A_RC_OSC_TEST, 0x80, 0);
		usleep_range(10000, 10100);
		if (resmgr->codec_type != WCD9XXX_CDC_TYPE_HELICON)
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					0x08, 0x08);
		else
			snd_soc_update_bits(codec,
					MSM8X10_WCD_A_CDC_TOP_CLK_CTL,
					0x20, 0x20);
	} else {
		snd_soc_update_bits(codec, WCD9XXX_A_BIAS_OSC_BG_CTL, 0x1, 0);
		snd_soc_update_bits(codec, WCD9XXX_A_RC_OSC_FREQ, 0x80, 0);
		if (resmgr->codec_type == WCD9XXX_CDC_TYPE_HELICON)
			snd_soc_update_bits(codec,
					MSM8X10_WCD_A_CDC_TOP_CLK_CTL,
					0x20, 0x00);
	}

	return 0;
}

static void wcd9xxx_enable_clock_block(struct wcd9xxx_resmgr *resmgr,
				enum wcd9xxx_clock_config_mode config_mode)
{
	struct snd_soc_codec *codec = resmgr->codec;
	unsigned long delay = WCD9XXX_RCO_CALIBRATION_DELAY_US;
	int num_retry = 0;
	unsigned int valr;
	unsigned int valr1;
	unsigned int valw[] = {0x01, 0x01, 0x10, 0x00};

	pr_debug("%s: config_mode = %d\n", __func__, config_mode);

	/* transit to RCO requires mclk off */
	if (resmgr->codec_type != WCD9XXX_CDC_TYPE_HELICON &&
	    resmgr->codec_type != WCD9XXX_CDC_TYPE_TOMTOM)
		WARN_ON(snd_soc_read(codec, WCD9XXX_A_CLK_BUFF_EN2) & (1 << 2));

	if (config_mode == WCD9XXX_CFG_RCO) {
		/* Notify */
		wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_RCO_ON);
		/* enable RCO and switch to it */
		wcd9xxx_resmgr_enable_config_mode(resmgr, 1);
		if (resmgr->codec_type != WCD9XXX_CDC_TYPE_HELICON)
			snd_soc_write(codec, WCD9XXX_A_CLK_BUFF_EN2, 0x02);
		usleep_range(1000, 1100);
	} else if (config_mode == WCD9XXX_CFG_CAL_RCO) {
		snd_soc_update_bits(codec, TOMTOM_A_BIAS_OSC_BG_CTL,
				    0x01, 0x01);
		/* 1ms sleep required after BG enabled */
		usleep_range(1000, 1100);

		snd_soc_update_bits(codec, TOMTOM_A_RCO_CTRL, 0x18, 0x10);
		valr = snd_soc_read(codec, TOMTOM_A_QFUSE_DATA_OUT0) & (0x04);
		valr1 = snd_soc_read(codec, TOMTOM_A_QFUSE_DATA_OUT1) & (0x08);
		valr = (valr >> 1) | (valr1 >> 3);
		snd_soc_update_bits(codec, TOMTOM_A_RCO_CTRL, 0x60,
				    valw[valr] << 5);

		snd_soc_update_bits(codec, TOMTOM_A_RCO_CTRL, 0x80, 0x80);

		do {
			snd_soc_update_bits(codec,
					    TOMTOM_A_RCO_CALIBRATION_CTRL1,
					    0x80, 0x80);
			snd_soc_update_bits(codec,
					    TOMTOM_A_RCO_CALIBRATION_CTRL1,
					    0x80, 0x00);
			/* RCO calibration takes approx. 5ms */
			usleep_range(delay, delay +
					    WCD9XXX_USLEEP_RANGE_MARGIN_US);
			if (!(snd_soc_read(codec,
				TOMTOM_A_RCO_CALIBRATION_RESULT1) & 0x10))
				break;
			if (num_retry >= 3) {
				delay = delay +
					WCD9XXX_RCO_CALIBRATION_DELAY_INC_US;
			}
		} while (num_retry++ < WCD9XXX_RCO_CALIBRATION_RETRY_COUNT);
	} else {
		/* Notify */
		wcd9xxx_resmgr_notifier_call(resmgr, WCD9XXX_EVENT_PRE_MCLK_ON);
		/* switch to MCLK */

		switch (resmgr->codec_type) {
		case WCD9XXX_CDC_TYPE_HELICON:
			snd_soc_update_bits(codec,
					MSM8X10_WCD_A_CDC_CLK_PDM_CTL,
					0x03, 0x03);
			snd_soc_update_bits(codec,
					MSM8X10_WCD_A_CDC_TOP_CLK_CTL,
					0x0f, 0x0d);

			/* if RCO is enabled, switch from it */
			if (snd_soc_read(codec, WCD9XXX_A_RC_OSC_FREQ) & 0x80)
				wcd9xxx_resmgr_enable_config_mode(resmgr, 0);
			break;
		case WCD9XXX_CDC_TYPE_TOMTOM:
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x08, 0x00);
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x40, 0x40);
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x40, 0x00);
			/* clk source to ext clk and clk buff ref to VBG */
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x0C, 0x04);
			break;
		default:
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x08, 0x00);
			/* if RCO is enabled, switch from it */
			if (snd_soc_read(codec, WCD9XXX_A_RC_OSC_FREQ) & 0x80) {
				snd_soc_write(codec, WCD9XXX_A_CLK_BUFF_EN2,
					      0x02);
				wcd9xxx_resmgr_enable_config_mode(resmgr, 0);
			}
			/* clk source to ext clk and clk buff ref to VBG */
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x0C, 0x04);
			break;
		}
	}

	if (config_mode != WCD9XXX_CFG_CAL_RCO) {
		if (resmgr->codec_type != WCD9XXX_CDC_TYPE_HELICON) {
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1,
					    0x01, 0x01);
			/*
			 * sleep required by codec hardware to
			 * enable clock buffer
			 */
			usleep_range(1000, 1200);
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2,
					    0x02, 0x00);
			/* on MCLK */
			snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN2,
					    0x04, 0x04);
			snd_soc_update_bits(codec, WCD9XXX_A_CDC_CLK_MCLK_CTL,
					    0x01, 0x01);
		} else {
			snd_soc_update_bits(codec,
					    MSM8X10_WCD_A_CDC_CLK_MCLK_CTL,
					    0x01, 0x01);
		}
	}
	usleep_range(50, 55);

	/* Notify */
	if (config_mode == WCD9XXX_CFG_RCO)
		wcd9xxx_resmgr_notifier_call(resmgr,
					     WCD9XXX_EVENT_POST_RCO_ON);
	else if (config_mode == WCD9XXX_CFG_MCLK)
		wcd9xxx_resmgr_notifier_call(resmgr,
					     WCD9XXX_EVENT_POST_MCLK_ON);
}

/*
 * disable clock and return previous clock state
 */
static enum wcd9xxx_clock_type wcd9xxx_save_clock(struct wcd9xxx_resmgr *resmgr)
{
	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);
	if (resmgr->clk_type != WCD9XXX_CLK_OFF)
		wcd9xxx_disable_clock_block(resmgr);
	return resmgr->clk_type != WCD9XXX_CLK_OFF;
}

static void wcd9xxx_restore_clock(struct wcd9xxx_resmgr *resmgr,
				  enum wcd9xxx_clock_type type)
{
	if (type != WCD9XXX_CLK_OFF)
		wcd9xxx_enable_clock_block(resmgr, type == WCD9XXX_CLK_RCO);
}

void wcd9xxx_resmgr_get_clk_block(struct wcd9xxx_resmgr *resmgr,
				  enum wcd9xxx_clock_type type)
{
	struct snd_soc_codec *codec = resmgr->codec;

	pr_debug("%s: current %d, requested %d, rco_users %d, mclk_users %d\n",
		 __func__, resmgr->clk_type, type,
		 resmgr->clk_rco_users, resmgr->clk_mclk_users);
	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);
	switch (type) {
	case WCD9XXX_CLK_RCO:
		if (++resmgr->clk_rco_users == 1 &&
		    resmgr->clk_type == WCD9XXX_CLK_OFF) {
			/* enable RCO and switch to it */
			wcd9xxx_enable_clock_block(resmgr, WCD9XXX_CFG_RCO);
			resmgr->clk_type = WCD9XXX_CLK_RCO;
		} else if (resmgr->clk_rco_users == 1 &&
			   resmgr->clk_type == WCD9XXX_CLK_MCLK &&
			   resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) {
			/*
			 * Enable RCO but do not switch CLK MUX to RCO
			 * unless ext_clk_users is 1, which indicates
			 * EXT CLK is enabled for RCO calibration
			 */
			wcd9xxx_enable_clock_block(resmgr, WCD9XXX_CFG_CAL_RCO);
			if (resmgr->ext_clk_users == 1) {
				/* Notify */
				wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_PRE_RCO_ON);
				/* CLK MUX to RCO */
				snd_soc_update_bits(codec,
						    WCD9XXX_A_CLK_BUFF_EN1,
						    0x08, 0x08);
				resmgr->clk_type = WCD9XXX_CLK_RCO;
				wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_POST_RCO_ON);
			}
		}
		break;
	case WCD9XXX_CLK_MCLK:
		if (++resmgr->clk_mclk_users == 1 &&
		    resmgr->clk_type == WCD9XXX_CLK_OFF) {
			/* switch to MCLK */
			wcd9xxx_enable_clock_block(resmgr, WCD9XXX_CFG_MCLK);
			resmgr->clk_type = WCD9XXX_CLK_MCLK;
		} else if (resmgr->clk_mclk_users == 1 &&
			   resmgr->clk_type == WCD9XXX_CLK_RCO) {
			/* RCO to MCLK switch, with RCO still powered on */
			if (resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) {
				wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_PRE_MCLK_ON);
				snd_soc_update_bits(codec,
						WCD9XXX_A_BIAS_CENTRAL_BG_CTL,
						0x40, 0x00);
				/* Enable clock buffer */
				snd_soc_update_bits(codec,
						WCD9XXX_A_CLK_BUFF_EN1,
						0x01, 0x01);
				snd_soc_update_bits(codec,
						WCD9XXX_A_CLK_BUFF_EN1,
						0x08, 0x00);
				wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_POST_MCLK_ON);
			} else {
				/* if RCO is enabled, switch from it */
				WARN_ON(!(snd_soc_read(resmgr->codec,
					WCD9XXX_A_RC_OSC_FREQ) & 0x80));
				/* disable clock block */
				wcd9xxx_disable_clock_block(resmgr);
				/* switch to MCLK */
				wcd9xxx_enable_clock_block(resmgr,
							   WCD9XXX_CFG_MCLK);
			}
			resmgr->clk_type = WCD9XXX_CLK_MCLK;
		}
		break;
	default:
		pr_err("%s: Error, Invalid clock get request %d\n", __func__,
		       type);
		break;
	}
	pr_debug("%s: leave\n", __func__);
}

void wcd9xxx_resmgr_put_clk_block(struct wcd9xxx_resmgr *resmgr,
				  enum wcd9xxx_clock_type type)
{
	struct snd_soc_codec *codec = resmgr->codec;

	pr_debug("%s: current %d, put %d\n", __func__, resmgr->clk_type, type);

	WCD9XXX_BG_CLK_ASSERT_LOCKED(resmgr);
	switch (type) {
	case WCD9XXX_CLK_RCO:
		if (--resmgr->clk_rco_users == 0 &&
		    resmgr->clk_type == WCD9XXX_CLK_RCO) {
			wcd9xxx_disable_clock_block(resmgr);
			if (resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) {
				/* Powerdown RCO */
				 snd_soc_update_bits(codec, TOMTOM_A_RCO_CTRL,
						     0x80, 0x00);
				 snd_soc_update_bits(codec,
						TOMTOM_A_BIAS_OSC_BG_CTL,
						0x01, 0x00);
			} else {
				/* if RCO is enabled, switch from it */
				if (snd_soc_read(resmgr->codec,
						 WCD9XXX_A_RC_OSC_FREQ)
						 & 0x80) {
					if (resmgr->codec_type !=
						WCD9XXX_CDC_TYPE_HELICON)
						snd_soc_write(resmgr->codec,
							WCD9XXX_A_CLK_BUFF_EN2,
							0x02);
					wcd9xxx_resmgr_enable_config_mode(
								resmgr,	0);
				}
			}
			resmgr->clk_type = WCD9XXX_CLK_OFF;
		}
		break;
	case WCD9XXX_CLK_MCLK:
		if (--resmgr->clk_mclk_users == 0 &&
		    resmgr->clk_rco_users == 0) {
			wcd9xxx_disable_clock_block(resmgr);

			if ((resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) &&
			    (snd_soc_read(codec, TOMTOM_A_RCO_CTRL) & 0x80)) {
				/* powerdown RCO*/
				 snd_soc_update_bits(codec, TOMTOM_A_RCO_CTRL,
						     0x80, 0x00);
				 snd_soc_update_bits(codec,
						TOMTOM_A_BIAS_OSC_BG_CTL,
						0x01, 0x00);
			}
			resmgr->clk_type = WCD9XXX_CLK_OFF;
		} else if (resmgr->clk_mclk_users == 0 &&
			   resmgr->clk_rco_users) {
			if (resmgr->codec_type == WCD9XXX_CDC_TYPE_TOMTOM) {
				if (!(snd_soc_read(codec, TOMTOM_A_RCO_CTRL) &
				      0x80)) {
					dev_dbg(codec->dev, "%s: Enabling RCO\n",
						__func__);
					wcd9xxx_enable_clock_block(resmgr,
							WCD9XXX_CFG_CAL_RCO);
					snd_soc_update_bits(codec,
							WCD9XXX_A_CLK_BUFF_EN1,
							0x01, 0x00);
				} else {
					wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_PRE_MCLK_OFF);
					snd_soc_update_bits(codec,
							WCD9XXX_A_CLK_BUFF_EN1,
							0x08, 0x08);
					snd_soc_update_bits(codec,
							WCD9XXX_A_CLK_BUFF_EN1,
							0x01, 0x00);
					wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_POST_MCLK_OFF);
					/* CLK Mux changed to RCO, notify that
					 * RCO is ON
					 */
					wcd9xxx_resmgr_notifier_call(resmgr,
						WCD9XXX_EVENT_POST_RCO_ON);
				}
			} else {
				/* disable clock */
				wcd9xxx_disable_clock_block(resmgr);
				/* switch to RCO */
				wcd9xxx_enable_clock_block(resmgr,
							WCD9XXX_CFG_RCO);
			}
			resmgr->clk_type = WCD9XXX_CLK_RCO;
		}
		break;
	default:
		pr_err("%s: Error, Invalid clock get request %d\n", __func__,
		       type);
		break;
	}
	WARN_ON(resmgr->clk_rco_users < 0);
	WARN_ON(resmgr->clk_mclk_users < 0);

	pr_debug("%s: new rco_users %d, mclk_users %d\n", __func__,
		 resmgr->clk_rco_users, resmgr->clk_mclk_users);
}

/*
 * wcd9xxx_resmgr_get_clk_type()
 * Returns clk type that is currently enabled
 */
int wcd9xxx_resmgr_get_clk_type(struct wcd9xxx_resmgr *resmgr)
{
	return resmgr->clk_type;
}

static void wcd9xxx_resmgr_update_cfilt_usage(struct wcd9xxx_resmgr *resmgr,
					      enum wcd9xxx_cfilt_sel cfilt_sel,
					      bool inc)
{
	u16 micb_cfilt_reg;
	enum wcd9xxx_notify_event e_pre_on, e_post_off;
	struct snd_soc_codec *codec = resmgr->codec;

	switch (cfilt_sel) {
	case WCD9XXX_CFILT1_SEL:
		micb_cfilt_reg = WCD9XXX_A_MICB_CFILT_1_CTL;
		e_pre_on = WCD9XXX_EVENT_PRE_CFILT_1_ON;
		e_post_off = WCD9XXX_EVENT_POST_CFILT_1_OFF;
		break;
	case WCD9XXX_CFILT2_SEL:
		micb_cfilt_reg = WCD9XXX_A_MICB_CFILT_2_CTL;
		e_pre_on = WCD9XXX_EVENT_PRE_CFILT_2_ON;
		e_post_off = WCD9XXX_EVENT_POST_CFILT_2_OFF;
		break;
	case WCD9XXX_CFILT3_SEL:
		micb_cfilt_reg = WCD9XXX_A_MICB_CFILT_3_CTL;
		e_pre_on = WCD9XXX_EVENT_PRE_CFILT_3_ON;
		e_post_off = WCD9XXX_EVENT_POST_CFILT_3_OFF;
		break;
	default:
		WARN(1, "Invalid CFILT selection %d\n", cfilt_sel);
		return; /* should not happen */
	}

	if (inc) {
		if ((resmgr->cfilt_users[cfilt_sel]++) == 0) {
			/* Notify */
			wcd9xxx_resmgr_notifier_call(resmgr, e_pre_on);
			/* Enable CFILT */
			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0x80);
		}
	} else {
		/*
		 * Check if count not zero, decrease
		 * then check if zero, go ahead disable cfilter
		 */
		WARN(resmgr->cfilt_users[cfilt_sel] == 0,
		     "Invalid CFILT use count 0\n");
		if ((--resmgr->cfilt_users[cfilt_sel]) == 0) {
			/* Disable CFILT */
			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0);
			/* Notify MBHC so MBHC can switch CFILT to fast mode */
			wcd9xxx_resmgr_notifier_call(resmgr, e_post_off);
		}
	}
}

void wcd9xxx_resmgr_cfilt_get(struct wcd9xxx_resmgr *resmgr,
			      enum wcd9xxx_cfilt_sel cfilt_sel)
{
	return wcd9xxx_resmgr_update_cfilt_usage(resmgr, cfilt_sel, true);
}

void wcd9xxx_resmgr_cfilt_put(struct wcd9xxx_resmgr *resmgr,
			      enum wcd9xxx_cfilt_sel cfilt_sel)
{
	return wcd9xxx_resmgr_update_cfilt_usage(resmgr, cfilt_sel, false);
}

int wcd9xxx_resmgr_get_k_val(struct wcd9xxx_resmgr *resmgr,
			     unsigned int cfilt_mv)
{
	int rc = -EINVAL;
	unsigned int ldoh_v = resmgr->micbias_pdata->ldoh_v;
	unsigned min_mv, max_mv;

	switch (ldoh_v) {
	case WCD9XXX_LDOH_1P95_V:
		min_mv = 160;
		max_mv = 1800;
		break;
	case WCD9XXX_LDOH_2P35_V:
		min_mv = 200;
		max_mv = 2200;
		break;
	case WCD9XXX_LDOH_2P75_V:
		min_mv = 240;
		max_mv = 2600;
		break;
	case WCD9XXX_LDOH_3P0_V:
		min_mv = 260;
		max_mv = 2875;
		break;
	default:
		goto done;
	}

	if (cfilt_mv < min_mv || cfilt_mv > max_mv)
		goto done;

	for (rc = 4; rc <= 44; rc++) {
		min_mv = max_mv * (rc) / 44;
		if (min_mv >= cfilt_mv) {
			rc -= 4;
			break;
		}
	}
done:
	return rc;
}

static void wcd9xxx_resmgr_cond_trigger_cond(struct wcd9xxx_resmgr *resmgr,
					     enum wcd9xxx_resmgr_cond cond)
{
	struct list_head *l;
	struct wcd9xxx_resmgr_cond_entry *e;
	bool set;

	pr_debug("%s: enter\n", __func__);
	/* update bit if cond isn't available or cond is set */
	set = !test_bit(cond, &resmgr->cond_avail_flags) ||
	      !!test_bit(cond, &resmgr->cond_flags);
	list_for_each(l, &resmgr->update_bit_cond_h) {
		e = list_entry(l, struct wcd9xxx_resmgr_cond_entry, list);
		if (e->cond == cond)
			snd_soc_update_bits(resmgr->codec, e->reg,
					    1 << e->shift,
					    (set ? !e->invert : e->invert)
					    << e->shift);
	}
	pr_debug("%s: leave\n", __func__);
}

/*
 * wcd9xxx_regmgr_cond_register : notify resmgr conditions in the condbits are
 *				  avaliable and notified.
 * condbits : contains bitmask of enum wcd9xxx_resmgr_cond
 */
void wcd9xxx_regmgr_cond_register(struct wcd9xxx_resmgr *resmgr,
				  unsigned long condbits)
{
	unsigned int cond;

	for_each_set_bit(cond, &condbits, BITS_PER_BYTE * sizeof(condbits)) {
		mutex_lock(&resmgr->update_bit_cond_lock);
		WARN(test_bit(cond, &resmgr->cond_avail_flags),
		     "Condition 0x%0x is already registered\n", cond);
		set_bit(cond, &resmgr->cond_avail_flags);
		wcd9xxx_resmgr_cond_trigger_cond(resmgr, cond);
		mutex_unlock(&resmgr->update_bit_cond_lock);
		pr_debug("%s: Condition 0x%x is registered\n", __func__, cond);
	}
}

void wcd9xxx_regmgr_cond_deregister(struct wcd9xxx_resmgr *resmgr,
				    unsigned long condbits)
{
	unsigned int cond;

	for_each_set_bit(cond, &condbits, BITS_PER_BYTE * sizeof(condbits)) {
		mutex_lock(&resmgr->update_bit_cond_lock);
		WARN(!test_bit(cond, &resmgr->cond_avail_flags),
		     "Condition 0x%0x isn't registered\n", cond);
		clear_bit(cond, &resmgr->cond_avail_flags);
		wcd9xxx_resmgr_cond_trigger_cond(resmgr, cond);
		mutex_unlock(&resmgr->update_bit_cond_lock);
		pr_debug("%s: Condition 0x%x is deregistered\n", __func__,
			 cond);
	}
}

void wcd9xxx_resmgr_cond_update_cond(struct wcd9xxx_resmgr *resmgr,
				     enum wcd9xxx_resmgr_cond cond, bool set)
{
	mutex_lock(&resmgr->update_bit_cond_lock);
	if ((set && !test_and_set_bit(cond, &resmgr->cond_flags)) ||
	    (!set && test_and_clear_bit(cond, &resmgr->cond_flags))) {
		pr_debug("%s: Resource %d condition changed to %s\n", __func__,
			 cond, set ? "set" : "clear");
		wcd9xxx_resmgr_cond_trigger_cond(resmgr, cond);
	}
	mutex_unlock(&resmgr->update_bit_cond_lock);
}

int wcd9xxx_resmgr_add_cond_update_bits(struct wcd9xxx_resmgr *resmgr,
					enum wcd9xxx_resmgr_cond cond,
					unsigned short reg, int shift,
					bool invert)
{
	struct wcd9xxx_resmgr_cond_entry *entry;

	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
	if (!entry)
		return -ENOMEM;

	entry->cond = cond;
	entry->reg = reg;
	entry->shift = shift;
	entry->invert = invert;

	mutex_lock(&resmgr->update_bit_cond_lock);
	list_add_tail(&entry->list, &resmgr->update_bit_cond_h);

	wcd9xxx_resmgr_cond_trigger_cond(resmgr, cond);
	mutex_unlock(&resmgr->update_bit_cond_lock);

	return 0;
}

/*
 * wcd9xxx_resmgr_rm_cond_update_bits :
 * Clear bit and remove from the conditional bit update list
 */
int wcd9xxx_resmgr_rm_cond_update_bits(struct wcd9xxx_resmgr *resmgr,
				       enum wcd9xxx_resmgr_cond cond,
				       unsigned short reg, int shift,
				       bool invert)
{
	struct list_head *l, *next;
	struct wcd9xxx_resmgr_cond_entry *e = NULL;

	pr_debug("%s: enter\n", __func__);
	mutex_lock(&resmgr->update_bit_cond_lock);
	list_for_each_safe(l, next, &resmgr->update_bit_cond_h) {
		e = list_entry(l, struct wcd9xxx_resmgr_cond_entry, list);
		if (e->reg == reg && e->shift == shift && e->invert == invert) {
			snd_soc_update_bits(resmgr->codec, e->reg,
					    1 << e->shift,
					    e->invert << e->shift);
			list_del(&e->list);
			mutex_unlock(&resmgr->update_bit_cond_lock);
			kfree(e);
			return 0;
		}
	}
	mutex_unlock(&resmgr->update_bit_cond_lock);
	pr_err("%s: Cannot find update bit entry reg 0x%x, shift %d\n",
	       __func__, e ? e->reg : 0, e ? e->shift : 0);

	return -EINVAL;
}

int wcd9xxx_resmgr_register_notifier(struct wcd9xxx_resmgr *resmgr,
				     struct notifier_block *nblock)
{
	return blocking_notifier_chain_register(&resmgr->notifier, nblock);
}

int wcd9xxx_resmgr_unregister_notifier(struct wcd9xxx_resmgr *resmgr,
				       struct notifier_block *nblock)
{
	return blocking_notifier_chain_unregister(&resmgr->notifier, nblock);
}

int wcd9xxx_resmgr_init(struct wcd9xxx_resmgr *resmgr,
			struct snd_soc_codec *codec,
			struct wcd9xxx_core_resource *core_res,
			struct wcd9xxx_pdata *pdata,
			struct wcd9xxx_micbias_setting *micbias_pdata,
			struct wcd9xxx_reg_address *reg_addr,
			const struct wcd9xxx_resmgr_cb *resmgr_cb,
			enum wcd9xxx_cdc_type cdc_type)
{
	WARN(ARRAY_SIZE(wcd9xxx_event_string) != WCD9XXX_EVENT_LAST + 1,
	     "Event string table isn't up to date!, %zd != %d\n",
	     ARRAY_SIZE(wcd9xxx_event_string), WCD9XXX_EVENT_LAST + 1);

	resmgr->bandgap_type = WCD9XXX_BANDGAP_OFF;
	resmgr->codec = codec;
	resmgr->codec_type = cdc_type;
	/* This gives access of core handle to lock/unlock suspend */
	resmgr->core_res = core_res;
	resmgr->pdata = pdata;
	resmgr->micbias_pdata = micbias_pdata;
	resmgr->reg_addr = reg_addr;
	resmgr->resmgr_cb = resmgr_cb;

	INIT_LIST_HEAD(&resmgr->update_bit_cond_h);

	BLOCKING_INIT_NOTIFIER_HEAD(&resmgr->notifier);

	mutex_init(&resmgr->codec_resource_lock);
	mutex_init(&resmgr->codec_bg_clk_lock);
	mutex_init(&resmgr->update_bit_cond_lock);

	return 0;
}

void wcd9xxx_resmgr_deinit(struct wcd9xxx_resmgr *resmgr)
{
	mutex_destroy(&resmgr->update_bit_cond_lock);
	mutex_destroy(&resmgr->codec_bg_clk_lock);
	mutex_destroy(&resmgr->codec_resource_lock);
}

void wcd9xxx_resmgr_bcl_lock(struct wcd9xxx_resmgr *resmgr)
{
	mutex_lock(&resmgr->codec_resource_lock);
}

void wcd9xxx_resmgr_bcl_unlock(struct wcd9xxx_resmgr *resmgr)
{
	mutex_unlock(&resmgr->codec_resource_lock);
}

MODULE_DESCRIPTION("wcd9xxx resmgr module");
MODULE_LICENSE("GPL v2");
/* driver/i2c/chip/rt5506.c
 *
 * Richtek Headphone Amp
 *
 * Copyright (C) 2010 HTC Corporation
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include <linux/interrupt.h>
#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/irq.h>
#include <linux/miscdevice.h>
#include <asm/uaccess.h>
#include <linux/delay.h>
#include <linux/input.h>
#include <linux/workqueue.h>
#include <linux/freezer.h>
#include <mach/rt5506.h>
#include <linux/mutex.h>
#include <linux/debugfs.h>
#include <linux/gpio.h>
#include <linux/module.h>
#include <mach/htc_headset_mgr.h>
#include <linux/wakelock.h>
#include <linux/jiffies.h>
#include <linux/of_gpio.h>
#include <mach/htc_acoustic_alsa.h>

#define DEBUG (1)
#define AMP_ON_CMD_LEN 7
#define RETRY_CNT 5

#define DRIVER_NAME "RT5506"

static int set_rt5506_amp(int on, int dsp);

enum AMP_REG_MODE {
	REG_PWM_MODE = 0,
	REG_AUTO_MODE,
};

enum AMP_POWER_MASK {
	POWER_PLAYBACK = 0,
	POWER_IMPEDANCE,
	POWER_CMDLINE_TOOL,
	POWER_HIGH_IMP_RESET,
	POWER_MASK_MAX,
};

struct headset_query {
	struct mutex mlock;
	struct mutex gpiolock;
	struct delayed_work hs_imp_detec_work;
	struct wake_lock hs_wake_lock;
	struct wake_lock gpio_wake_lock;
	enum HEADSET_QUERY_STATUS hs_qstatus;
	enum AMP_STATUS rt5506_status;
	enum HEADSET_OM headsetom;
	enum PLAYBACK_MODE curmode;
	enum AMP_GPIO_STATUS gpiostatus;
	enum AMP_REG_MODE regstatus;
	int action_on;
	int gpio_off_cancel;
	struct mutex actionlock;
	struct delayed_work volume_ramp_work;
	struct delayed_work gpio_off_work;
	int hs_connec;
	unsigned long power_mask;
};

static struct i2c_client *this_client;
static struct rt5506_platform_data *pdata;
static int rt5506Connect = 0;

struct rt5506_config_data rt5506_config_data;
static struct mutex hp_amp_lock;
static int rt5506_opened;
static int last_spkamp_state;
struct rt5506_config RT5506_AMP_ON = {7,{{0x0,0xc0},{0x1,0x1c},{0x2,0x00},{0x7,0x7f},{0x9,0x1},{0xa,0x0},{0xb,0xc7},}};
struct rt5506_config RT5506_AMP_INIT = {11,{{0,0xc0},{0x81,0x30},{0x87,0xf6},{0x93,0x8d},{0x95,0x7d},{0xa4,0x52},\
                                        {0x96,0xae},{0x97,0x13},{0x99,0x35},{0x9b,0x68},{0x9d,0x68},}};

struct rt5506_config RT5506_AMP_MUTE = {1,{{0x1,0xC7},}};;
struct rt5506_config RT5506_AMP_OFF = {1,{{0x0,0x1},}};

static int rt5506_write_reg(u8 reg, u8 val);
static void hs_imp_detec_func(struct work_struct *work);
static int rt5506_i2c_read_addr(unsigned char *rxData, unsigned char addr);
static int rt5506_i2c_write(struct rt5506_reg_data *txData, int length);
static void set_amp(int on, struct rt5506_config *i2c_command);
struct headset_query rt5506_query;
static struct workqueue_struct *hs_wq;

static struct workqueue_struct *ramp_wq;
static struct workqueue_struct *gpio_wq;
static int high_imp = 0;

static int set_rt5506_regulator(enum AMP_REG_MODE mode)
{
	if(pdata->power_reg) {

		switch(mode) {
			case REG_PWM_MODE:
				pr_info("%s:set regulator to PWM mode\n",__func__);
				rpm_regulator_set_mode(pdata->power_reg,RPM_REGULATOR_MODE_HPM);
				break;

			case REG_AUTO_MODE:
				pr_info("%s:set regulator to AUTO mode\n",__func__);
				rpm_regulator_set_mode(pdata->power_reg,RPM_REGULATOR_MODE_AUTO);
				break;

			default:
				break;
		}
	}

	return 0;
}

static int need_power(unsigned long *addr)
{
	return (*addr != 0);
}

static void vote_power(unsigned long *addr, enum AMP_POWER_MASK bit)
{
	pr_info("%s: mask %d\n",__func__,bit);
	set_bit(bit,addr);

	if(need_power(addr) && rt5506_query.gpiostatus == AMP_GPIO_OFF) {
		pr_info("%s: enable gpio %d\n",__func__,pdata->gpio_rt5506_enable);
		if(rt5506_query.regstatus == REG_AUTO_MODE) {
			set_rt5506_regulator(REG_PWM_MODE);
			rt5506_query.regstatus = REG_PWM_MODE;
			msleep(1);
		}

		gpio_set_value(pdata->gpio_rt5506_enable, 1);
		rt5506_query.gpiostatus = AMP_GPIO_ON;
		usleep_range(20000,20000);
	}

}

static void unvote_power(unsigned long *addr, enum AMP_POWER_MASK bit)
{
	pr_info("%s: mask %d\n",__func__,bit);
	clear_bit(bit,addr);

	if(!need_power(addr) && rt5506_query.gpiostatus == AMP_GPIO_ON) {
		rt5506_query.gpio_off_cancel = 0;
		queue_delayed_work(gpio_wq, &rt5506_query.gpio_off_work, msecs_to_jiffies(0));
	}

}

static int rt5506_headset_detect(void *private_data, int on)
{

	if(!rt5506Connect)
		return 0;

	if(on) {
		mutex_lock(&rt5506_query.mlock);
		if(rt5506_query.hs_connec) {
			pr_info("%s: headset exist, ignore\n",__func__);
			mutex_unlock(&rt5506_query.mlock);
			return 0;
		}
		mutex_unlock(&rt5506_query.mlock);

		pr_info("%s: headset in ++\n",__func__);
		cancel_delayed_work_sync(&rt5506_query.hs_imp_detec_work);
		mutex_lock(&rt5506_query.gpiolock);
		mutex_lock(&rt5506_query.mlock);
		rt5506_query.hs_qstatus = QUERY_HEADSET;
		rt5506_query.headsetom = HEADSET_OM_UNDER_DETECT;

		if(rt5506_query.rt5506_status == STATUS_PLAYBACK) {

			if(high_imp) {
				rt5506_write_reg(1,0x7);
				rt5506_write_reg(0xb1,0x81);
			} else {
				rt5506_write_reg(1,0xc7);

			}

			last_spkamp_state = 0;
			pr_info("%s: OFF\n", __func__);

			rt5506_query.rt5506_status = STATUS_SUSPEND;
		}
		rt5506_query.hs_connec = 1;
		pr_info("%s: headset in --\n",__func__);
		mutex_unlock(&rt5506_query.mlock);
		mutex_unlock(&rt5506_query.gpiolock);
		
		queue_delayed_work(hs_wq,&rt5506_query.hs_imp_detec_work,msecs_to_jiffies(5));
		pr_info("%s: headset in --2\n",__func__);

	} else {

		mutex_lock(&rt5506_query.mlock);
		if(!rt5506_query.hs_connec) {
			pr_info("%s: headset isn't exist, ignore\n",__func__);
			mutex_unlock(&rt5506_query.mlock);
			return 0;
		}
		mutex_unlock(&rt5506_query.mlock);

		pr_info("%s: headset remove ++\n",__func__);
		cancel_delayed_work_sync(&rt5506_query.hs_imp_detec_work);
		flush_work_sync(&rt5506_query.volume_ramp_work.work);
		mutex_lock(&rt5506_query.gpiolock);
		mutex_lock(&rt5506_query.mlock);
		rt5506_query.hs_qstatus = QUERY_OFF;
		rt5506_query.headsetom = HEADSET_OM_UNDER_DETECT;

		if(rt5506_query.regstatus == REG_AUTO_MODE) {
			set_rt5506_regulator(REG_PWM_MODE);
			rt5506_query.regstatus = REG_PWM_MODE;
		}

		if(rt5506_query.rt5506_status == STATUS_PLAYBACK) {

			if(high_imp) {
				rt5506_write_reg(1,0x7);
				rt5506_write_reg(0xb1,0x81);

			} else {
				rt5506_write_reg(1,0xc7);

			}

			last_spkamp_state = 0;
			pr_info("%s: OFF\n", __func__);

			rt5506_query.rt5506_status = STATUS_SUSPEND;
		}

		if(high_imp) {
			vote_power(&rt5506_query.power_mask, POWER_HIGH_IMP_RESET);
			pr_info("%s: reset rt5501\n",__func__);
			rt5506_write_reg(0x0,0x4);
			mdelay(1);

			rt5506_write_reg(0x1,0xc7);
			high_imp = 0;
			unvote_power(&rt5506_query.power_mask, POWER_HIGH_IMP_RESET);
		}

		rt5506_query.curmode = PLAYBACK_MODE_OFF;
		rt5506_query.hs_connec = 0;
		pr_info("%s: headset remove --1\n",__func__);


		mutex_unlock(&rt5506_query.mlock);
		mutex_unlock(&rt5506_query.gpiolock);

		pr_info("%s: headset remove --2\n",__func__);

	}

	return 0;
}

static void rt5506_register_hs_notification(void)
{
#if 1
	struct hs_notify_t notifier;
	notifier.private_data = NULL;
	notifier.callback_f = rt5506_headset_detect;
	htc_acoustic_register_hs_notify(HS_AMP_N, &notifier);
#else

	rt5506_headset_detect(NULL,0);
#endif
}

static int rt5506_write_reg(u8 reg, u8 val)
{
	int err;
	struct i2c_msg msg[1];
	unsigned char data[2];

	msg->addr = this_client->addr;
	msg->flags = 0;
	msg->len = 2;
	msg->buf = data;
	data[0] = reg;
	data[1] = val;
        pr_info("%s: write reg 0x%x val 0x%x\n",__func__,data[0],data[1]); 
	err = i2c_transfer(this_client->adapter, msg, 1);
	if (err >= 0)
		return 0;
        else {

            pr_info("%s: write error error %d\n",__func__,err);
            return err;
        }
}

static int rt5506_i2c_write(struct rt5506_reg_data *txData, int length)
{
	int i, retry, pass = 0;
	char buf[2];
	struct i2c_msg msg[] = {
		{
		 .addr = this_client->addr,
		 .flags = 0,
		 .len = 2,
		 .buf = buf,
		},
	};
	for (i = 0; i < length; i++) {
		
		
		buf[0] = txData[i].addr;
		buf[1] = txData[i].val;

#if DEBUG
		pr_info("%s:i2c_write addr 0x%x val 0x%x\n", __func__,buf[0], buf[1]);
#endif
		msg->buf = buf;
		retry = RETRY_CNT;
		pass = 0;
		while (retry--) {
			if (i2c_transfer(this_client->adapter, msg, 1) < 0) {
				pr_err("%s: I2C transfer error %d retry %d\n",
						__func__, i, retry);
				msleep(20);
			} else {
				pass = 1;
				break;
			}
		}
		if (pass == 0) {
			pr_err("I2C transfer error, retry fail\n");
			return -EIO;
		}
	}
	return 0;
}

static int rt5506_i2c_read_addr(unsigned char *rxData, unsigned char addr)
{
	int rc;
	struct i2c_msg msgs[] = {
		{
		 .addr = this_client->addr,
		 .flags = 0,
		 .len = 1,
		 .buf = rxData,
		},
		{
		 .addr = this_client->addr,
		 .flags = I2C_M_RD,
		 .len = 1,
		 .buf = rxData,
		},
	};

	if(!rxData)
		return -1;

	*rxData = addr;

	rc = i2c_transfer(this_client->adapter, msgs, 2);
	if (rc < 0) {
		pr_err("%s:[1] transfer error %d\n", __func__, rc);
		return rc;
	}

	pr_info("%s:i2c_read addr 0x%x value = 0x%x\n", __func__, addr, *rxData);
	return 0;
}

static int rt5506_open(struct inode *inode, struct file *file)
{
	int rc = 0;

	mutex_lock(&hp_amp_lock);

	if (rt5506_opened) {
		pr_err("%s: busy\n", __func__);
		rc = -EBUSY;
		goto done;
	}
	rt5506_opened = 1;
done:
	mutex_unlock(&hp_amp_lock);
	return rc;
}

static int rt5506_release(struct inode *inode, struct file *file)
{
	mutex_lock(&hp_amp_lock);
	rt5506_opened = 0;
	mutex_unlock(&hp_amp_lock);

	return 0;
}

static void hs_imp_gpio_off(struct work_struct *work)
{
	u64 timeout = get_jiffies_64() + 3*HZ;
	wake_lock(&rt5506_query.gpio_wake_lock);

	while(1) {
		if(time_after64(get_jiffies_64(),timeout))
			break;
		else if(rt5506_query.gpio_off_cancel) {
			wake_unlock(&rt5506_query.gpio_wake_lock);
			return;
		} else
			msleep(10);
	}

	mutex_lock(&rt5506_query.gpiolock);
	if(!need_power(&rt5506_query.power_mask)) {
		pr_info("%s: disable gpio %d\n",__func__,pdata->gpio_rt5506_enable);
		gpio_set_value(pdata->gpio_rt5506_enable, 0);
		rt5506_query.gpiostatus = AMP_GPIO_OFF;

		if(rt5506_query.regstatus == REG_PWM_MODE) {
			set_rt5506_regulator(REG_AUTO_MODE);
			rt5506_query.regstatus = REG_AUTO_MODE;
		}
	}
	mutex_unlock(&rt5506_query.gpiolock);
	wake_unlock(&rt5506_query.gpio_wake_lock);
}

static void hs_imp_detec_func(struct work_struct *work)
{
	struct headset_query *hs;
	unsigned char temp[8]={0x1,};
	unsigned char r_channel;
	int ret;
	pr_info("%s: read rt5506 hs imp \n",__func__);

	hs = container_of(work, struct headset_query, hs_imp_detec_work.work);
	wake_lock(&hs->hs_wake_lock);

	rt5506_query.gpio_off_cancel = 1;
	cancel_delayed_work_sync(&rt5506_query.gpio_off_work);
	mutex_lock(&hs->gpiolock);
	mutex_lock(&hs->mlock);

	if(hs->hs_qstatus != QUERY_HEADSET) {
		mutex_unlock(&hs->mlock);
		mutex_unlock(&hs->gpiolock);
		wake_unlock(&hs->hs_wake_lock);
		return;
	}

	vote_power(&rt5506_query.power_mask, POWER_IMPEDANCE);

	rt5506_write_reg(0,0x04);
	rt5506_write_reg(0xa4,0x52);
	rt5506_write_reg(1,0x7);
	msleep(10);
	rt5506_write_reg(0x3,0x81);

	msleep(101);

	ret = rt5506_i2c_read_addr(temp,0x4);

	if(ret < 0) {
		pr_err("%s: read rt5506 status error %d\n",__func__,ret);

		unvote_power(&rt5506_query.power_mask, POWER_IMPEDANCE);
		mutex_unlock(&hs->mlock);
		mutex_unlock(&hs->gpiolock);
		wake_unlock(&hs->hs_wake_lock);
		return;
	}

	rt5506_i2c_read_addr(&r_channel,0x6);
	rt5506_write_reg(0x0,0x4);
	mdelay(1);

	rt5506_write_reg(0x0,0xc0);
	rt5506_write_reg(0x81,0x30);
	rt5506_write_reg(0x90,0xd0);
	rt5506_write_reg(0x93,0x9d);
	rt5506_write_reg(0x95,0x7b);
	rt5506_write_reg(0xa4,0x52);
	rt5506_write_reg(0x97,0x00);
	rt5506_write_reg(0x98,0x22);
	rt5506_write_reg(0x99,0x33);
	rt5506_write_reg(0x9a,0x55);
	rt5506_write_reg(0x9b,0x66);
	rt5506_write_reg(0x9c,0x99);
	rt5506_write_reg(0x9d,0x66);
	rt5506_write_reg(0x9e,0x99);


	high_imp = 0;

	if(temp[0] & AMP_SENSE_READY) {

		unsigned char om, hsmode;
		enum HEADSET_OM hsom;

		hsmode = (temp[0] & 0x30) >> 4;
		om = (temp[0] & 0xe) >> 1;

		if(r_channel == 0) {
			
			hsom = HEADSET_MONO;
		} else {

			switch(om) {
				case 0:
					hsom = HEADSET_8OM;
					break;
				case 1:
					hsom = HEADSET_16OM;
					break;
				case 2:
					hsom = HEADSET_32OM;
					break;
				case 3:
					hsom = HEADSET_64OM;
					break;
				case 4:
					hsom = HEADSET_128OM;
					break;
				case 5:
					hsom = HEADSET_256OM;
					break;
				case 6:
					hsom = HEADSET_500OM;
					break;
				case 7:
					hsom = HEADSET_1KOM;
					break;

				default:
					hsom = HEADSET_OM_UNDER_DETECT;
					break;
			}
		}

		hs->hs_qstatus = QUERY_FINISH;
		hs->headsetom = hsom;

		if(om >= HEADSET_256OM && om <= HEADSET_1KOM)
			high_imp = 1;

		pr_info("rt5506 hs imp value 0x%x hsmode %d om 0x%x hsom %d r_channel 0x%x high_imp %d\n",\
			temp[0] & 0xf,hsmode,om,hsom,r_channel,high_imp);
	} else {

		if(hs->hs_qstatus == QUERY_HEADSET)
			queue_delayed_work(hs_wq,&rt5506_query.hs_imp_detec_work,QUERY_LATTER);
	}

	if(high_imp) {
		rt5506_write_reg(0xb1,0x81);
		rt5506_write_reg(0x80,0x87);
		rt5506_write_reg(0x83,0xc3);
		rt5506_write_reg(0x84,0x63);
		rt5506_write_reg(0x89,0x7);
		mdelay(9);
		rt5506_write_reg(0x83,0xcf);
		rt5506_write_reg(0x89,0x1d);
		mdelay(1);

		rt5506_write_reg(1,0x7);
		rt5506_write_reg(0xb1,0x81);
	} else {

		rt5506_write_reg(1,0xc7);
	}

	if(hs->rt5506_status == STATUS_PLAYBACK)
		hs->rt5506_status = STATUS_SUSPEND;

	unvote_power(&rt5506_query.power_mask, POWER_IMPEDANCE);
	mutex_unlock(&hs->mlock);
	mutex_unlock(&hs->gpiolock);

	if(hs->rt5506_status == STATUS_SUSPEND)
		set_rt5506_amp(1,0);

	wake_unlock(&hs->hs_wake_lock);
}

static void volume_ramp_func(struct work_struct *work)
{
	set_amp(1, &RT5506_AMP_ON);
}

static void set_amp(int on, struct rt5506_config *i2c_command)
{
	pr_info("%s: %d\n", __func__, on);
	mutex_lock(&rt5506_query.mlock);
	mutex_lock(&hp_amp_lock);

	if(rt5506_query.hs_qstatus == QUERY_HEADSET)
		rt5506_query.hs_qstatus = QUERY_FINISH;

	if (on) {
		if(rt5506_query.rt5506_status != STATUS_PLAYBACK) {

			mdelay(1);
			
			if(high_imp)
				rt5506_write_reg(0xb1,0x80);

			rt5506_write_reg(0x2,0x0);
			mdelay(1);
		}

		rt5506_query.rt5506_status = STATUS_PLAYBACK;
		if (rt5506_i2c_write(i2c_command->reg, i2c_command->reg_len) == 0) {
			last_spkamp_state = 1;
			pr_info("%s: ON \n",__func__);
		}

	} else {

		if(high_imp) {
			rt5506_write_reg(1,0x7);
			rt5506_write_reg(0xb1,0x81);
		} else {
			rt5506_write_reg(1,0xc7);
		}

		if(rt5506_query.rt5506_status == STATUS_PLAYBACK) {
			last_spkamp_state = 0;
			pr_info("%s: OFF\n", __func__);
		}
		rt5506_query.rt5506_status = STATUS_OFF;
		rt5506_query.curmode = PLAYBACK_MODE_OFF;
	}
	mutex_unlock(&hp_amp_lock);
	mutex_unlock(&rt5506_query.mlock);
}

int query_rt5506(void)
{
    return rt5506Connect;
}

static int set_rt5506_amp(int on, int dsp)
{
	if(!rt5506Connect)
		return 0;

	pr_info("%s: %d\n", __func__, on);
	mutex_lock(&rt5506_query.actionlock);
	rt5506_query.gpio_off_cancel = 1;
	if(!on)
		rt5506_query.action_on = 0;
	cancel_delayed_work_sync(&rt5506_query.gpio_off_work);
	cancel_delayed_work_sync(&rt5506_query.volume_ramp_work);
	
	mutex_lock(&rt5506_query.gpiolock);

	if(on) {
		vote_power(&rt5506_query.power_mask, POWER_PLAYBACK);
		rt5506_query.action_on = 1;
		queue_delayed_work(ramp_wq, &rt5506_query.volume_ramp_work, msecs_to_jiffies(0));

	} else {
		set_amp(0, &RT5506_AMP_ON);
		unvote_power(&rt5506_query.power_mask, POWER_PLAYBACK);
	}

	mutex_unlock(&rt5506_query.gpiolock);
	mutex_unlock(&rt5506_query.actionlock);

	return 0;
}

static int update_amp_parameter(int mode)
{
	if (mode >= rt5506_config_data.mode_num)
		return -EINVAL;

        pr_info("%s: set mode %d\n", __func__, mode);

	if (mode == PLAYBACK_MODE_OFF)
		memcpy(&RT5506_AMP_OFF, &rt5506_config_data.cmd_data[mode].config,
				sizeof(struct rt5506_config));
	else if (mode == AMP_INIT)
		memcpy(&RT5506_AMP_INIT, &rt5506_config_data.cmd_data[mode].config,
				sizeof(struct rt5506_config));
	else if (mode == AMP_MUTE)
		memcpy(&RT5506_AMP_MUTE, &rt5506_config_data.cmd_data[mode].config,
				sizeof(struct rt5506_config));
	else {
		memcpy(&RT5506_AMP_ON, &rt5506_config_data.cmd_data[mode].config,
				sizeof(struct rt5506_config));
	}
	return 0;
}


static long rt5506_ioctl(struct file *file, unsigned int cmd,
	   unsigned long arg)
{
	void __user *argp = (void __user *)arg;
	int rc = 0, modeid = 0;
	int premode = 0;
	struct amp_ctrl ampctrl;
	struct rt5506_reg_data reg;

	switch (cmd) {
	case AMP_SET_MODE:
		if (copy_from_user(&modeid, argp, sizeof(modeid)))
			return -EFAULT;

		if (!rt5506_config_data.cmd_data) {
			pr_err("%s: out of memory\n", __func__);
			return -ENOMEM;
		}

		if (modeid >= rt5506_config_data.mode_num || modeid < 0) {
			pr_err("unsupported rt5506 mode %d\n", modeid);
			return -EINVAL;
		}
		mutex_lock(&hp_amp_lock);
		premode = rt5506_query.curmode;
		rt5506_query.curmode = modeid;
		rc = update_amp_parameter(modeid);
		mutex_unlock(&hp_amp_lock);
		pr_info("%s:set rt5506 mode to %d curstatus %d\n", __func__,modeid,rt5506_query.rt5506_status);
		mutex_lock(&rt5506_query.actionlock);
		if(rt5506_query.rt5506_status == STATUS_PLAYBACK && premode != rt5506_query.curmode) {
			flush_work_sync(&rt5506_query.volume_ramp_work.work);
			rt5506_query.action_on = 1;
			queue_delayed_work(ramp_wq, &rt5506_query.volume_ramp_work, msecs_to_jiffies(280));
		}
		mutex_unlock(&rt5506_query.actionlock);
		break;
	case AMP_SET_PARAM:
		mutex_lock(&hp_amp_lock);
		if (copy_from_user(&rt5506_config_data.mode_num, argp, sizeof(unsigned int))) {
			pr_err("%s: copy from user failed.\n", __func__);
			mutex_unlock(&hp_amp_lock);
			return -EFAULT;
		}

		if (rt5506_config_data.mode_num <= 0) {
			pr_err("%s: invalid mode number %d\n",
					__func__, rt5506_config_data.mode_num);
			mutex_unlock(&hp_amp_lock);
			return -EINVAL;
		}
		if (rt5506_config_data.cmd_data == NULL)
			rt5506_config_data.cmd_data = kzalloc(sizeof(struct rt5506_comm_data)*rt5506_config_data.mode_num, GFP_KERNEL);

		if (!rt5506_config_data.cmd_data) {
			pr_err("%s: out of memory\n", __func__);
			mutex_unlock(&hp_amp_lock);
			return -ENOMEM;
		}

		if (copy_from_user(rt5506_config_data.cmd_data, ((struct rt5506_config_data*)argp)->cmd_data \
			,sizeof(struct rt5506_comm_data)*rt5506_config_data.mode_num)) {
			pr_err("%s: copy data from user failed.\n", __func__);
			kfree(rt5506_config_data.cmd_data);
			rt5506_config_data.cmd_data = NULL;
			mutex_unlock(&hp_amp_lock);
			return -EFAULT;
		}

		pr_info("%s: update rt5506 i2c commands #%d success.\n",
				__func__, rt5506_config_data.mode_num);
		
		update_amp_parameter(PLAYBACK_MODE_OFF);
		update_amp_parameter(AMP_MUTE);
		update_amp_parameter(AMP_INIT);
		mutex_unlock(&hp_amp_lock);
		rc = 0;
		break;
	case AMP_QUERY_OM:
		mutex_lock(&rt5506_query.mlock);
		rc = rt5506_query.headsetom;
		mutex_unlock(&rt5506_query.mlock);
		pr_info("%s: query headset om %d\n", __func__,rc);

		if (copy_to_user(argp, &rc, sizeof(rc)))
			rc = -EFAULT;
		else
			rc = 0;
		break;
	case ACOUSTIC_AMP_CTRL:
		if (copy_from_user(&ampctrl, argp, sizeof(ampctrl)))
			return -EFAULT;

		if(!this_client)
			return -EFAULT;

		if(ampctrl.slave != AUD_AMP_SLAVE_ALL && ampctrl.slave != this_client->addr)
			break;

		mutex_lock(&rt5506_query.gpiolock);
		mutex_lock(&rt5506_query.mlock);
		mutex_lock(&hp_amp_lock);

		rc = 0;
		vote_power(&rt5506_query.power_mask, POWER_CMDLINE_TOOL);
		if(ampctrl.ctrl == AMP_WRITE) {
			reg.addr = (unsigned char)ampctrl.reg;
			reg.val = (unsigned char)ampctrl.val;
			rt5506_write_reg(reg.addr,reg.val);
		} else if (ampctrl.ctrl == AMP_READ) {
			reg.addr = (unsigned char)ampctrl.reg;
			rt5506_i2c_read_addr(&reg.val, reg.addr);
			ampctrl.val = (unsigned int)reg.val;

			if (copy_to_user(argp, &ampctrl, sizeof(ampctrl)))
				rc = -EFAULT;
		}
		unvote_power(&rt5506_query.power_mask, POWER_CMDLINE_TOOL);
		mutex_unlock(&hp_amp_lock);
		mutex_unlock(&rt5506_query.mlock);
		mutex_unlock(&rt5506_query.gpiolock);
		break;
	default:
		pr_err("%s: Invalid command\n", __func__);
		rc = -EINVAL;
		break;
	}
	return rc;
}

static int rt550_parse_pfdata(struct device *dev, struct rt5506_platform_data *ppdata)
{
	struct device_node *dt = dev->of_node;
	enum of_gpio_flags flags;
	int ret;

	pdata->gpio_rt5506_enable = -EINVAL;
	pdata->power_supply = NULL;
	pdata->power_reg = NULL;

	if (dt) {
		pdata->gpio_rt5506_enable = of_get_named_gpio_flags(dt,"richtek,enable-gpio",0, &flags);
		ret = of_property_read_string(dt,"power_supply",&pdata->power_supply);

		if(ret < 0) {
			pdata->power_supply = NULL;
			pr_err("%s:parse power supply fail\n",__func__);
		}

	} else {
		if(dev->platform_data) {
			pdata->gpio_rt5506_enable = ((struct rt5506_platform_data *)dev->platform_data)->gpio_rt5506_enable;
			pdata->power_supply = ((struct rt5506_platform_data *)dev->platform_data)->power_supply;
		}
	}

	pr_info("%s: rt5506 gpio %d\n",__func__,pdata->gpio_rt5506_enable);

	if(pdata->power_supply)
		pr_info("%s:power supply %s\n",__func__,pdata->power_supply);

	if(pdata->power_supply != NULL) {
		pdata->power_reg = rpm_regulator_get(NULL, pdata->power_supply);

		if (IS_ERR(pdata->power_reg)) {
			pdata->power_reg = NULL;
			pr_err("%s: reqest regulator %s fail\n",__func__,pdata->power_supply);
		}
	}

	if(gpio_is_valid(pdata->gpio_rt5506_enable))
		return 0;
	else
		return -EINVAL;
}

static struct file_operations rt5506_fops = {
	.owner = THIS_MODULE,
	.open = rt5506_open,
	.release = rt5506_release,
	.unlocked_ioctl = rt5506_ioctl,
};

static struct miscdevice rt5506_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "rt5501",
	.fops = &rt5506_fops,
};

int rt5506_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	int ret = 0;
	int err = 0;

	pr_info("rt5506_probe");
	htc_amp_power_enable(true);

	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		pr_err("%s: i2c check functionality error\n", __func__);
		ret = -ENODEV;
		goto err_alloc_data_failed;
	}

	if (pdata == NULL) {

		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
		if (pdata == NULL) {
			ret = -ENOMEM;
			pr_err("%s: platform data is NULL\n", __func__);
			goto err_alloc_data_failed;
		}
	}

	if(rt550_parse_pfdata(&client->dev, pdata) < 0)
		goto err_free_allocated_mem;

	this_client = client;

	if(1) {
		unsigned char temp[2];

		err = gpio_request(pdata->gpio_rt5506_enable, "hp_en_rt5506");
		if(err)
			pr_err("%s:gpio request %d error %d\n",__func__,pdata->gpio_rt5506_enable,err);
#if 1
		pr_info("%s:[1]current gpio %d value %d\n",__func__,pdata->gpio_rt5506_enable,gpio_get_value(pdata->gpio_rt5506_enable));
		ret = gpio_direction_output(pdata->gpio_rt5506_enable, 1);

		if(ret < 0) {
			pr_err("%s: gpio %d on error %d\n", __func__,pdata->gpio_rt5506_enable,ret);
		}
#endif
#if 0
		gpio_direction_output(pdata->gpio_rt5506_enable, 0);
		pr_info("%s:[t-1]current gpio %d value %d\n",__func__,pdata->gpio_rt5506_enable,gpio_get_value(pdata->gpio_rt5506_enable));
		mdelay(10);

		gpio_direction_output(pdata->gpio_rt5506_enable, 1);
		pr_info("%s:[t-2]current gpio %d value %d\n",__func__,pdata->gpio_rt5506_enable,gpio_get_value(pdata->gpio_rt5506_enable));
#endif
		mdelay(10);
		pr_info("%s:[2]current gpio %d value %d\n",__func__,pdata->gpio_rt5506_enable,gpio_get_value(pdata->gpio_rt5506_enable));
		rt5506_write_reg(0,0x04);
		mdelay(5);
		rt5506_write_reg(0x0,0xc0);
		rt5506_write_reg(0x81,0x30);
		
		rt5506_write_reg(0x90,0xd0);
		rt5506_write_reg(0x93,0x9d);
		rt5506_write_reg(0x95,0x7b);
		rt5506_write_reg(0xa4,0x52);
		
		rt5506_write_reg(0x97,0x00);
		rt5506_write_reg(0x98,0x22);
		rt5506_write_reg(0x99,0x33);
		rt5506_write_reg(0x9a,0x55);
		rt5506_write_reg(0x9b,0x66);
		rt5506_write_reg(0x9c,0x99);
		rt5506_write_reg(0x9d,0x66);
		rt5506_write_reg(0x9e,0x99);

		rt5506_write_reg(0x1,0xc7);
		mdelay(10);
		ret = rt5506_i2c_read_addr(temp, 0x1);
		if(ret < 0) {
			pr_info("rt5506 is not connected\n");
			rt5506Connect = 0;
		} else {
			pr_info("rt5506 is connected\n");
			rt5506Connect = 1;
		}
		rt5506Connect = 1;

		gpio_set_value(pdata->gpio_rt5506_enable, 0);

	}

	if(rt5506Connect) {
		htc_acoustic_register_hs_amp(set_rt5506_amp,&rt5506_fops);
		ret = misc_register(&rt5506_device);
		if (ret) {
			pr_err("%s: rt5506_device register failed\n", __func__);
			goto err_free_allocated_mem;
		}

		hs_wq = create_workqueue("rt5506_hsdetect");
		INIT_DELAYED_WORK(&rt5506_query.hs_imp_detec_work,hs_imp_detec_func);
		wake_lock_init(&rt5506_query.hs_wake_lock, WAKE_LOCK_SUSPEND, "rt5506 hs wakelock");
		wake_lock_init(&rt5506_query.gpio_wake_lock, WAKE_LOCK_SUSPEND, "rt5506 gpio wakelock");
		ramp_wq = create_workqueue("rt5506_volume_ramp");
		INIT_DELAYED_WORK(&rt5506_query.volume_ramp_work, volume_ramp_func);
		gpio_wq = create_workqueue("rt5506_gpio_off");
		INIT_DELAYED_WORK(&rt5506_query.gpio_off_work, hs_imp_gpio_off);
		rt5506_register_hs_notification();
		

	}
	return 0;

err_free_allocated_mem:
	if(pdata)
		kfree(pdata);
err_alloc_data_failed:
        rt5506Connect = 0;
	return ret;
}

static int rt5506_remove(struct i2c_client *client)
{
	struct rt5506_platform_data *p5501data = i2c_get_clientdata(client);
	pr_info("%s:\n",__func__);
	if(p5501data)
		kfree(p5501data);

        if(rt5506Connect) {
            misc_deregister(&rt5506_device);
            cancel_delayed_work_sync(&rt5506_query.hs_imp_detec_work);
            destroy_workqueue(hs_wq);
        }
	return 0;
}

static void rt5506_shutdown(struct i2c_client *client)
{
	rt5506_query.gpio_off_cancel = 1;
	cancel_delayed_work_sync(&rt5506_query.gpio_off_work);
	cancel_delayed_work_sync(&rt5506_query.volume_ramp_work);

	mutex_lock(&rt5506_query.gpiolock);
	mutex_lock(&hp_amp_lock);
	mutex_lock(&rt5506_query.mlock);

	if(rt5506_query.gpiostatus == AMP_GPIO_OFF) {

		if(rt5506_query.regstatus == REG_AUTO_MODE) {
			set_rt5506_regulator(REG_PWM_MODE);
			rt5506_query.regstatus = REG_PWM_MODE;
			msleep(1);
		}

		pr_info("%s: enable gpio %d\n",__func__,pdata->gpio_rt5506_enable);
		gpio_set_value(pdata->gpio_rt5506_enable, 1);
		rt5506_query.gpiostatus = AMP_GPIO_ON;
		usleep_range(20000,20000);
	}
	pr_info("%s: reset rt5501\n",__func__);
	rt5506_write_reg(0x0,0x4);
	mdelay(1);

	high_imp = 0;

	rt5506_query.power_mask = 0;

	if(rt5506_query.gpiostatus == AMP_GPIO_ON) {
		pr_info("%s: disable gpio %d\n",__func__,pdata->gpio_rt5506_enable);
		gpio_set_value(pdata->gpio_rt5506_enable, 0);
		rt5506_query.gpiostatus = AMP_GPIO_OFF;

		if(rt5506_query.regstatus == REG_PWM_MODE) {
			set_rt5506_regulator(REG_AUTO_MODE);
			rt5506_query.regstatus = REG_AUTO_MODE;
		}
	}

	rt5506Connect = 0;

	mutex_unlock(&rt5506_query.mlock);
	mutex_unlock(&hp_amp_lock);
	mutex_unlock(&rt5506_query.gpiolock);

}

static int rt5506_suspend(struct i2c_client *client, pm_message_t mesg)
{
	return 0;
}

static int rt5506_resume(struct i2c_client *client)
{
	return 0;
}

static struct of_device_id rt5506_match_table[] = {
	{ .compatible = "richtek,rt5506-amp",},
	{ },
};

static const struct i2c_device_id rt5506_id[] = {
	{ RT5506_I2C_NAME, 0 },
	{ }
};

static struct i2c_driver rt5506_driver = {
	.probe = rt5506_probe,
	.remove = rt5506_remove,
	.shutdown = rt5506_shutdown,
	.suspend = rt5506_suspend,
	.resume = rt5506_resume,
	.id_table = rt5506_id,
	.driver = {
		.owner	= THIS_MODULE,
		.name = RT5506_I2C_NAME,
		.of_match_table = rt5506_match_table,
	},
};

static int __init rt5506_init(void)
{
	pr_info("%s\n", __func__);
	mutex_init(&hp_amp_lock);
	mutex_init(&rt5506_query.mlock);
	mutex_init(&rt5506_query.gpiolock);
	mutex_init(&rt5506_query.actionlock);
	rt5506_query.rt5506_status = STATUS_OFF;
	rt5506_query.hs_qstatus = QUERY_OFF;
	rt5506_query.headsetom = HEADSET_8OM;
	rt5506_query.curmode = PLAYBACK_MODE_OFF;
	rt5506_query.gpiostatus = AMP_GPIO_OFF;
	rt5506_query.regstatus = REG_AUTO_MODE;
	rt5506_query.hs_connec = 0;
	rt5506_query.power_mask = 0;
	return i2c_add_driver(&rt5506_driver);
}

static void __exit rt5506_exit(void)
{
	i2c_del_driver(&rt5506_driver);

	if(pdata->power_reg)
		rpm_regulator_put(pdata->power_reg);
}

module_init(rt5506_init);
module_exit(rt5506_exit);

MODULE_DESCRIPTION("rt5506 Headphone Amp driver");
MODULE_LICENSE("GPL");
/*
 * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
 * reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directory of this source tree, or the NetLogic
 * license below:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/linkage.h>
#include <linux/interrupt.h>
#include <linux/spinlock.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/irq.h>

#include <asm/errno.h>
#include <asm/signal.h>
#include <asm/ptrace.h>
#include <asm/mipsregs.h>
#include <asm/thread_info.h>

#include <asm/netlogic/mips-extns.h>
#include <asm/netlogic/interrupt.h>
#include <asm/netlogic/haldefs.h>
#include <asm/netlogic/common.h>

#if defined(CONFIG_CPU_XLP)
#include <asm/netlogic/xlp-hal/iomap.h>
#include <asm/netlogic/xlp-hal/xlp.h>
#include <asm/netlogic/xlp-hal/pic.h>
#elif defined(CONFIG_CPU_XLR)
#include <asm/netlogic/xlr/iomap.h>
#include <asm/netlogic/xlr/pic.h>
#else
#error "Unknown CPU"
#endif
/*
 * These are the routines that handle all the low level interrupt stuff.
 * Actions handled here are: initialization of the interrupt map, requesting of
 * interrupt lines by handlers, dispatching if interrupts to handlers, probing
 * for interrupt lines
 */

/* Globals */
static uint64_t nlm_irq_mask;
static DEFINE_SPINLOCK(nlm_pic_lock);

static void xlp_pic_enable(struct irq_data *d)
{
	unsigned long flags;
	int irt;

	irt = nlm_irq_to_irt(d->irq);
	if (irt == -1)
		return;
	spin_lock_irqsave(&nlm_pic_lock, flags);
	nlm_pic_enable_irt(nlm_pic_base, irt);
	spin_unlock_irqrestore(&nlm_pic_lock, flags);
}

static void xlp_pic_disable(struct irq_data *d)
{
	unsigned long flags;
	int irt;

	irt = nlm_irq_to_irt(d->irq);
	if (irt == -1)
		return;
	spin_lock_irqsave(&nlm_pic_lock, flags);
	nlm_pic_disable_irt(nlm_pic_base, irt);
	spin_unlock_irqrestore(&nlm_pic_lock, flags);
}

static void xlp_pic_mask_ack(struct irq_data *d)
{
	uint64_t mask = 1ull << d->irq;

	write_c0_eirr(mask);            /* ack by writing EIRR */
}

static void xlp_pic_unmask(struct irq_data *d)
{
	void *hd = irq_data_get_irq_handler_data(d);
	int irt;

	irt = nlm_irq_to_irt(d->irq);
	if (irt == -1)
		return;

	if (hd) {
		void (*extra_ack)(void *) = hd;
		extra_ack(d);
	}
	/* Ack is a single write, no need to lock */
	nlm_pic_ack(nlm_pic_base, irt);
}

static struct irq_chip xlp_pic = {
	.name		= "XLP-PIC",
	.irq_enable	= xlp_pic_enable,
	.irq_disable	= xlp_pic_disable,
	.irq_mask_ack	= xlp_pic_mask_ack,
	.irq_unmask	= xlp_pic_unmask,
};

static void cpuintr_disable(struct irq_data *d)
{
	uint64_t eimr;
	uint64_t mask = 1ull << d->irq;

	eimr = read_c0_eimr();
	write_c0_eimr(eimr & ~mask);
}

static void cpuintr_enable(struct irq_data *d)
{
	uint64_t eimr;
	uint64_t mask = 1ull << d->irq;

	eimr = read_c0_eimr();
	write_c0_eimr(eimr | mask);
}

static void cpuintr_ack(struct irq_data *d)
{
	uint64_t mask = 1ull << d->irq;

	write_c0_eirr(mask);
}

static void cpuintr_nop(struct irq_data *d)
{
	WARN(d->irq >= PIC_IRQ_BASE, "Bad irq %d", d->irq);
}

/*
 * Chip definition for CPU originated interrupts(timer, msg) and
 * IPIs
 */
struct irq_chip nlm_cpu_intr = {
	.name		= "XLP-CPU-INTR",
	.irq_enable	= cpuintr_enable,
	.irq_disable	= cpuintr_disable,
	.irq_mask	= cpuintr_nop,
	.irq_ack	= cpuintr_nop,
	.irq_eoi	= cpuintr_ack,
};

void __init init_nlm_common_irqs(void)
{
	int i, irq, irt;

	for (i = 0; i < PIC_IRT_FIRST_IRQ; i++)
		irq_set_chip_and_handler(i, &nlm_cpu_intr, handle_percpu_irq);

	for (i = PIC_IRT_FIRST_IRQ; i <= PIC_IRT_LAST_IRQ ; i++)
		irq_set_chip_and_handler(i, &xlp_pic, handle_level_irq);

#ifdef CONFIG_SMP
	irq_set_chip_and_handler(IRQ_IPI_SMP_FUNCTION, &nlm_cpu_intr,
			 nlm_smp_function_ipi_handler);
	irq_set_chip_and_handler(IRQ_IPI_SMP_RESCHEDULE, &nlm_cpu_intr,
			 nlm_smp_resched_ipi_handler);
	nlm_irq_mask |=
	    ((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
#endif

	for (irq = PIC_IRT_FIRST_IRQ; irq <= PIC_IRT_LAST_IRQ; irq++) {
		irt = nlm_irq_to_irt(irq);
		if (irt == -1)
			continue;
		nlm_irq_mask |= (1ULL << irq);
		nlm_pic_init_irt(nlm_pic_base, irt, irq, 0);
	}

	nlm_irq_mask |= (1ULL << IRQ_TIMER);
}

void __init arch_init_irq(void)
{
	/* Initialize the irq descriptors */
	init_nlm_common_irqs();

	write_c0_eimr(nlm_irq_mask);
}

void nlm_smp_irq_init(void)
{
	/* set interrupt mask for non-zero cpus */
	write_c0_eimr(nlm_irq_mask);
}

asmlinkage void plat_irq_dispatch(void)
{
	uint64_t eirr;
	int i;

	eirr = read_c0_eirr() & read_c0_eimr();
	if (eirr & (1 << IRQ_TIMER)) {
		do_IRQ(IRQ_TIMER);
		return;
	}

	i = __ilog2_u64(eirr);
	if (i == -1)
		return;

	do_IRQ(i);
}
/*
 * Common SMP CPU bringup/teardown functions
 */
#include <linux/cpu.h>
#include <linux/err.h>
#include <linux/smp.h>
#include <linux/init.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/export.h>
#include <linux/percpu.h>
#include <linux/kthread.h>
#include <linux/smpboot.h>
#include <linux/kmemleak.h>

#include "smpboot.h"

#ifdef CONFIG_SMP

#ifdef CONFIG_GENERIC_SMP_IDLE_THREAD
/*
 * For the hotplug case we keep the task structs around and reuse
 * them.
 */
static DEFINE_PER_CPU(struct task_struct *, idle_threads);

struct task_struct * __cpuinit idle_thread_get(unsigned int cpu)
{
	struct task_struct *tsk = per_cpu(idle_threads, cpu);

	if (!tsk)
		return ERR_PTR(-ENOMEM);
	init_idle(tsk, cpu);
	return tsk;
}

void __init idle_thread_set_boot_cpu(void)
{
	per_cpu(idle_threads, smp_processor_id()) = current;
}

/**
 * idle_init - Initialize the idle thread for a cpu
 * @cpu:	The cpu for which the idle thread should be initialized
 *
 * Creates the thread if it does not exist.
 */
static inline void idle_init(unsigned int cpu)
{
	struct task_struct *tsk = per_cpu(idle_threads, cpu);

	if (!tsk) {
		tsk = fork_idle(cpu);
		if (IS_ERR(tsk))
			pr_err("SMP: fork_idle() failed for CPU %u\n", cpu);
		else
			per_cpu(idle_threads, cpu) = tsk;
	}
}

/**
 * idle_threads_init - Initialize idle threads for all cpus
 */
void __init idle_threads_init(void)
{
	unsigned int cpu, boot_cpu;

	boot_cpu = smp_processor_id();

	for_each_possible_cpu(cpu) {
		if (cpu != boot_cpu)
			idle_init(cpu);
	}
}
#endif

#endif /* #ifdef CONFIG_SMP */

static LIST_HEAD(hotplug_threads);
static DEFINE_MUTEX(smpboot_threads_lock);

struct smpboot_thread_data {
	unsigned int			cpu;
	unsigned int			status;
	struct smp_hotplug_thread	*ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE,
	HP_THREAD_PARKED,
};

/**
 * smpboot_thread_fn - percpu hotplug thread loop function
 * @data:	thread data pointer
 *
 * Checks for thread stop and park conditions. Calls the necessary
 * setup, cleanup, park and unpark functions for the registered
 * thread.
 *
 * Returns 1 when the thread should exit, 0 otherwise.
 */
static int smpboot_thread_fn(void *data)
{
	struct smpboot_thread_data *td = data;
	struct smp_hotplug_thread *ht = td->ht;

	while (1) {
		set_current_state(TASK_INTERRUPTIBLE);
		preempt_disable();
		if (kthread_should_stop()) {
			__set_current_state(TASK_RUNNING);
			preempt_enable();
			if (ht->cleanup)
				ht->cleanup(td->cpu, cpu_online(td->cpu));
			kfree(td);
			return 0;
		}

		if (kthread_should_park()) {
			__set_current_state(TASK_RUNNING);
			preempt_enable();
			if (ht->park && td->status == HP_THREAD_ACTIVE) {
				BUG_ON(td->cpu != smp_processor_id());
				ht->park(td->cpu);
				td->status = HP_THREAD_PARKED;
			}
			kthread_parkme();
			/* We might have been woken for stop */
			continue;
		}

		BUG_ON(td->cpu != smp_processor_id());

		/* Check for state change setup */
		switch (td->status) {
		case HP_THREAD_NONE:
			__set_current_state(TASK_RUNNING);
			preempt_enable();
			if (ht->setup)
				ht->setup(td->cpu);
			td->status = HP_THREAD_ACTIVE;
			continue;

		case HP_THREAD_PARKED:
			__set_current_state(TASK_RUNNING);
			preempt_enable();
			if (ht->unpark)
				ht->unpark(td->cpu);
			td->status = HP_THREAD_ACTIVE;
			continue;
		}

		if (!ht->thread_should_run(td->cpu)) {
			preempt_enable_no_resched();
			schedule();
		} else {
			__set_current_state(TASK_RUNNING);
			preempt_enable();
			ht->thread_fn(td->cpu);
		}
	}
}

static int
__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)
{
	struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);
	struct smpboot_thread_data *td;

	if (tsk)
		return 0;

	td = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));
	if (!td)
		return -ENOMEM;

	kmemleak_not_leak(td);
	td->cpu = cpu;
	td->ht = ht;

	tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu,
				    ht->thread_comm);
	if (IS_ERR(tsk)) {
		kfree(td);
		return PTR_ERR(tsk);
	}
	get_task_struct(tsk);
	*per_cpu_ptr(ht->store, cpu) = tsk;
	if (ht->create) {
		/*
		 * Make sure that the task has actually scheduled out
		 * into park position, before calling the create
		 * callback. At least the migration thread callback
		 * requires that the task is off the runqueue.
		 */
		if (!wait_task_inactive(tsk, TASK_PARKED))
			WARN_ON(1);
		else
			ht->create(cpu);
	}
	return 0;
}

int smpboot_create_threads(unsigned int cpu)
{
	struct smp_hotplug_thread *cur;
	int ret = 0;

	mutex_lock(&smpboot_threads_lock);
	list_for_each_entry(cur, &hotplug_threads, list) {
		ret = __smpboot_create_thread(cur, cpu);
		if (ret)
			break;
	}
	mutex_unlock(&smpboot_threads_lock);
	return ret;
}

static void smpboot_unpark_thread(struct smp_hotplug_thread *ht, unsigned int cpu)
{
	struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);

	if (ht->pre_unpark)
		ht->pre_unpark(cpu);
	kthread_unpark(tsk);
}

void smpboot_unpark_threads(unsigned int cpu)
{
	struct smp_hotplug_thread *cur;

	mutex_lock(&smpboot_threads_lock);
	list_for_each_entry(cur, &hotplug_threads, list)
		smpboot_unpark_thread(cur, cpu);
	mutex_unlock(&smpboot_threads_lock);
}

static void smpboot_park_thread(struct smp_hotplug_thread *ht, unsigned int cpu)
{
	struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);

	if (tsk && !ht->selfparking)
		kthread_park(tsk);
}

void smpboot_park_threads(unsigned int cpu)
{
	struct smp_hotplug_thread *cur;

	mutex_lock(&smpboot_threads_lock);
	list_for_each_entry_reverse(cur, &hotplug_threads, list)
		smpboot_park_thread(cur, cpu);
	mutex_unlock(&smpboot_threads_lock);
}

static void smpboot_destroy_threads(struct smp_hotplug_thread *ht)
{
	unsigned int cpu;

	/* We need to destroy also the parked threads of offline cpus */
	for_each_possible_cpu(cpu) {
		struct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);

		if (tsk) {
			kthread_stop(tsk);
			put_task_struct(tsk);
			*per_cpu_ptr(ht->store, cpu) = NULL;
		}
	}
}

/**
 * smpboot_register_percpu_thread - Register a per_cpu thread related to hotplug
 * @plug_thread:	Hotplug thread descriptor
 *
 * Creates and starts the threads on all online cpus.
 */
int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)
{
	unsigned int cpu;
	int ret = 0;

	get_online_cpus();
	mutex_lock(&smpboot_threads_lock);
	for_each_online_cpu(cpu) {
		ret = __smpboot_create_thread(plug_thread, cpu);
		if (ret) {
			smpboot_destroy_threads(plug_thread);
			goto out;
		}
		smpboot_unpark_thread(plug_thread, cpu);
	}
	list_add(&plug_thread->list, &hotplug_threads);
out:
	mutex_unlock(&smpboot_threads_lock);
	put_online_cpus();
	return ret;
}
EXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);

/**
 * smpboot_unregister_percpu_thread - Unregister a per_cpu thread related to hotplug
 * @plug_thread:	Hotplug thread descriptor
 *
 * Stops all threads on all possible cpus.
 */
void smpboot_unregister_percpu_thread(struct smp_hotplug_thread *plug_thread)
{
	get_online_cpus();
	mutex_lock(&smpboot_threads_lock);
	list_del(&plug_thread->list);
	smpboot_destroy_threads(plug_thread);
	mutex_unlock(&smpboot_threads_lock);
	put_online_cpus();
}
EXPORT_SYMBOL_GPL(smpboot_unregister_percpu_thread);
# NPUH10023, ULJM05492 - ARMORED CORE 3 Portable
[VR]
UnitsPerMetre = 1.0
HudThickness = 0.1
HudDistance = 3
CameraForward = 2.5
CameraPitch = 0.0
AimDistance = 40.0
MinFOV = 0.0
ScreenHeight = 1.0
ScreenThickness = 0.2
ScreenDistance = 1.5
ScreenRight = 0.0
ScreenUp = 0.0
ScreenPitch = 0.0
TelescopeMaxFOV = 0.0
Disable3D = False
HudFullscreen = False
TelescopeEye = 0
MetroidPrime = 0
HudOnTop = False
Invert2DOrthoDepth = False
Invert2DThroughDepth = False
DontClearScreen = True
CanReadCameraAngles = False
ReadPitch = 180.0
DetectSkybox = False
DontDrawScreenSpace = True
Before3DIsBackground = False
OverrideClearColor = False
BackgroundColor = -16777216
CPUSpeed = 0
VRStateId = 4
VRIssues = FMV issues, minor issues with mech shadows when far, camera angles
/*
  zip_filerange_crc.c -- compute CRC32 for a range of a file
  Copyright (C) 2008 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifdef _MSC_VER
#pragma warning (disable:4996)
#pragma warning (disable:4244)
#endif

#include <stdio.h>
#include <errno.h>

#include "zipint.h"




int
_zip_filerange_crc(FILE *fp, off_t start, off_t len, uLong *crcp,
		   struct zip_error *errp)
{
    Bytef buf[BUFSIZE];
    size_t n;

    *crcp = crc32(0L, Z_NULL, 0);

    if (fseeko(fp, start, SEEK_SET) != 0) {
	_zip_error_set(errp, ZIP_ER_SEEK, errno);
	return -1;
    }
    
    while (len > 0) {
	n = len > BUFSIZE ? BUFSIZE : len;
	if ((n=fread(buf, 1, n, fp)) <= 0) {
	    _zip_error_set(errp, ZIP_ER_READ, errno);
	    return -1;
	}

	*crcp = crc32(*crcp, buf, (uInt)n);

	len-= (off_t)n;
    }

    return 0;
}
/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include "msm_sensor.h"
#include <mach/board_lge.h>		//to use lge_get_board_revno()

#define IMX208_SENSOR_NAME "imx208"
DEFINE_MSM_MUTEX(imx208_mut);

#define CONFIG_IMX208_DEBUG

#undef CDBG
#ifdef CONFIG_IMX208_DEBUG
#define CDBG(fmt, args...) pr_err(fmt, ##args)
#else
#define CDBG(fmt, args...) do { } while (0)
#endif

static struct msm_sensor_ctrl_t imx208_s_ctrl;
#if defined(CONFIG_MACH_MSM8974_G3_GLOBAL_COM) || defined(CONFIG_MACH_MSM8974_G3_ATT)|| defined(CONFIG_MACH_MSM8974_G3_VZW) || defined(CONFIG_MACH_MSM8974_G3_CA)
static struct msm_sensor_power_setting imx208_power_setting_rev_b[] = {
	{  /* Set GPIO_RESET to low to disable power on reset*/
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_LOW,
		.delay = 1,
	},
	{  //VDIG, PMIC_GPIO 10
		.seq_type = SENSOR_VREG, //VREG_L18
		.seq_val = CAM_VANA,
		.config_val = 0,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_GPIO, //VDD DIG GPIO 89
		.seq_val = SENSOR_GPIO_VDIG,
		.config_val = GPIO_OUT_HIGH,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_VREG, //VREG_LVS2
		.seq_val = CAM_VIO,
		.config_val = 0,
		.delay = 5,
	},
	{
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_HIGH,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_CLK,
		.seq_val = SENSOR_CAM_MCLK,
		.config_val = 0,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_I2C_MUX,
		.seq_val = 0,
		.config_val = 0,
		.delay = 10,
	},
};
#else
static struct msm_sensor_power_setting imx208_power_setting_rev_b[] = {
	{  /* Set GPIO_RESET to low to disable power on reset*/
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_LOW,
		.delay = 1,
	},
	{  //VDIG, PMIC_GPIO 10
		.seq_type = SENSOR_VREG, //VREG_L18
		.seq_val = CAM_VANA,
		.config_val = 0,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_VREG, //VREG_L3
		.seq_val = CAM_VDIG,
		.config_val = 0,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_VREG, //VREG_LVS2
		.seq_val = CAM_VIO,
		.config_val = 0,
		.delay = 5,
	},
	{
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_HIGH,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_CLK,
		.seq_val = SENSOR_CAM_MCLK,
		.config_val = 0,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_I2C_MUX,
		.seq_val = 0,
		.config_val = 0,
		.delay = 10,
	},
};
#endif

static struct msm_sensor_power_setting imx208_power_setting_rev_a[] = {
	{  /* Set GPIO_RESET to low to disable power on reset*/
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_LOW,
		.delay = 1,
	},
	{  //VDIG, PMIC_GPIO 10
		.seq_type = SENSOR_VREG,
		.seq_val = CAM_VANA,
		.config_val = 0,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_VREG,
		.seq_val = CAM_VDIG,
		.config_val = 0,
		.delay = 0,
	},
	{
		.seq_type = SENSOR_VREG,
		.seq_val = CAM_VIO,
		.config_val = 0,
		.delay = 5,
	},
	{
		.seq_type = SENSOR_GPIO,
		.seq_val = SENSOR_GPIO_RESET,
		.config_val = GPIO_OUT_HIGH,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_CLK,
		.seq_val = SENSOR_CAM_MCLK,
		.config_val = 0,
		.delay = 50,
	},
	{
		.seq_type = SENSOR_I2C_MUX,
		.seq_val = 0,
		.config_val = 0,
		.delay = 10,
	},
};

static struct v4l2_subdev_info imx208_subdev_info[] = {
	{
		.code		= V4L2_MBUS_FMT_SBGGR10_1X10,
		.colorspace	= V4L2_COLORSPACE_JPEG,
		.fmt		= 1,
		.order		= 0,
	},
};

static const struct i2c_device_id imx208_i2c_id[] = {
	{IMX208_SENSOR_NAME, (kernel_ulong_t)&imx208_s_ctrl},
	{ }
};

static int32_t msm_imx208_i2c_probe(struct i2c_client *client,
	const struct i2c_device_id *id)
{
	return msm_sensor_i2c_probe(client, id, &imx208_s_ctrl);
}

static struct i2c_driver imx208_i2c_driver = {
	.id_table = imx208_i2c_id,
	.probe  = msm_imx208_i2c_probe,
	.driver = {
		.name = IMX208_SENSOR_NAME,
	},
};

static struct msm_camera_i2c_client imx208_sensor_i2c_client = {
	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
};

static const struct of_device_id imx208_dt_match[] = {
	{.compatible = "qcom,imx208", .data = &imx208_s_ctrl},
	{}
};

MODULE_DEVICE_TABLE(of, imx208_dt_match);

static struct platform_driver imx208_platform_driver = {
	.driver = {
		.name = "qcom,imx208",
		.owner = THIS_MODULE,
		.of_match_table = imx208_dt_match,
	},
};

static int32_t imx208_platform_probe(struct platform_device *pdev)
{
	int32_t rc = 0;
	const struct of_device_id *match;
	CDBG("%s E\n", __func__);
	match = of_match_device(imx208_dt_match, &pdev->dev);
	if (!match) {
		pr_err(" %s failed ",__func__);
		return -ENODEV;
	}

	rc = msm_sensor_platform_probe(pdev, match->data);
	CDBG("%s: X, rc = %d\n", __func__, rc);
	return rc;
}

static int __init imx208_init_module(void)
{
	int32_t rc = 0;
	CDBG("%s E\n", __func__);
#ifdef CONFIG_MACH_LGE
		switch(lge_get_board_revno()) {
			case HW_REV_A:
				CDBG("%s: Sensor power is set REV An", __func__);
				imx208_s_ctrl.power_setting_array.power_setting = imx208_power_setting_rev_a;
				imx208_s_ctrl.power_setting_array.size = ARRAY_SIZE(imx208_power_setting_rev_a);
				break;
			case HW_REV_B:
			default:
				CDBG("%s: Sensor power is set REV B\n", __func__);
				imx208_s_ctrl.power_setting_array.power_setting = imx208_power_setting_rev_b;
				imx208_s_ctrl.power_setting_array.size = ARRAY_SIZE(imx208_power_setting_rev_b);
				break;
		}
#endif

	rc = platform_driver_probe(&imx208_platform_driver,
		imx208_platform_probe);
	if (!rc) {
		CDBG("%s: X, rc = %d\n", __func__, rc);
		return rc;
	}
	return i2c_add_driver(&imx208_i2c_driver);
}

static void __exit imx208_exit_module(void)
{
	if (imx208_s_ctrl.pdev) {
		msm_sensor_free_sensor_data(&imx208_s_ctrl);
		platform_driver_unregister(&imx208_platform_driver);
	} else
		i2c_del_driver(&imx208_i2c_driver);
	return;
}

static struct msm_sensor_ctrl_t imx208_s_ctrl = {
	.sensor_i2c_client = &imx208_sensor_i2c_client,
#ifndef CONFIG_MACH_LGE
	.power_setting_array.power_setting = imx208_power_setting,
	.power_setting_array.size = ARRAY_SIZE(imx208_power_setting),
#endif
	.msm_sensor_mutex = &imx208_mut,
	.sensor_v4l2_subdev_info = imx208_subdev_info,
	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx208_subdev_info),
};

module_init(imx208_init_module);
module_exit(imx208_exit_module);
MODULE_DESCRIPTION("imx208");
MODULE_LICENSE("GPL v2");
/*
 * Misc utility routines for accessing chip-specific features
 * of the SiliconBackplane-based Broadcom chips.
 *
 * Copyright (C) 1999-2015, Broadcom Corporation
 * 
 *      Unless you and Broadcom execute a separate written software license
 * agreement governing use of this software, this software is licensed to you
 * under the terms of the GNU General Public License version 2 (the "GPL"),
 * available at http://www.broadcom.com/licenses/GPLv2.php, with the
 * following added to such license:
 * 
 *      As a special exception, the copyright holders of this software give you
 * permission to link this software with independent modules, and to copy and
 * distribute the resulting executable under terms of your choice, provided that
 * you also meet, for each linked independent module, the terms and conditions of
 * the license of that module.  An independent module is a module which is not
 * derived from this software.  The special exception does not apply to any
 * modifications of the software.
 * 
 *      Notwithstanding the above, under no circumstances may you combine this
 * software in any way with any other Broadcom software provided under a license
 * other than the GPL, without Broadcom's express prior written consent.
 *
 * $Id: siutils.c 497460 2014-08-19 15:14:13Z $
 */

#include <bcm_cfg.h>
#include <typedefs.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmutils.h>
#include <siutils.h>
#include <bcmdevs.h>
#include <hndsoc.h>
#include <sbchipc.h>
#include <pcicfg.h>
#include <sbpcmcia.h>
#include <sbsocram.h>
#ifdef BCMSDIO
#include <bcmsdh.h>
#include <sdio.h>
#include <sbsdio.h>
#include <sbhnddma.h>
#include <sbsdpcmdev.h>
#include <bcmsdpcm.h>
#endif /* BCMSDIO */
#include <hndpmu.h>
#ifdef BCMSPI
#include <spid.h>
#endif /* BCMSPI */

#ifdef BCM_SDRBL
#include <hndcpu.h>
#endif /* BCM_SDRBL */
#ifdef HNDGCI
#include <hndgci.h>
#endif /* HNDGCI */

#include "siutils_priv.h"

/**
 * A set of PMU registers is clocked in the ILP domain, which has an implication on register write
 * behavior: if such a register is written, it takes multiple ILP clocks for the PMU block to absorb
 * the write. During that time the 'SlowWritePending' bit in the PMUStatus register is set.
 */
#define PMUREGS_ILP_SENSITIVE(regoff) \
	((regoff) == OFFSETOF(pmuregs_t, pmutimer) || \
	 (regoff) == OFFSETOF(pmuregs_t, pmuwatchdog) || \
	 (regoff) == OFFSETOF(pmuregs_t, res_req_timer))

#define CHIPCREGS_ILP_SENSITIVE(regoff) \
	((regoff) == OFFSETOF(chipcregs_t, pmutimer) || \
	 (regoff) == OFFSETOF(chipcregs_t, pmuwatchdog) || \
	 (regoff) == OFFSETOF(chipcregs_t, res_req_timer))

/* local prototypes */
static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
                              uint bustype, void *sdh, char **vars, uint *varsz);
static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid, void *sdh);
static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype, uint32 savewin,
	uint *origidx, void *regs);


static bool si_pmu_is_ilp_sensitive(uint32 idx, uint regoff);

#ifdef BCMLTECOEX
static void si_config_gcigpio(si_t *sih, uint32 gci_pos, uint8 gcigpio,
	uint8 gpioctl_mask, uint8 gpioctl_val);
#endif /* BCMLTECOEX */

#ifdef CUSTOMER_HW4
#ifdef CONFIG_MACH_UNIVERSAL5433
extern int check_rev(void);
extern int check_pcie_link_status(void);
#endif /* CONFIG_MACH_UNIVERSAL5433 */
#endif /* CUSTOMER_HW4 */


/* global variable to indicate reservation/release of gpio's */
static uint32 si_gpioreservation = 0;

/* global flag to prevent shared resources from being initialized multiple times in si_attach() */
#ifdef SR_DEBUG
static const uint32 si_power_island_test_array[] = {
	0x0000, 0x0001, 0x0010, 0x0011,
	0x0100, 0x0101, 0x0110, 0x0111,
	0x1000, 0x1001, 0x1010, 0x1011,
	0x1100, 0x1101, 0x1110, 0x1111
};
#endif /* SR_DEBUG */

int do_4360_pcie2_war = 0;

/* global kernel resource */
static si_info_t ksii;
static si_cores_info_t ksii_cores_info;

/**
 * Allocate an si handle. This function may be called multiple times.
 *
 * devid - pci device id (used to determine chip#)
 * osh - opaque OS handle
 * regs - virtual address of initial core registers
 * bustype - pci/pcmcia/sb/sdio/etc
 * vars - pointer to a to-be created pointer area for "environment" variables. Some callers of this
 *        function set 'vars' to NULL, making dereferencing of this parameter undesired.
 * varsz - pointer to int to return the size of the vars
 */
si_t *
si_attach(uint devid, osl_t *osh, void *regs,
                       uint bustype, void *sdh, char **vars, uint *varsz)
{
	si_info_t *sii;
	si_cores_info_t *cores_info;
	/* alloc si_info_t */
	if ((sii = MALLOCZ(osh, sizeof (si_info_t))) == NULL) {
		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n", MALLOCED(osh)));
		return (NULL);
	}

	/* alloc si_cores_info_t */
	if ((cores_info = (si_cores_info_t *)MALLOCZ(osh, sizeof (si_cores_info_t))) == NULL) {
		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n", MALLOCED(osh)));
		MFREE(osh, sii, sizeof(si_info_t));
		return (NULL);
	}
	sii->cores_info = cores_info;

	if (si_doattach(sii, devid, osh, regs, bustype, sdh, vars, varsz) == NULL) {
		MFREE(osh, sii, sizeof(si_info_t));
		MFREE(osh, cores_info, sizeof(si_cores_info_t));
		return (NULL);
	}
	sii->vars = vars ? *vars : NULL;
	sii->varsz = varsz ? *varsz : 0;

	return (si_t *)sii;
}


static uint32	wd_msticks;		/* watchdog timer ticks normalized to ms */

/** generic kernel variant of si_attach() */
si_t *
si_kattach(osl_t *osh)
{
	static bool ksii_attached = FALSE;
	si_cores_info_t *cores_info;

	if (!ksii_attached) {
		void *regs = NULL;
		regs = REG_MAP(SI_ENUM_BASE, SI_CORE_SIZE);
		cores_info = (si_cores_info_t *)&ksii_cores_info;
		ksii.cores_info = cores_info;

		ASSERT(osh);
		if (si_doattach(&ksii, BCM4710_DEVICE_ID, osh, regs,
		                SI_BUS, NULL,
		                osh != SI_OSH ? &(ksii.vars) : NULL,
		                osh != SI_OSH ? &(ksii.varsz) : NULL) == NULL) {
			SI_ERROR(("si_kattach: si_doattach failed\n"));
			REG_UNMAP(regs);
			return NULL;
		}
		REG_UNMAP(regs);

		/* save ticks normalized to ms for si_watchdog_ms() */
		if (PMUCTL_ENAB(&ksii.pub)) {
				/* based on 32KHz ILP clock */
				wd_msticks = 32;
		} else {
			wd_msticks = ALP_CLOCK / 1000;
		}

		ksii_attached = TRUE;
		SI_MSG(("si_kattach done. ccrev = %d, wd_msticks = %d\n",
		        ksii.pub.ccrev, wd_msticks));
	}

	return &ksii.pub;
}


static bool
si_buscore_prep(si_info_t *sii, uint bustype, uint devid, void *sdh)
{
	/* need to set memseg flag for CF card first before any sb registers access */
	if (BUSTYPE(bustype) == PCMCIA_BUS)
		sii->memseg = TRUE;


#if defined(BCMSDIO)
	if (BUSTYPE(bustype) == SDIO_BUS) {
		int err;
		uint8 clkset;

		/* Try forcing SDIO core to do ALPAvail request only */
		clkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;
		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, clkset, &err);
		if (!err) {
			uint8 clkval;

			/* If register supported, wait for ALPAvail and then force ALP */
			clkval = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, NULL);
			if ((clkval & ~SBSDIO_AVBITS) == clkset) {
				SPINWAIT(((clkval = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
					SBSDIO_FUNC1_CHIPCLKCSR, NULL)), !SBSDIO_ALPAV(clkval)),
					PMU_MAX_TRANSITION_DLY);
				if (!SBSDIO_ALPAV(clkval)) {
					SI_ERROR(("timeout on ALPAV wait, clkval 0x%02x\n",
						clkval));
					return FALSE;
				}
				clkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP;
				bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
					clkset, &err);
				OSL_DELAY(65);
			}
		}

		/* Also, disable the extra SDIO pull-ups */
		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SDIOPULLUP, 0, NULL);
	}

#ifdef BCMSPI
	/* Avoid backplane accesses before wake-wlan (i.e. htavail) for spi.
	 * F1 read accesses may return correct data but with data-not-available dstatus bit set.
	 */
	if (BUSTYPE(bustype) == SPI_BUS) {

		int err;
		uint32 regdata;
		/* wake up wlan function :WAKE_UP goes as HT_AVAIL request in hardware */
		regdata = bcmsdh_cfg_read_word(sdh, SDIO_FUNC_0, SPID_CONFIG, NULL);
		SI_MSG(("F0 REG0 rd = 0x%x\n", regdata));
		regdata |= WAKE_UP;

		bcmsdh_cfg_write_word(sdh, SDIO_FUNC_0, SPID_CONFIG, regdata, &err);

		OSL_DELAY(100000);
	}
#endif /* BCMSPI */
#endif /* BCMSDIO && BCMDONGLEHOST */

	return TRUE;
}

static bool
si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype, uint32 savewin,
	uint *origidx, void *regs)
{
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	bool pci, pcie, pcie_gen2 = FALSE;
	uint i;
	uint pciidx, pcieidx, pcirev, pcierev;

	cc = si_setcoreidx(&sii->pub, SI_CC_IDX);
	ASSERT((uintptr)cc);

	/* get chipcommon rev */
	sii->pub.ccrev = (int)si_corerev(&sii->pub);

	/* get chipcommon chipstatus */
	if (sii->pub.ccrev >= 11)
		sii->pub.chipst = R_REG(sii->osh, &cc->chipstatus);

	/* get chipcommon capabilites */
	sii->pub.cccaps = R_REG(sii->osh, &cc->capabilities);
	/* get chipcommon extended capabilities */

	if (sii->pub.ccrev >= 35)
		sii->pub.cccaps_ext = R_REG(sii->osh, &cc->capabilities_ext);

	/* get pmu rev and caps */
	if (sii->pub.cccaps & CC_CAP_PMU) {
		if (AOB_ENAB(&sii->pub)) {
			uint pmucoreidx;
			pmuregs_t *pmu;
			pmucoreidx = si_findcoreidx(&sii->pub, PMU_CORE_ID, 0);
			pmu = si_setcoreidx(&sii->pub, pmucoreidx);
			sii->pub.pmucaps = R_REG(sii->osh, &pmu->pmucapabilities);
			si_setcoreidx(&sii->pub, SI_CC_IDX);
		} else
			sii->pub.pmucaps = R_REG(sii->osh, &cc->pmucapabilities);

		sii->pub.pmurev = sii->pub.pmucaps & PCAP_REV_MASK;
	}

	SI_MSG(("Chipc: rev %d, caps 0x%x, chipst 0x%x pmurev %d, pmucaps 0x%x\n",
		sii->pub.ccrev, sii->pub.cccaps, sii->pub.chipst, sii->pub.pmurev,
		sii->pub.pmucaps));

	/* figure out bus/orignal core idx */
	sii->pub.buscoretype = NODEV_CORE_ID;
	sii->pub.buscorerev = (uint)NOREV;
	sii->pub.buscoreidx = BADIDX;

	pci = pcie = FALSE;
	pcirev = pcierev = (uint)NOREV;
	pciidx = pcieidx = BADIDX;

	for (i = 0; i < sii->numcores; i++) {
		uint cid, crev;

		si_setcoreidx(&sii->pub, i);
		cid = si_coreid(&sii->pub);
		crev = si_corerev(&sii->pub);

		/* Display cores found */
		SI_VMSG(("CORE[%d]: id 0x%x rev %d base 0x%x regs 0x%p\n",
		        i, cid, crev, cores_info->coresba[i], cores_info->regs[i]));

		if (BUSTYPE(bustype) == SI_BUS) {
			/* now look at the chipstatus register to figure the pacakge */
			/* for SDIO but downloaded on PCIE dev */
			if (cid == PCIE2_CORE_ID) {
				if ((CHIPID(sii->pub.chip) == BCM43602_CHIP_ID) ||
					((CHIPID(sii->pub.chip) == BCM4345_CHIP_ID) &&
					CST4345_CHIPMODE_PCIE(sii->pub.chipst))) {
					pcieidx = i;
					pcierev = crev;
					pcie = TRUE;
					pcie_gen2 = TRUE;
				}
			}

		}
		else if (BUSTYPE(bustype) == PCI_BUS) {
			if (cid == PCI_CORE_ID) {
				pciidx = i;
				pcirev = crev;
				pci = TRUE;
			} else if ((cid == PCIE_CORE_ID) || (cid == PCIE2_CORE_ID)) {
				pcieidx = i;
				pcierev = crev;
				pcie = TRUE;
				if (cid == PCIE2_CORE_ID)
					pcie_gen2 = TRUE;
			}
		} else if ((BUSTYPE(bustype) == PCMCIA_BUS) &&
		           (cid == PCMCIA_CORE_ID)) {
			sii->pub.buscorerev = crev;
			sii->pub.buscoretype = cid;
			sii->pub.buscoreidx = i;
		}
#ifdef BCMSDIO
		else if (((BUSTYPE(bustype) == SDIO_BUS) ||
		          (BUSTYPE(bustype) == SPI_BUS)) &&
		         ((cid == PCMCIA_CORE_ID) ||
		          (cid == SDIOD_CORE_ID))) {
			sii->pub.buscorerev = crev;
			sii->pub.buscoretype = cid;
			sii->pub.buscoreidx = i;
		}
#endif /* BCMSDIO */

		/* find the core idx before entering this func. */
		if ((savewin && (savewin == cores_info->coresba[i])) ||
		    (regs == cores_info->regs[i]))
			*origidx = i;
	}

#if defined(PCIE_FULL_DONGLE)
	pci = FALSE;
#endif
	if (pci) {
		sii->pub.buscoretype = PCI_CORE_ID;
		sii->pub.buscorerev = pcirev;
		sii->pub.buscoreidx = pciidx;
	} else if (pcie) {
		if (pcie_gen2)
			sii->pub.buscoretype = PCIE2_CORE_ID;
		else
			sii->pub.buscoretype = PCIE_CORE_ID;
		sii->pub.buscorerev = pcierev;
		sii->pub.buscoreidx = pcieidx;
	}

	SI_VMSG(("Buscore id/type/rev %d/0x%x/%d\n", sii->pub.buscoreidx, sii->pub.buscoretype,
	         sii->pub.buscorerev));

	if (BUSTYPE(sii->pub.bustype) == SI_BUS && (CHIPID(sii->pub.chip) == BCM4712_CHIP_ID) &&
	    (sii->pub.chippkg != BCM4712LARGE_PKG_ID) && (CHIPREV(sii->pub.chiprev) <= 3))
		OR_REG(sii->osh, &cc->slow_clk_ctl, SCC_SS_XTAL);


#if defined(BCMSDIO)
	/* Make sure any on-chip ARM is off (in case strapping is wrong), or downloaded code was
	 * already running.
	 */
	if ((BUSTYPE(bustype) == SDIO_BUS) || (BUSTYPE(bustype) == SPI_BUS)) {
		if (si_setcore(&sii->pub, ARM7S_CORE_ID, 0) ||
		    si_setcore(&sii->pub, ARMCM3_CORE_ID, 0))
			si_core_disable(&sii->pub, 0);
	}
#endif /* BCMSDIO && BCMDONGLEHOST */

	/* return to the original core */
	si_setcoreidx(&sii->pub, *origidx);

	return TRUE;
}




uint16
si_chipid(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);

	return (sii->chipnew) ? sii->chipnew : sih->chip;
}

static void
si_chipid_fixup(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);

	ASSERT(sii->chipnew == 0);
	switch (sih->chip) {
		case BCM43570_CHIP_ID:
		case BCM4358_CHIP_ID:
			sii->chipnew = sih->chip; /* save it */
			sii->pub.chip = BCM43569_CHIP_ID; /* chip class */
		break;
		case BCM4356_CHIP_ID:
			sii->chipnew = sih->chip; /* save it */
			sii->pub.chip = BCM4354_CHIP_ID; /* chip class */
		break;
		default:
		ASSERT(0);
		break;
	}
}

/**
 * Allocate an si handle. This function may be called multiple times.
 *
 * vars - pointer to a to-be created pointer area for "environment" variables. Some callers of this
 *        function set 'vars' to NULL.
 */
static si_info_t *
si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
                       uint bustype, void *sdh, char **vars, uint *varsz)
{
	struct si_pub *sih = &sii->pub;
	uint32 w, savewin;
	chipcregs_t *cc;
	char *pvars = NULL;
	uint origidx;
#if !defined(_CFEZ_) || defined(CFG_WL)
#endif 

	ASSERT(GOODREGS(regs));

	savewin = 0;

	sih->buscoreidx = BADIDX;

	sii->curmap = regs;
	sii->sdh = sdh;
	sii->osh = osh;


	/* check to see if we are a si core mimic'ing a pci core */
	if ((bustype == PCI_BUS) &&
	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(uint32)) == 0xffffffff)) {
		SI_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SI "
		          "devid:0x%x\n", __FUNCTION__, devid));
#ifdef CUSTOMER_HW4
#ifdef CONFIG_MACH_UNIVERSAL5433
		/* old revision */
		if (!check_rev()) {
			/* abnormal link status */
			if (!check_pcie_link_status()) {
				printk("%s : PCIE LINK is abnormal status\n", __FUNCTION__);
				return NULL;
			}
		}
#endif /* CONFIG_MACH_UNIVERSAL5433 */
#endif /* CUSTOMER_HW4 */
		bustype = SI_BUS;
	}

	/* find Chipcommon address */
	if (bustype == PCI_BUS) {
		savewin = OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
		if (!GOODCOREADDR(savewin, SI_ENUM_BASE))
			savewin = SI_ENUM_BASE;
		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, SI_ENUM_BASE);
		if (!regs)
			return NULL;
		cc = (chipcregs_t *)regs;
#ifdef BCMSDIO
	} else if ((bustype == SDIO_BUS) || (bustype == SPI_BUS)) {
		cc = (chipcregs_t *)sii->curmap;
#endif
	} else {
		cc = (chipcregs_t *)REG_MAP(SI_ENUM_BASE, SI_CORE_SIZE);
	}

	sih->bustype = bustype;
	if (bustype != BUSTYPE(bustype)) {
		SI_ERROR(("si_doattach: bus type %d does not match configured bus type %d\n",
			bustype, BUSTYPE(bustype)));
		return NULL;
	}

	/* bus/core/clk setup for register access */
	if (!si_buscore_prep(sii, bustype, devid, sdh)) {
		SI_ERROR(("si_doattach: si_core_clk_prep failed %d\n", bustype));
		return NULL;
	}

	/* ChipID recognition.
	*   We assume we can read chipid at offset 0 from the regs arg.
	*   If we add other chiptypes (or if we need to support old sdio hosts w/o chipcommon),
	*   some way of recognizing them needs to be added here.
	*/
	if (!cc) {
		SI_ERROR(("%s: chipcommon register space is null \n", __FUNCTION__));
		return NULL;
	}
#ifdef COSTOMER_HW4
#ifdef CONFIG_MACH_UNIVERSAL5433
	/* old revision check */
	if (!check_rev()) {
		/* abnormal link status */
		if (!check_pcie_link_status()) {
			printk("%s : PCIE LINK is abnormal status\n", __FUNCTION__);
			return NULL;
		}
	}
#endif /* CONFIG_MACH_UNIVERSAL5433 */
#endif /* CUSTOMER_HW4 */
	w = R_REG(osh, &cc->chipid);
	if ((w & 0xfffff) == 148277) w -= 65532;
	sih->socitype = (w & CID_TYPE_MASK) >> CID_TYPE_SHIFT;
	/* Might as wll fill in chip id rev & pkg */
	sih->chip = w & CID_ID_MASK;
	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;

	if ((sih->chip == BCM4358_CHIP_ID) ||
		(sih->chip == BCM43570_CHIP_ID) ||
		(sih->chip == BCM4358_CHIP_ID)) {
		si_chipid_fixup(sih);
	}

	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 0) &&
		(sih->chippkg != BCM4329_289PIN_PKG_ID)) {
		sih->chippkg = BCM4329_182PIN_PKG_ID;
	}
	sih->issim = IS_SIM(sih->chippkg);

	/* scan for cores */
	if (CHIPTYPE(sii->pub.socitype) == SOCI_SB) {
		SI_MSG(("Found chip type SB (0x%08x)\n", w));
		sb_scan(&sii->pub, regs, devid);
	} else if ((CHIPTYPE(sii->pub.socitype) == SOCI_AI) ||
		(CHIPTYPE(sii->pub.socitype) == SOCI_NAI)) {
		if (CHIPTYPE(sii->pub.socitype) == SOCI_AI)
			SI_MSG(("Found chip type AI (0x%08x)\n", w));
		else
			SI_MSG(("Found chip type NAI (0x%08x)\n", w));
		/* pass chipc address instead of original core base */
		ai_scan(&sii->pub, (void *)(uintptr)cc, devid);
	} else if (CHIPTYPE(sii->pub.socitype) == SOCI_UBUS) {
		SI_MSG(("Found chip type UBUS (0x%08x), chip id = 0x%4x\n", w, sih->chip));
		/* pass chipc address instead of original core base */
		ub_scan(&sii->pub, (void *)(uintptr)cc, devid);
	} else {
		SI_ERROR(("Found chip of unknown type (0x%08x)\n", w));
		return NULL;
	}
	/* no cores found, bail out */
	if (sii->numcores == 0) {
		SI_ERROR(("si_doattach: could not find any cores\n"));
		return NULL;
	}
	/* bus/core/clk setup */
	origidx = SI_CC_IDX;
	if (!si_buscore_setup(sii, cc, bustype, savewin, &origidx, regs)) {
		SI_ERROR(("si_doattach: si_buscore_setup failed\n"));
		goto exit;
	}

#if !defined(_CFEZ_) || defined(CFG_WL)
	if (CHIPID(sih->chip) == BCM4322_CHIP_ID && (((sih->chipst & CST4322_SPROM_OTP_SEL_MASK)
		>> CST4322_SPROM_OTP_SEL_SHIFT) == (CST4322_OTP_PRESENT |
		CST4322_SPROM_PRESENT))) {
		SI_ERROR(("%s: Invalid setting: both SPROM and OTP strapped.\n", __FUNCTION__));
		return NULL;
	}

	/* assume current core is CC */
	if ((sii->pub.ccrev == 0x25) && ((CHIPID(sih->chip) == BCM43236_CHIP_ID ||
	                                  CHIPID(sih->chip) == BCM43235_CHIP_ID ||
	                                  CHIPID(sih->chip) == BCM43234_CHIP_ID ||
	                                  CHIPID(sih->chip) == BCM43238_CHIP_ID) &&
	                                 (CHIPREV(sii->pub.chiprev) <= 2))) {

		if ((cc->chipstatus & CST43236_BP_CLK) != 0) {
			uint clkdiv;
			clkdiv = R_REG(osh, &cc->clkdiv);
			/* otp_clk_div is even number, 120/14 < 9mhz */
			clkdiv = (clkdiv & ~CLKD_OTP) | (14 << CLKD_OTP_SHIFT);
			W_REG(osh, &cc->clkdiv, clkdiv);
			SI_ERROR(("%s: set clkdiv to %x\n", __FUNCTION__, clkdiv));
		}
		OSL_DELAY(10);
	}

	if (bustype == PCI_BUS) {

	}
#endif 
#ifdef BCM_SDRBL
	/* 4360 rom bootloader in PCIE case, if the SDR is enabled, But preotection is
	 * not turned on, then we want to hold arm in reset.
	 * Bottomline: In sdrenable case, we allow arm to boot only when protection is
	 * turned on.
	 */
	if (CHIP_HOSTIF_PCIE(&(sii->pub))) {
		uint32 sflags = si_arm_sflags(&(sii->pub));

		/* If SDR is enabled but protection is not turned on
		* then we want to force arm to WFI.
		*/
		if ((sflags & (SISF_SDRENABLE | SISF_TCMPROT)) == SISF_SDRENABLE) {
			disable_arm_irq();
			while (1) {
				hnd_cpu_wait(sih);
			}
		}
	}
#endif /* BCM_SDRBL */

	pvars = NULL;
	BCM_REFERENCE(pvars);



		if (sii->pub.ccrev >= 20) {
			uint32 gpiopullup = 0, gpiopulldown = 0;
			cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
			ASSERT(cc != NULL);

			/* 4314/43142 has pin muxing, don't clear gpio bits */
			if ((CHIPID(sih->chip) == BCM4314_CHIP_ID) ||
				(CHIPID(sih->chip) == BCM43142_CHIP_ID)) {
				gpiopullup |= 0x402e0;
				gpiopulldown |= 0x20500;
			}

			W_REG(osh, &cc->gpiopullup, gpiopullup);
			W_REG(osh, &cc->gpiopulldown, gpiopulldown);
			si_setcoreidx(sih, origidx);
		}


	/* clear any previous epidiag-induced target abort */
	ASSERT(!si_taclear(sih, FALSE));


#ifdef BOOTLOADER_CONSOLE_OUTPUT
	/* Enable console prints */
	si_muxenab(sii, 3);
#endif

	return (sii);

exit:

	return NULL;
}

/** may be called with core in reset */
void
si_detach(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint idx;


	if (BUSTYPE(sih->bustype) == SI_BUS)
		for (idx = 0; idx < SI_MAXCORES; idx++)
			if (cores_info->regs[idx]) {
				REG_UNMAP(cores_info->regs[idx]);
				cores_info->regs[idx] = NULL;
			}


#if !defined(BCMBUSTYPE) || (BCMBUSTYPE == SI_BUS)
	if (cores_info != &ksii_cores_info)
#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SI_BUS) */
		MFREE(sii->osh, cores_info, sizeof(si_cores_info_t));

#if !defined(BCMBUSTYPE) || (BCMBUSTYPE == SI_BUS)
	if (sii != &ksii)
#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SI_BUS) */
		MFREE(sii->osh, sii, sizeof(si_info_t));
}

void *
si_osh(si_t *sih)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	return sii->osh;
}

void
si_setosh(si_t *sih, osl_t *osh)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	if (sii->osh != NULL) {
		SI_ERROR(("osh is already set....\n"));
		ASSERT(!sii->osh);
	}
	sii->osh = osh;
}

/** register driver interrupt disabling and restoring callback functions */
void
si_register_intr_callback(si_t *sih, void *intrsoff_fn, void *intrsrestore_fn,
                          void *intrsenabled_fn, void *intr_arg)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	sii->intr_arg = intr_arg;
	sii->intrsoff_fn = (si_intrsoff_t)intrsoff_fn;
	sii->intrsrestore_fn = (si_intrsrestore_t)intrsrestore_fn;
	sii->intrsenabled_fn = (si_intrsenabled_t)intrsenabled_fn;
	/* save current core id.  when this function called, the current core
	 * must be the core which provides driver functions(il, et, wl, etc.)
	 */
	sii->dev_coreid = cores_info->coreid[sii->curidx];
}

void
si_deregister_intr_callback(si_t *sih)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	sii->intrsoff_fn = NULL;
	sii->intrsrestore_fn = NULL;
	sii->intrsenabled_fn = NULL;
}

uint
si_intflag(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);

	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_intflag(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return R_REG(sii->osh, ((uint32 *)(uintptr)
			    (sii->oob_router + OOB_STATUSA)));
	else {
		ASSERT(0);
		return 0;
	}
}

uint
si_flag(si_t *sih)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_flag(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_flag(sih);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_flag(sih);
	else {
		ASSERT(0);
		return 0;
	}
}

uint
si_flag_alt(si_t *sih)
{
	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_flag_alt(sih);
	else {
		ASSERT(0);
		return 0;
	}
}

void
si_setint(si_t *sih, int siflag)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		sb_setint(sih, siflag);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		ai_setint(sih, siflag);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		ub_setint(sih, siflag);
	else
		ASSERT(0);
}

uint
si_coreid(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;

	return cores_info->coreid[sii->curidx];
}

uint
si_coreidx(si_t *sih)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	return sii->curidx;
}

void *
si_d11_switch_addrbase(si_t *sih, uint coreunit)
{
	return si_setcore(sih,  D11_CORE_ID, coreunit);
}

/** return the core-type instantiation # of the current core */
uint
si_coreunit(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint idx;
	uint coreid;
	uint coreunit;
	uint i;

	coreunit = 0;

	idx = sii->curidx;

	ASSERT(GOODREGS(sii->curmap));
	coreid = si_coreid(sih);

	/* count the cores of our type */
	for (i = 0; i < idx; i++)
		if (cores_info->coreid[i] == coreid)
			coreunit++;

	return (coreunit);
}

uint
si_corevendor(si_t *sih)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_corevendor(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_corevendor(sih);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_corevendor(sih);
	else {
		ASSERT(0);
		return 0;
	}
}

bool
si_backplane64(si_t *sih)
{
	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
}

uint
si_corerev(si_t *sih)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_corerev(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_corerev(sih);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_corerev(sih);
	else {
		ASSERT(0);
		return 0;
	}
}


/* return index of coreid or BADIDX if not found */
uint
si_findcoreidx(si_t *sih, uint coreid, uint coreunit)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint found;
	uint i;


	found = 0;

	for (i = 0; i < sii->numcores; i++)
		if (cores_info->coreid[i] == coreid) {
			if (found == coreunit)
				return (i);
			found++;
		}

	return (BADIDX);
}

/** return total coreunit of coreid or zero if not found */
uint
si_numcoreunits(si_t *sih, uint coreid)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint found = 0;
	uint i;

	for (i = 0; i < sii->numcores; i++) {
		if (cores_info->coreid[i] == coreid) {
			found++;
		}
	}

	return found;
}

/** return total D11 coreunits */
uint
BCMRAMFN(si_numd11coreunits)(si_t *sih)
{
	uint found = 0;

	found = si_numcoreunits(sih, D11_CORE_ID);

#if defined(WLRSDB) && defined(WLRSDB_DISABLED)
	/* If RSDB functionality is compiled out,
	 * then ignore any D11 cores beyond the first
	 * Used in norsdb dongle build variants for rsdb chip.
	 */
	found = 1;
#endif /* defined(WLRSDB) && !defined(WLRSDB_DISABLED) */

	return found;
}

/** return list of found cores */
uint
si_corelist(si_t *sih, uint coreid[])
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;

	bcopy((uchar*)cores_info->coreid, (uchar*)coreid, (sii->numcores * sizeof(uint)));
	return (sii->numcores);
}

/** return current wrapper mapping */
void *
si_wrapperregs(si_t *sih)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	ASSERT(GOODREGS(sii->curwrap));

	return (sii->curwrap);
}

/** return current register mapping */
void *
si_coreregs(si_t *sih)
{
	si_info_t *sii;

	sii = SI_INFO(sih);
	ASSERT(GOODREGS(sii->curmap));

	return (sii->curmap);
}

/**
 * This function changes logical "focus" to the indicated core;
 * must be called with interrupts off.
 * Moreover, callers should keep interrupts off during switching out of and back to d11 core
 */
void *
si_setcore(si_t *sih, uint coreid, uint coreunit)
{
	uint idx;

	idx = si_findcoreidx(sih, coreid, coreunit);
	if (!GOODIDX(idx))
		return (NULL);

	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_setcoreidx(sih, idx);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_setcoreidx(sih, idx);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_setcoreidx(sih, idx);
	else {
		ASSERT(0);
		return NULL;
	}
}

void *
si_setcoreidx(si_t *sih, uint coreidx)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_setcoreidx(sih, coreidx);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_setcoreidx(sih, coreidx);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_setcoreidx(sih, coreidx);
	else {
		ASSERT(0);
		return NULL;
	}
}

/** Turn off interrupt as required by sb_setcore, before switch core */
void *
si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
{
	void *cc;
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;

	if (SI_FAST(sii)) {
		/* Overloading the origidx variable to remember the coreid,
		 * this works because the core ids cannot be confused with
		 * core indices.
		 */
		*origidx = coreid;
		if (coreid == CC_CORE_ID)
			return (void *)CCREGS_FAST(sii);
		else if (coreid == sih->buscoretype)
			return (void *)PCIEREGS(sii);
	}
	INTR_OFF(sii, *intr_val);
	*origidx = sii->curidx;
	cc = si_setcore(sih, coreid, 0);
	ASSERT(cc != NULL);

	return cc;
}

/* restore coreidx and restore interrupt */
void
si_restore_core(si_t *sih, uint coreid, uint intr_val)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;

	if (SI_FAST(sii) && ((coreid == CC_CORE_ID) || (coreid == sih->buscoretype)))
		return;

	si_setcoreidx(sih, coreid);
	INTR_RESTORE(sii, intr_val);
}

int
si_numaddrspaces(si_t *sih)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_numaddrspaces(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_numaddrspaces(sih);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_numaddrspaces(sih);
	else {
		ASSERT(0);
		return 0;
	}
}

uint32
si_addrspace(si_t *sih, uint asidx)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_addrspace(sih, asidx);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_addrspace(sih, asidx);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_addrspace(sih, asidx);
	else {
		ASSERT(0);
		return 0;
	}
}

uint32
si_addrspacesize(si_t *sih, uint asidx)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_addrspacesize(sih, asidx);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_addrspacesize(sih, asidx);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_addrspacesize(sih, asidx);
	else {
		ASSERT(0);
		return 0;
	}
}

void
si_coreaddrspaceX(si_t *sih, uint asidx, uint32 *addr, uint32 *size)
{
	/* Only supported for SOCI_AI */
	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		ai_coreaddrspaceX(sih, asidx, addr, size);
	else
		*size = 0;
}

uint32
si_core_cflags(si_t *sih, uint32 mask, uint32 val)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_core_cflags(sih, mask, val);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_core_cflags(sih, mask, val);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_core_cflags(sih, mask, val);
	else {
		ASSERT(0);
		return 0;
	}
}

void
si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		sb_core_cflags_wo(sih, mask, val);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		ai_core_cflags_wo(sih, mask, val);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		ub_core_cflags_wo(sih, mask, val);
	else
		ASSERT(0);
}

uint32
si_core_sflags(si_t *sih, uint32 mask, uint32 val)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_core_sflags(sih, mask, val);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_core_sflags(sih, mask, val);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_core_sflags(sih, mask, val);
	else {
		ASSERT(0);
		return 0;
	}
}

bool
si_iscoreup(si_t *sih)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_iscoreup(sih);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_iscoreup(sih);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_iscoreup(sih);
	else {
		ASSERT(0);
		return FALSE;
	}
}

uint
si_wrapperreg(si_t *sih, uint32 offset, uint32 mask, uint32 val)
{
	/* only for AI back plane chips */
	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return (ai_wrap_reg(sih, offset, mask, val));
	return 0;
}

uint
si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_corereg(sih, coreidx, regoff, mask, val);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_corereg(sih, coreidx, regoff, mask, val);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		return ub_corereg(sih, coreidx, regoff, mask, val);
	else {
		ASSERT(0);
		return 0;
	}
}

/** ILP sensitive register access needs special treatment to avoid backplane stalls */
bool si_pmu_is_ilp_sensitive(uint32 idx, uint regoff)
{
	if (idx == SI_CC_IDX) {
		if (CHIPCREGS_ILP_SENSITIVE(regoff))
			return TRUE;
	} else if (PMUREGS_ILP_SENSITIVE(regoff)) {
		return TRUE;
	}

	return FALSE;
}

/** 'idx' should refer either to the chipcommon core or the PMU core */
uint
si_pmu_corereg(si_t *sih, uint32 idx, uint regoff, uint mask, uint val)
{
	int pmustatus_offset;

	/* prevent backplane stall on double write to 'ILP domain' registers in the PMU */
	if (mask != 0 && sih->pmurev >= 22 &&
	    si_pmu_is_ilp_sensitive(idx, regoff)) {
		pmustatus_offset = AOB_ENAB(sih) ? OFFSETOF(pmuregs_t, pmustatus) :
			OFFSETOF(chipcregs_t, pmustatus);

		while (si_corereg(sih, idx, pmustatus_offset, 0, 0) & PST_SLOW_WR_PENDING)
			{};
	}

	return si_corereg(sih, idx, regoff, mask, val);
}

/*
 * If there is no need for fiddling with interrupts or core switches (typically silicon
 * back plane registers, pci registers and chipcommon registers), this function
 * returns the register offset on this core to a mapped address. This address can
 * be used for W_REG/R_REG directly.
 *
 * For accessing registers that would need a core switch, this function will return
 * NULL.
 */
uint32 *
si_corereg_addr(si_t *sih, uint coreidx, uint regoff)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		return sb_corereg_addr(sih, coreidx, regoff);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		return ai_corereg_addr(sih, coreidx, regoff);
	else {
		return 0;
	}
}

void
si_core_disable(si_t *sih, uint32 bits)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		sb_core_disable(sih, bits);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		ai_core_disable(sih, bits);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		ub_core_disable(sih, bits);
}

void
si_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
{
	if (CHIPTYPE(sih->socitype) == SOCI_SB)
		sb_core_reset(sih, bits, resetbits);
	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
		ai_core_reset(sih, bits, resetbits);
	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
		ub_core_reset(sih, bits, resetbits);
}

/** Run bist on current core. Caller needs to take care of core-specific bist hazards */
int
si_corebist(si_t *sih)
{
	uint32 cflags;
	int result = 0;

	/* Read core control flags */
	cflags = si_core_cflags(sih, 0, 0);

	/* Set bist & fgc */
	si_core_cflags(sih, ~0, (SICF_BIST_EN | SICF_FGC));

	/* Wait for bist done */
	SPINWAIT(((si_core_sflags(sih, 0, 0) & SISF_BIST_DONE) == 0), 100000);

	if (si_core_sflags(sih, 0, 0) & SISF_BIST_ERROR)
		result = BCME_ERROR;

	/* Reset core control flags */
	si_core_cflags(sih, 0xffff, cflags);

	return result;
}

static uint32
factor6(uint32 x)
{
	switch (x) {
	case CC_F6_2:	return 2;
	case CC_F6_3:	return 3;
	case CC_F6_4:	return 4;
	case CC_F6_5:	return 5;
	case CC_F6_6:	return 6;
	case CC_F6_7:	return 7;
	default:	return 0;
	}
}

/** calculate the speed the SI would run at given a set of clockcontrol values */
uint32
si_clock_rate(uint32 pll_type, uint32 n, uint32 m)
{
	uint32 n1, n2, clock, m1, m2, m3, mc;

	n1 = n & CN_N1_MASK;
	n2 = (n & CN_N2_MASK) >> CN_N2_SHIFT;

	if (pll_type == PLL_TYPE6) {
		if (m & CC_T6_MMASK)
			return CC_T6_M1;
		else
			return CC_T6_M0;
	} else if ((pll_type == PLL_TYPE1) ||
	           (pll_type == PLL_TYPE3) ||
	           (pll_type == PLL_TYPE4) ||
	           (pll_type == PLL_TYPE7)) {
		n1 = factor6(n1);
		n2 += CC_F5_BIAS;
	} else if (pll_type == PLL_TYPE2) {
		n1 += CC_T2_BIAS;
		n2 += CC_T2_BIAS;
		ASSERT((n1 >= 2) && (n1 <= 7));
		ASSERT((n2 >= 5) && (n2 <= 23));
	} else if (pll_type == PLL_TYPE5) {
		return (100000000);
	} else
		ASSERT(0);
	/* PLL types 3 and 7 use BASE2 (25Mhz) */
	if ((pll_type == PLL_TYPE3) ||
	    (pll_type == PLL_TYPE7)) {
		clock = CC_CLOCK_BASE2 * n1 * n2;
	} else
		clock = CC_CLOCK_BASE1 * n1 * n2;

	if (clock == 0)
		return 0;

	m1 = m & CC_M1_MASK;
	m2 = (m & CC_M2_MASK) >> CC_M2_SHIFT;
	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;

	if ((pll_type == PLL_TYPE1) ||
	    (pll_type == PLL_TYPE3) ||
	    (pll_type == PLL_TYPE4) ||
	    (pll_type == PLL_TYPE7)) {
		m1 = factor6(m1);
		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
			m2 += CC_F5_BIAS;
		else
			m2 = factor6(m2);
		m3 = factor6(m3);

		switch (mc) {
		case CC_MC_BYPASS:	return (clock);
		case CC_MC_M1:		return (clock / m1);
		case CC_MC_M1M2:	return (clock / (m1 * m2));
		case CC_MC_M1M2M3:	return (clock / (m1 * m2 * m3));
		case CC_MC_M1M3:	return (clock / (m1 * m3));
		default:		return (0);
		}
	} else {
		ASSERT(pll_type == PLL_TYPE2);

		m1 += CC_T2_BIAS;
		m2 += CC_T2M2_BIAS;
		m3 += CC_T2_BIAS;
		ASSERT((m1 >= 2) && (m1 <= 7));
		ASSERT((m2 >= 3) && (m2 <= 10));
		ASSERT((m3 >= 2) && (m3 <= 7));

		if ((mc & CC_T2MC_M1BYP) == 0)
			clock /= m1;
		if ((mc & CC_T2MC_M2BYP) == 0)
			clock /= m2;
		if ((mc & CC_T2MC_M3BYP) == 0)
			clock /= m3;

		return (clock);
	}
}

/**
 * Some chips could have multiple host interfaces, however only one will be active.
 * For a given chip. Depending pkgopt and cc_chipst return the active host interface.
 */
uint
si_chip_hostif(si_t *sih)
{
	uint hosti = 0;

	switch (CHIPID(sih->chip)) {

	case BCM43602_CHIP_ID:
		hosti = CHIP_HOSTIF_PCIEMODE;
		break;

	case BCM4360_CHIP_ID:
		/* chippkg bit-0 == 0 is PCIE only pkgs
		 * chippkg bit-0 == 1 has both PCIE and USB cores enabled
		 */
		if ((sih->chippkg & 0x1) && (sih->chipst & CST4360_MODE_USB))
			hosti = CHIP_HOSTIF_USBMODE;
		else
			hosti = CHIP_HOSTIF_PCIEMODE;

		break;

	case BCM4335_CHIP_ID:
		/* TBD: like in 4360, do we need to check pkg? */
		if (CST4335_CHIPMODE_USB20D(sih->chipst))
			hosti = CHIP_HOSTIF_USBMODE;
		else if (CST4335_CHIPMODE_SDIOD(sih->chipst))
			hosti = CHIP_HOSTIF_SDIOMODE;
		else
			hosti = CHIP_HOSTIF_PCIEMODE;
		break;

	case BCM4345_CHIP_ID:
		if (CST4345_CHIPMODE_USB20D(sih->chipst) || CST4345_CHIPMODE_HSIC(sih->chipst))
			hosti = CHIP_HOSTIF_USBMODE;
		else if (CST4345_CHIPMODE_SDIOD(sih->chipst))
			hosti = CHIP_HOSTIF_SDIOMODE;
		else if (CST4345_CHIPMODE_PCIE(sih->chipst))
			hosti = CHIP_HOSTIF_PCIEMODE;
		break;

	case BCM4349_CHIP_GRPID:
		if (CST4349_CHIPMODE_SDIOD(sih->chipst))
			hosti = CHIP_HOSTIF_SDIOMODE;
		else if (CST4349_CHIPMODE_PCIE(sih->chipst))
			hosti = CHIP_HOSTIF_PCIEMODE;
		break;

	case BCM4350_CHIP_ID:
	case BCM4354_CHIP_ID:
	case BCM4356_CHIP_ID:
	case BCM43556_CHIP_ID:
	case BCM43558_CHIP_ID:
	case BCM43566_CHIP_ID:
	case BCM43568_CHIP_ID:
	case BCM43569_CHIP_ID:
	case BCM43570_CHIP_ID:
	case BCM4358_CHIP_ID:
		if (CST4350_CHIPMODE_USB20D(sih->chipst) ||
		    CST4350_CHIPMODE_HSIC20D(sih->chipst) ||
		    CST4350_CHIPMODE_USB30D(sih->chipst) ||
		    CST4350_CHIPMODE_USB30D_WL(sih->chipst) ||
		    CST4350_CHIPMODE_HSIC30D(sih->chipst))
			hosti = CHIP_HOSTIF_USBMODE;
		else if (CST4350_CHIPMODE_SDIOD(sih->chipst))
			hosti = CHIP_HOSTIF_SDIOMODE;
		else if (CST4350_CHIPMODE_PCIE(sih->chipst))
			hosti = CHIP_HOSTIF_PCIEMODE;
		break;

	default:
		break;
	}

	return hosti;
}


/** set chip watchdog reset timer to fire in 'ticks' */
void
si_watchdog(si_t *sih, uint ticks)
{
	uint nb, maxt;

	if (PMUCTL_ENAB(sih)) {

#if !defined(_CFEZ_) || defined(CFG_WL)
		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
			si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, clk_ctl_st), ~0, 0x2);
			si_setcore(sih, USB20D_CORE_ID, 0);
			si_core_disable(sih, 1);
			si_setcore(sih, CC_CORE_ID, 0);
		}
#endif 

			nb = (sih->ccrev < 26) ? 16 : ((sih->ccrev >= 37) ? 32 : 24);
		/* The mips compiler uses the sllv instruction,
		 * so we specially handle the 32-bit case.
		 */
		if (nb == 32)
			maxt = 0xffffffff;
		else
			maxt = ((1 << nb) - 1);

		if (ticks == 1)
			ticks = 2;
		else if (ticks > maxt)
			ticks = maxt;

		pmu_corereg(sih, SI_CC_IDX, pmuwatchdog, ~0, ticks);
	} else {
		maxt = (1 << 28) - 1;
		if (ticks > maxt)
			ticks = maxt;

		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
	}
}

/** trigger watchdog reset after ms milliseconds */
void
si_watchdog_ms(si_t *sih, uint32 ms)
{
	si_watchdog(sih, wd_msticks * ms);
}

uint32 si_watchdog_msticks(void)
{
	return wd_msticks;
}

bool
si_taclear(si_t *sih, bool details)
{
	return FALSE;
}



/** return the slow clock source - LPO, XTAL, or PCI */
static uint
si_slowclk_src(si_info_t *sii)
{
	chipcregs_t *cc;

	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);

	if (sii->pub.ccrev < 6) {
		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32)) &
		     PCI_CFG_GPIO_SCS))
			return (SCC_SS_PCI);
		else
			return (SCC_SS_XTAL);
	} else if (sii->pub.ccrev < 10) {
		cc = (chipcregs_t *)si_setcoreidx(&sii->pub, sii->curidx);
		ASSERT(cc);
		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
	} else	/* Insta-clock */
		return (SCC_SS_XTAL);
}

/** return the ILP (slowclock) min or max frequency */
static uint
si_slowclk_freq(si_info_t *sii, bool max_freq, chipcregs_t *cc)
{
	uint32 slowclk;
	uint div;

	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);

	/* shouldn't be here unless we've established the chip has dynamic clk control */
	ASSERT(R_REG(sii->osh, &cc->capabilities) & CC_CAP_PWR_CTL);

	slowclk = si_slowclk_src(sii);
	if (sii->pub.ccrev < 6) {
		if (slowclk == SCC_SS_PCI)
			return (max_freq ? (PCIMAXFREQ / 64) : (PCIMINFREQ / 64));
		else
			return (max_freq ? (XTALMAXFREQ / 32) : (XTALMINFREQ / 32));
	} else if (sii->pub.ccrev < 10) {
		div = 4 *
		        (((R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
		if (slowclk == SCC_SS_LPO)
			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
		else if (slowclk == SCC_SS_XTAL)
			return (max_freq ? (XTALMAXFREQ / div) : (XTALMINFREQ / div));
		else if (slowclk == SCC_SS_PCI)
			return (max_freq ? (PCIMAXFREQ / div) : (PCIMINFREQ / div));
		else
			ASSERT(0);
	} else {
		/* Chipc rev 10 is InstaClock */
		div = R_REG(sii->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
		div = 4 * (div + 1);
		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
	}
	return (0);
}

static void
si_clkctl_setdelay(si_info_t *sii, void *chipcregs)
{
	chipcregs_t *cc = (chipcregs_t *)chipcregs;
	uint slowmaxfreq, pll_delay, slowclk;
	uint pll_on_delay, fref_sel_delay;

	pll_delay = PLL_DELAY;

	/* If the slow clock is not sourced by the xtal then add the xtal_on_delay
	 * since the xtal will also be powered down by dynamic clk control logic.
	 */

	slowclk = si_slowclk_src(sii);
	if (slowclk != SCC_SS_XTAL)
		pll_delay += XTAL_ON_DELAY;

	/* Starting with 4318 it is ILP that is used for the delays */
	slowmaxfreq = si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : TRUE, cc);

	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;

	W_REG(sii->osh, &cc->pll_on_delay, pll_on_delay);
	W_REG(sii->osh, &cc->fref_sel_delay, fref_sel_delay);
}

/** initialize power control delay registers */
void
si_clkctl_init(si_t *sih)
{
	si_info_t *sii;
	uint origidx = 0;
	chipcregs_t *cc;
	bool fast;

	if (!CCCTL_ENAB(sih))
		return;

	sii = SI_INFO(sih);
	fast = SI_FAST(sii);
	if (!fast) {
		origidx = sii->curidx;
		if ((cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0)) == NULL)
			return;
	} else if ((cc = (chipcregs_t *)CCREGS_FAST(sii)) == NULL)
		return;
	ASSERT(cc != NULL);

	/* set all Instaclk chip ILP to 1 MHz */
	if (sih->ccrev >= 10)
		SET_REG(sii->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
		        (ILP_DIV_1MHZ << SYCC_CD_SHIFT));

	si_clkctl_setdelay(sii, (void *)(uintptr)cc);

	OSL_DELAY(20000);

	if (!fast)
		si_setcoreidx(sih, origidx);
}


/** change logical "focus" to the gpio core for optimized access */
void *
si_gpiosetcore(si_t *sih)
{
	return (si_setcoreidx(sih, SI_CC_IDX));
}

/**
 * mask & set gpiocontrol bits.
 * If a gpiocontrol bit is set to 0, chipcommon controls the corresponding GPIO pin.
 * If a gpiocontrol bit is set to 1, the GPIO pin is no longer a GPIO and becomes dedicated
 *   to some chip-specific purpose.
 */
uint32
si_gpiocontrol(si_t *sih, uint32 mask, uint32 val, uint8 priority)
{
	uint regoff;

	regoff = 0;

	/* gpios could be shared on router platforms
	 * ignore reservation if it's high priority (e.g., test apps)
	 */
	if ((priority != GPIO_HI_PRIORITY) &&
	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
		mask = priority ? (si_gpioreservation & mask) :
			((si_gpioreservation | mask) & ~(si_gpioreservation));
		val &= mask;
	}

	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
}

/** mask&set gpio output enable bits */
uint32
si_gpioouten(si_t *sih, uint32 mask, uint32 val, uint8 priority)
{
	uint regoff;

	regoff = 0;

	/* gpios could be shared on router platforms
	 * ignore reservation if it's high priority (e.g., test apps)
	 */
	if ((priority != GPIO_HI_PRIORITY) &&
	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
		mask = priority ? (si_gpioreservation & mask) :
			((si_gpioreservation | mask) & ~(si_gpioreservation));
		val &= mask;
	}

	regoff = OFFSETOF(chipcregs_t, gpioouten);
	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
}

/** mask&set gpio output bits */
uint32
si_gpioout(si_t *sih, uint32 mask, uint32 val, uint8 priority)
{
	uint regoff;

	regoff = 0;

	/* gpios could be shared on router platforms
	 * ignore reservation if it's high priority (e.g., test apps)
	 */
	if ((priority != GPIO_HI_PRIORITY) &&
	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
		mask = priority ? (si_gpioreservation & mask) :
			((si_gpioreservation | mask) & ~(si_gpioreservation));
		val &= mask;
	}

	regoff = OFFSETOF(chipcregs_t, gpioout);
	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
}

/** reserve one gpio */
uint32
si_gpioreserve(si_t *sih, uint32 gpio_bitmask, uint8 priority)
{
	/* only cores on SI_BUS share GPIO's and only applcation users need to
	 * reserve/release GPIO
	 */
	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
		return 0xffffffff;
	}
	/* make sure only one bit is set */
	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
		return 0xffffffff;
	}

	/* already reserved */
	if (si_gpioreservation & gpio_bitmask)
		return 0xffffffff;
	/* set reservation */
	si_gpioreservation |= gpio_bitmask;

	return si_gpioreservation;
}

/**
 * release one gpio.
 *
 * releasing the gpio doesn't change the current value on the GPIO last write value
 * persists till someone overwrites it.
 */
uint32
si_gpiorelease(si_t *sih, uint32 gpio_bitmask, uint8 priority)
{
	/* only cores on SI_BUS share GPIO's and only applcation users need to
	 * reserve/release GPIO
	 */
	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
		return 0xffffffff;
	}
	/* make sure only one bit is set */
	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
		return 0xffffffff;
	}

	/* already released */
	if (!(si_gpioreservation & gpio_bitmask))
		return 0xffffffff;

	/* clear reservation */
	si_gpioreservation &= ~gpio_bitmask;

	return si_gpioreservation;
}

/* return the current gpioin register value */
uint32
si_gpioin(si_t *sih)
{
	uint regoff;

	regoff = OFFSETOF(chipcregs_t, gpioin);
	return (si_corereg(sih, SI_CC_IDX, regoff, 0, 0));
}

/* mask&set gpio interrupt polarity bits */
uint32
si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val, uint8 priority)
{
	uint regoff;

	/* gpios could be shared on router platforms */
	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
		mask = priority ? (si_gpioreservation & mask) :
			((si_gpioreservation | mask) & ~(si_gpioreservation));
		val &= mask;
	}

	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
}

/* mask&set gpio interrupt mask bits */
uint32
si_gpiointmask(si_t *sih, uint32 mask, uint32 val, uint8 priority)
{
	uint regoff;

	/* gpios could be shared on router platforms */
	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
		mask = priority ? (si_gpioreservation & mask) :
			((si_gpioreservation | mask) & ~(si_gpioreservation));
		val &= mask;
	}

	regoff = OFFSETOF(chipcregs_t, gpiointmask);
	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
}

/* assign the gpio to an led */
uint32
si_gpioled(si_t *sih, uint32 mask, uint32 val)
{
	if (sih->ccrev < 16)
		return 0xffffffff;

	/* gpio led powersave reg */
	return (si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask, val));
}

/* mask&set gpio timer val */
uint32
si_gpiotimerval(si_t *sih, uint32 mask, uint32 gpiotimerval)
{
	if (sih->ccrev < 16)
		return 0xffffffff;

	return (si_corereg(sih, SI_CC_IDX,
		OFFSETOF(chipcregs_t, gpiotimerval), mask, gpiotimerval));
}

uint32
si_gpiopull(si_t *sih, bool updown, uint32 mask, uint32 val)
{
	uint offs;

	if (sih->ccrev < 20)
		return 0xffffffff;

	offs = (updown ? OFFSETOF(chipcregs_t, gpiopulldown) : OFFSETOF(chipcregs_t, gpiopullup));
	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
}

uint32
si_gpioevent(si_t *sih, uint regtype, uint32 mask, uint32 val)
{
	uint offs;

	if (sih->ccrev < 11)
		return 0xffffffff;

	if (regtype == GPIO_REGEVT)
		offs = OFFSETOF(chipcregs_t, gpioevent);
	else if (regtype == GPIO_REGEVT_INTMSK)
		offs = OFFSETOF(chipcregs_t, gpioeventintmask);
	else if (regtype == GPIO_REGEVT_INTPOL)
		offs = OFFSETOF(chipcregs_t, gpioeventintpolarity);
	else
		return 0xffffffff;

	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
}

void *
si_gpio_handler_register(si_t *sih, uint32 event,
	bool level, gpio_handler_t cb, void *arg)
{
	si_info_t *sii = SI_INFO(sih);
	gpioh_item_t *gi;

	ASSERT(event);
	ASSERT(cb != NULL);

	if (sih->ccrev < 11)
		return NULL;

	if ((gi = MALLOC(sii->osh, sizeof(gpioh_item_t))) == NULL)
		return NULL;

	bzero(gi, sizeof(gpioh_item_t));
	gi->event = event;
	gi->handler = cb;
	gi->arg = arg;
	gi->level = level;

	gi->next = sii->gpioh_head;
	sii->gpioh_head = gi;

	return (void *)(gi);
}

void
si_gpio_handler_unregister(si_t *sih, void *gpioh)
{
	si_info_t *sii = SI_INFO(sih);
	gpioh_item_t *p, *n;

	if (sih->ccrev < 11)
		return;

	ASSERT(sii->gpioh_head != NULL);
	if ((void*)sii->gpioh_head == gpioh) {
		sii->gpioh_head = sii->gpioh_head->next;
		MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
		return;
	} else {
		p = sii->gpioh_head;
		n = p->next;
		while (n) {
			if ((void*)n == gpioh) {
				p->next = n->next;
				MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
				return;
			}
			p = n;
			n = n->next;
		}
	}

	ASSERT(0); /* Not found in list */
}

void
si_gpio_handler_process(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	gpioh_item_t *h;
	uint32 level = si_gpioin(sih);
	uint32 levelp = si_gpiointpolarity(sih, 0, 0, 0);
	uint32 edge = si_gpioevent(sih, GPIO_REGEVT, 0, 0);
	uint32 edgep = si_gpioevent(sih, GPIO_REGEVT_INTPOL, 0, 0);

	for (h = sii->gpioh_head; h != NULL; h = h->next) {
		if (h->handler) {
			uint32 status = (h->level ? level : edge) & h->event;
			uint32 polarity = (h->level ? levelp : edgep) & h->event;

			/* polarity bitval is opposite of status bitval */
			if ((h->level && (status ^ polarity)) || (!h->level && status))
				h->handler(status, h->arg);
		}
	}

	si_gpioevent(sih, GPIO_REGEVT, edge, edge); /* clear edge-trigger status */
}

uint32
si_gpio_int_enable(si_t *sih, bool enable)
{
	uint offs;

	if (sih->ccrev < 11)
		return 0xffffffff;

	offs = OFFSETOF(chipcregs_t, intmask);
	return (si_corereg(sih, SI_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
}


/** Return the size of the specified SOCRAM bank */
static uint
socram_banksize(si_info_t *sii, sbsocramregs_t *regs, uint8 idx, uint8 mem_type)
{
	uint banksize, bankinfo;
	uint bankidx = idx | (mem_type << SOCRAM_BANKIDX_MEMTYPE_SHIFT);

	ASSERT(mem_type <= SOCRAM_MEMTYPE_DEVRAM);

	W_REG(sii->osh, &regs->bankidx, bankidx);
	bankinfo = R_REG(sii->osh, &regs->bankinfo);
	banksize = SOCRAM_BANKINFO_SZBASE * ((bankinfo & SOCRAM_BANKINFO_SZMASK) + 1);
	return banksize;
}

void si_socram_set_bankpda(si_t *sih, uint32 bankidx, uint32 bankpda)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);

	corerev = si_corerev(sih);
	if (corerev >= 16) {
		W_REG(sii->osh, &regs->bankidx, bankidx);
		W_REG(sii->osh, &regs->bankpda, bankpda);
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);
}

void
si_socdevram(si_t *sih, bool set, uint8 *enable, uint8 *protect, uint8 *remap)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	if (!set)
		*enable = *protect = *remap = 0;

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);

	corerev = si_corerev(sih);
	if (corerev >= 10) {
		uint32 extcinfo;
		uint8 nb;
		uint8 i;
		uint32 bankidx, bankinfo;

		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
		nb = ((extcinfo & SOCRAM_DEVRAMBANK_MASK) >> SOCRAM_DEVRAMBANK_SHIFT);
		for (i = 0; i < nb; i++) {
			bankidx = i | (SOCRAM_MEMTYPE_DEVRAM << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
			W_REG(sii->osh, &regs->bankidx, bankidx);
			bankinfo = R_REG(sii->osh, &regs->bankinfo);
			if (set) {
				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMSEL_MASK;
				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMPRO_MASK;
				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMREMAP_MASK;
				if (*enable) {
					bankinfo |= (1 << SOCRAM_BANKINFO_DEVRAMSEL_SHIFT);
					if (*protect)
						bankinfo |= (1 << SOCRAM_BANKINFO_DEVRAMPRO_SHIFT);
					if ((corerev >= 16) && *remap)
						bankinfo |=
							(1 << SOCRAM_BANKINFO_DEVRAMREMAP_SHIFT);
				}
				W_REG(sii->osh, &regs->bankinfo, bankinfo);
			}
			else if (i == 0) {
				if (bankinfo & SOCRAM_BANKINFO_DEVRAMSEL_MASK) {
					*enable = 1;
					if (bankinfo & SOCRAM_BANKINFO_DEVRAMPRO_MASK)
						*protect = 1;
					if (bankinfo & SOCRAM_BANKINFO_DEVRAMREMAP_MASK)
						*remap = 1;
				}
			}
		}
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);
}

bool
si_socdevram_remap_isenb(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	sbsocramregs_t *regs;
	bool wasup, remap = FALSE;
	uint corerev;
	uint32 extcinfo;
	uint8 nb;
	uint8 i;
	uint32 bankidx, bankinfo;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);

	corerev = si_corerev(sih);
	if (corerev >= 16) {
		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
		nb = ((extcinfo & SOCRAM_DEVRAMBANK_MASK) >> SOCRAM_DEVRAMBANK_SHIFT);
		for (i = 0; i < nb; i++) {
			bankidx = i | (SOCRAM_MEMTYPE_DEVRAM << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
			W_REG(sii->osh, &regs->bankidx, bankidx);
			bankinfo = R_REG(sii->osh, &regs->bankinfo);
			if (bankinfo & SOCRAM_BANKINFO_DEVRAMREMAP_MASK) {
				remap = TRUE;
				break;
			}
		}
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);
	return remap;
}

bool
si_socdevram_pkg(si_t *sih)
{
	if (si_socdevram_size(sih) > 0)
		return TRUE;
	else
		return FALSE;
}

uint32
si_socdevram_size(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	uint32 memsize = 0;
	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);

	corerev = si_corerev(sih);
	if (corerev >= 10) {
		uint32 extcinfo;
		uint8 nb;
		uint8 i;

		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
		nb = (((extcinfo & SOCRAM_DEVRAMBANK_MASK) >> SOCRAM_DEVRAMBANK_SHIFT));
		for (i = 0; i < nb; i++)
			memsize += socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_DEVRAM);
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);

	return memsize;
}

uint32
si_socdevram_remap_size(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	uint32 memsize = 0, banksz;
	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;
	uint32 extcinfo;
	uint8 nb;
	uint8 i;
	uint32 bankidx, bankinfo;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);

	corerev = si_corerev(sih);
	if (corerev >= 16) {
		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
		nb = (((extcinfo & SOCRAM_DEVRAMBANK_MASK) >> SOCRAM_DEVRAMBANK_SHIFT));

		/*
		 * FIX: A0 Issue: Max addressable is 512KB, instead 640KB
		 * Only four banks are accessible to ARM
		 */
		if ((corerev == 16) && (nb == 5))
			nb = 4;

		for (i = 0; i < nb; i++) {
			bankidx = i | (SOCRAM_MEMTYPE_DEVRAM << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
			W_REG(sii->osh, &regs->bankidx, bankidx);
			bankinfo = R_REG(sii->osh, &regs->bankinfo);
			if (bankinfo & SOCRAM_BANKINFO_DEVRAMREMAP_MASK) {
				banksz = socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_DEVRAM);
				memsize += banksz;
			} else {
				/* Account only consecutive banks for now */
				break;
			}
		}
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);

	return memsize;
}

/** Return the RAM size of the SOCRAM core */
uint32
si_socram_size(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;

	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;
	uint32 coreinfo;
	uint memsize = 0;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);
	corerev = si_corerev(sih);
	coreinfo = R_REG(sii->osh, &regs->coreinfo);

	/* Calculate size from coreinfo based on rev */
	if (corerev == 0)
		memsize = 1 << (16 + (coreinfo & SRCI_MS0_MASK));
	else if (corerev < 3) {
		memsize = 1 << (SR_BSZ_BASE + (coreinfo & SRCI_SRBSZ_MASK));
		memsize *= (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
	} else if ((corerev <= 7) || (corerev == 12)) {
		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
		uint bsz = (coreinfo & SRCI_SRBSZ_MASK);
		uint lss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;
		if (lss != 0)
			nb --;
		memsize = nb * (1 << (bsz + SR_BSZ_BASE));
		if (lss != 0)
			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
	} else {
		uint8 i;
		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
		for (i = 0; i < nb; i++)
			memsize += socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_RAM);
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);

	return memsize;
}


/** Return the TCM-RAM size of the ARMCR4 core. */
uint32
si_tcm_size(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	uint8 *regs;
	bool wasup;
	uint32 corecap;
	uint memsize = 0;
	uint32 nab = 0;
	uint32 nbb = 0;
	uint32 totb = 0;
	uint32 bxinfo = 0;
	uint32 idx = 0;
	uint32 *arm_cap_reg;
	uint32 *arm_bidx;
	uint32 *arm_binfo;

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to CR4 core */
	if (!(regs = si_setcore(sih, ARMCR4_CORE_ID, 0)))
		goto done;

	/* Get info for determining size. If in reset, come out of reset,
	 * but remain in halt
	 */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, SICF_CPUHALT, SICF_CPUHALT);

	arm_cap_reg = (uint32 *)(regs + SI_CR4_CAP);
	corecap = R_REG(sii->osh, arm_cap_reg);

	nab = (corecap & ARMCR4_TCBANB_MASK) >> ARMCR4_TCBANB_SHIFT;
	nbb = (corecap & ARMCR4_TCBBNB_MASK) >> ARMCR4_TCBBNB_SHIFT;
	totb = nab + nbb;

	arm_bidx = (uint32 *)(regs + SI_CR4_BANKIDX);
	arm_binfo = (uint32 *)(regs + SI_CR4_BANKINFO);
	for (idx = 0; idx < totb; idx++) {
		W_REG(sii->osh, arm_bidx, idx);

		bxinfo = R_REG(sii->osh, arm_binfo);
		memsize += ((bxinfo & ARMCR4_BSZ_MASK) + 1) * ARMCR4_BSZ_MULT;
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);

	return memsize;
}

bool
si_has_flops(si_t *sih)
{
	uint origidx, cr4_rev;

	/* Find out CR4 core revision */
	origidx = si_coreidx(sih);
	if (si_setcore(sih, ARMCR4_CORE_ID, 0)) {
		cr4_rev = si_corerev(sih);
		si_setcoreidx(sih, origidx);

		if (cr4_rev == 1 || cr4_rev >= 3)
			return TRUE;
	}
	return FALSE;
}

uint32
si_socram_srmem_size(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;

	sbsocramregs_t *regs;
	bool wasup;
	uint corerev;
	uint32 coreinfo;
	uint memsize = 0;

	if ((CHIPID(sih->chip) == BCM4334_CHIP_ID) && (CHIPREV(sih->chiprev) < 2)) {
		return (32 * 1024);
	}

	if (CHIPID(sih->chip) == BCM43430_CHIP_ID) {
		return (64 * 1024);
	}

	/* Block ints and save current core */
	INTR_OFF(sii, intr_val);
	origidx = si_coreidx(sih);

	/* Switch to SOCRAM core */
	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
		goto done;

	/* Get info for determining size */
	if (!(wasup = si_iscoreup(sih)))
		si_core_reset(sih, 0, 0);
	corerev = si_corerev(sih);
	coreinfo = R_REG(sii->osh, &regs->coreinfo);

	/* Calculate size from coreinfo based on rev */
	if (corerev >= 16) {
		uint8 i;
		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
		for (i = 0; i < nb; i++) {
			W_REG(sii->osh, &regs->bankidx, i);
			if (R_REG(sii->osh, &regs->bankinfo) & SOCRAM_BANKINFO_RETNTRAM_MASK)
				memsize += socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_RAM);
		}
	}

	/* Return to previous state and core */
	if (!wasup)
		si_core_disable(sih, 0);
	si_setcoreidx(sih, origidx);

done:
	INTR_RESTORE(sii, intr_val);

	return memsize;
}


#if !defined(_CFEZ_) || defined(CFG_WL)
void
si_btcgpiowar(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	uint origidx;
	uint intr_val = 0;
	chipcregs_t *cc;

	/* Make sure that there is ChipCommon core present &&
	 * UART_TX is strapped to 1
	 */
	if (!(sih->cccaps & CC_CAP_UARTGPIO))
		return;

	/* si_corereg cannot be used as we have to guarantee 8-bit read/writes */
	INTR_OFF(sii, intr_val);

	origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	ASSERT(cc != NULL);

	W_REG(sii->osh, &cc->uart0mcr, R_REG(sii->osh, &cc->uart0mcr) | 0x04);

	/* restore the original index */
	si_setcoreidx(sih, origidx);

	INTR_RESTORE(sii, intr_val);
}

void
si_chipcontrl_btshd0_4331(si_t *sih, bool on)
{
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;
	chipcregs_t *cc;
	uint origidx;
	uint32 val;
	uint intr_val = 0;

	INTR_OFF(sii, intr_val);

	origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);

	val = R_REG(sii->osh, &cc->chipcontrol);

	/* bt_shd0 controls are same for 4331 chiprevs 0 and 1, packages 12x9 and 12x12 */
	if (on) {
		/* Enable bt_shd0 on gpio4: */
		val |= (CCTRL4331_BT_SHD0_ON_GPIO4);
		W_REG(sii->osh, &cc->chipcontrol, val);
	} else {
		val &= ~(CCTRL4331_BT_SHD0_ON_GPIO4);
		W_REG(sii->osh, &cc->chipcontrol, val);
	}

	/* restore the original index */
	si_setcoreidx(sih, origidx);

	INTR_RESTORE(sii, intr_val);
}

void
si_chipcontrl_restore(si_t *sih, uint32 val)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	W_REG(sii->osh, &cc->chipcontrol, val);
	si_setcoreidx(sih, origidx);
}

uint32
si_chipcontrl_read(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);
	uint32 val;

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	val = R_REG(sii->osh, &cc->chipcontrol);
	si_setcoreidx(sih, origidx);
	return val;
}

void
si_chipcontrl_epa4331(si_t *sih, bool on)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);
	uint32 val;

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	val = R_REG(sii->osh, &cc->chipcontrol);

	if (on) {
		if (sih->chippkg == 9 || sih->chippkg == 0xb) {
			val |= (CCTRL4331_EXTPA_EN | CCTRL4331_EXTPA_ON_GPIO2_5);
			/* Ext PA Controls for 4331 12x9 Package */
			W_REG(sii->osh, &cc->chipcontrol, val);
		} else {
			/* Ext PA Controls for 4331 12x12 Package */
			if (sih->chiprev > 0) {
				W_REG(sii->osh, &cc->chipcontrol, val |
				      (CCTRL4331_EXTPA_EN) | (CCTRL4331_EXTPA_EN2));
			} else {
				W_REG(sii->osh, &cc->chipcontrol, val | (CCTRL4331_EXTPA_EN));
			}
		}
	} else {
		val &= ~(CCTRL4331_EXTPA_EN | CCTRL4331_EXTPA_EN2 | CCTRL4331_EXTPA_ON_GPIO2_5);
		W_REG(sii->osh, &cc->chipcontrol, val);
	}

	si_setcoreidx(sih, origidx);
}

/** switch muxed pins, on: SROM, off: FEMCTRL. Called for a family of ac chips, not just 4360. */
void
si_chipcontrl_srom4360(si_t *sih, bool on)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);
	uint32 val;

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	val = R_REG(sii->osh, &cc->chipcontrol);

	if (on) {
		val &= ~(CCTRL4360_SECI_MODE |
			CCTRL4360_BTSWCTRL_MODE |
			CCTRL4360_EXTRA_FEMCTRL_MODE |
			CCTRL4360_BT_LGCY_MODE |
			CCTRL4360_CORE2FEMCTRL4_ON);

		W_REG(sii->osh, &cc->chipcontrol, val);
	} else {
	}

	si_setcoreidx(sih, origidx);
}

void
si_chipcontrl_epa4331_wowl(si_t *sih, bool enter_wowl)
{
	si_info_t *sii;
	chipcregs_t *cc;
	uint origidx;
	uint32 val;
	bool sel_chip;

	sel_chip = (CHIPID(sih->chip) == BCM4331_CHIP_ID) ||
		(CHIPID(sih->chip) == BCM43431_CHIP_ID);
	sel_chip &= ((sih->chippkg == 9 || sih->chippkg == 0xb));

	if (!sel_chip)
		return;

	sii = SI_INFO(sih);
	origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);

	val = R_REG(sii->osh, &cc->chipcontrol);

	if (enter_wowl) {
		val |= CCTRL4331_EXTPA_EN;
		W_REG(sii->osh, &cc->chipcontrol, val);
	} else {
		val |= (CCTRL4331_EXTPA_EN | CCTRL4331_EXTPA_ON_GPIO2_5);
		W_REG(sii->osh, &cc->chipcontrol, val);
	}
	si_setcoreidx(sih, origidx);
}
#endif 

uint
si_pll_reset(si_t *sih)
{
	uint err = 0;

	return (err);
}

/** Enable BT-COEX & Ex-PA for 4313 */
void
si_epa_4313war(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);

	/* EPA Fix */
	W_REG(sii->osh, &cc->gpiocontrol,
	R_REG(sii->osh, &cc->gpiocontrol) | GPIO_CTRL_EPA_EN_MASK);

	si_setcoreidx(sih, origidx);
}

void
si_clk_pmu_htavail_set(si_t *sih, bool set_clear)
{
}

/** Re-enable synth_pwrsw resource in min_res_mask for 4313 */
void
si_pmu_synth_pwrsw_4313_war(si_t *sih)
{
}

/** WL/BT control for 4313 btcombo boards >= P250 */
void
si_btcombo_p250_4313_war(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
	W_REG(sii->osh, &cc->gpiocontrol,
		R_REG(sii->osh, &cc->gpiocontrol) | GPIO_CTRL_5_6_EN_MASK);

	W_REG(sii->osh, &cc->gpioouten,
		R_REG(sii->osh, &cc->gpioouten) | GPIO_CTRL_5_6_EN_MASK);

	si_setcoreidx(sih, origidx);
}
void
si_btc_enable_chipcontrol(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);

	/* BT fix */
	W_REG(sii->osh, &cc->chipcontrol,
		R_REG(sii->osh, &cc->chipcontrol) | CC_BTCOEX_EN_MASK);

	si_setcoreidx(sih, origidx);
}
void
si_btcombo_43228_war(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);

	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);

	W_REG(sii->osh, &cc->gpioouten, GPIO_CTRL_7_6_EN_MASK);
	W_REG(sii->osh, &cc->gpioout, GPIO_OUT_7_EN_MASK);

	si_setcoreidx(sih, origidx);
}

/** check if the device is removed */
bool
si_deviceremoved(si_t *sih)
{
	uint32 w;

	switch (BUSTYPE(sih->bustype)) {
	case PCI_BUS:
		ASSERT(SI_INFO(sih)->osh != NULL);
		w = OSL_PCI_READ_CONFIG(SI_INFO(sih)->osh, PCI_CFG_VID, sizeof(uint32));
		if ((w & 0xFFFF) != VENDOR_BROADCOM)
			return TRUE;
		break;
	}
	return FALSE;
}

bool
si_is_sprom_available(si_t *sih)
{
	if (sih->ccrev >= 31) {
		si_info_t *sii;
		uint origidx;
		chipcregs_t *cc;
		uint32 sromctrl;

		if ((sih->cccaps & CC_CAP_SROM) == 0)
			return FALSE;

		sii = SI_INFO(sih);
		origidx = sii->curidx;
		cc = si_setcoreidx(sih, SI_CC_IDX);
		ASSERT(cc);
		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
		si_setcoreidx(sih, origidx);
		return (sromctrl & SRC_PRESENT);
	}

	switch (CHIPID(sih->chip)) {
	case BCM4312_CHIP_ID:
		return ((sih->chipst & CST4312_SPROM_OTP_SEL_MASK) != CST4312_OTP_SEL);
	case BCM4325_CHIP_ID:
		return (sih->chipst & CST4325_SPROM_SEL) != 0;
	case BCM4322_CHIP_ID:	case BCM43221_CHIP_ID:	case BCM43231_CHIP_ID:
	case BCM43222_CHIP_ID:	case BCM43111_CHIP_ID:	case BCM43112_CHIP_ID:
	case BCM4342_CHIP_ID: {
		uint32 spromotp;
		spromotp = (sih->chipst & CST4322_SPROM_OTP_SEL_MASK) >>
		        CST4322_SPROM_OTP_SEL_SHIFT;
		return (spromotp & CST4322_SPROM_PRESENT) != 0;
	}
	case BCM4329_CHIP_ID:
		return (sih->chipst & CST4329_SPROM_SEL) != 0;
	case BCM4315_CHIP_ID:
		return (sih->chipst & CST4315_SPROM_SEL) != 0;
	case BCM4319_CHIP_ID:
		return (sih->chipst & CST4319_SPROM_SEL) != 0;
	case BCM4336_CHIP_ID:
	case BCM43362_CHIP_ID:
		return (sih->chipst & CST4336_SPROM_PRESENT) != 0;
	case BCM4330_CHIP_ID:
		return (sih->chipst & CST4330_SPROM_PRESENT) != 0;
	case BCM4313_CHIP_ID:
		return (sih->chipst & CST4313_SPROM_PRESENT) != 0;
	case BCM4331_CHIP_ID:
	case BCM43431_CHIP_ID:
		return (sih->chipst & CST4331_SPROM_PRESENT) != 0;
	case BCM43239_CHIP_ID:
		return ((sih->chipst & CST43239_SPROM_MASK) &&
			!(sih->chipst & CST43239_SFLASH_MASK));
	case BCM4324_CHIP_ID:
	case BCM43242_CHIP_ID:
		return ((sih->chipst & CST4324_SPROM_MASK) &&
			!(sih->chipst & CST4324_SFLASH_MASK));
	case BCM4335_CHIP_ID:
	case BCM4345_CHIP_ID:
		return ((sih->chipst & CST4335_SPROM_MASK) &&
			!(sih->chipst & CST4335_SFLASH_MASK));
	case BCM4349_CHIP_GRPID:
		return (sih->chipst & CST4349_SPROM_PRESENT) != 0;
		break;
	case BCM4350_CHIP_ID:
	case BCM4354_CHIP_ID:
	case BCM4356_CHIP_ID:
	case BCM43556_CHIP_ID:
	case BCM43558_CHIP_ID:
	case BCM43566_CHIP_ID:
	case BCM43568_CHIP_ID:
	case BCM43569_CHIP_ID:
	case BCM43570_CHIP_ID:
	case BCM4358_CHIP_ID:
		return (sih->chipst & CST4350_SPROM_PRESENT) != 0;
	case BCM43602_CHIP_ID:
		return (sih->chipst & CST43602_SPROM_PRESENT) != 0;
	case BCM43131_CHIP_ID:
	case BCM43217_CHIP_ID:
	case BCM43227_CHIP_ID:
	case BCM43228_CHIP_ID:
	case BCM43428_CHIP_ID:
		return (sih->chipst & CST43228_OTP_PRESENT) != CST43228_OTP_PRESENT;
	default:
		return TRUE;
	}
}


uint32 si_get_sromctl(si_t *sih)
{
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);
	uint32 sromctl;
	osl_t *osh = si_osh(sih);

	cc = si_setcoreidx(sih, SI_CC_IDX);
	ASSERT((uintptr)cc);

	sromctl = R_REG(osh, &cc->sromcontrol);

	/* return to the original core */
	si_setcoreidx(sih, origidx);
	return sromctl;
}

int si_set_sromctl(si_t *sih, uint32 value)
{
	chipcregs_t *cc;
	uint origidx = si_coreidx(sih);
	osl_t *osh = si_osh(sih);

	cc = si_setcoreidx(sih, SI_CC_IDX);
	ASSERT((uintptr)cc);

	/* get chipcommon rev */
	if (si_corerev(sih) < 32)
		return BCME_UNSUPPORTED;

	W_REG(osh, &cc->sromcontrol, value);

	/* return to the original core */
	si_setcoreidx(sih, origidx);
	return BCME_OK;

}

uint
si_core_wrapperreg(si_t *sih, uint32 coreidx, uint32 offset, uint32 mask, uint32 val)
{
	uint origidx, intr_val = 0;
	uint ret_val;
	si_info_t *sii = SI_INFO(sih);
	si_cores_info_t *cores_info = (si_cores_info_t *)sii->cores_info;

	origidx = si_coreidx(sih);

	INTR_OFF(sii, intr_val);
	si_setcoreidx(sih, coreidx);

	ret_val = si_wrapperreg(sih, offset, mask, val);

	/* return to the original core */
	si_setcoreidx(sih, origidx);
	INTR_RESTORE(sii, intr_val);
	return ret_val;
}


/* cleanup the timer from the host when ARM is been halted
 * without a chance for ARM cleanup its resources
 * If left not cleanup, Intr from a software timer can still
 * request HT clk when ARM is halted.
 */
uint32
si_pmu_res_req_timer_clr(si_t *sih)
{
	uint32 mask;

	mask = PRRT_REQ_ACTIVE | PRRT_INTEN | PRRT_HT_REQ;
	if (CHIPID(sih->chip) != BCM4328_CHIP_ID)
		mask <<= 14;
	/* clear mask bits */
	pmu_corereg(sih, SI_CC_IDX, res_req_timer, mask, 0);
	/* readback to ensure write completes */
	return pmu_corereg(sih, SI_CC_IDX, res_req_timer, 0, 0);
}

/** turn on/off rfldo */
void
si_pmu_rfldo(si_t *sih, bool on)
{
}


#ifdef SURVIVE_PERST_ENAB
static uint32
si_pcie_survive_perst(si_t *sih, uint32 mask, uint32 val)
{
	si_info_t *sii;

	sii = SI_INFO(sih);

	if (!PCIE(sii))
		return (0);

	return pcie_survive_perst(sii->pch, mask, val);
}

static void
si_watchdog_reset(si_t *sih)
{
	si_info_t *sii = SI_INFO(sih);
	uint32 i;

	/* issue a watchdog reset */
	pmu_corereg(sih, SI_CC_IDX, pmuwatchdog, 2, 2);
	/* do busy wait for 20ms */
	for (i = 0; i < 2000; i++) {
		OSL_DELAY(10);
	}
}
#endif /* SURVIVE_PERST_ENAB */

void
si_survive_perst_war(si_t *sih, bool reset, uint32 sperst_mask, uint32 sperst_val)
{
#ifdef SURVIVE_PERST_ENAB
	if (BUSTYPE(sih->bustype) != PCI_BUS)
		  return;

	if ((CHIPID(sih->chip) != BCM4360_CHIP_ID && CHIPID(sih->chip) != BCM4352_CHIP_ID) ||
	    (CHIPREV(sih->chiprev) >= 4))
		return;

	if (reset) {
		si_info_t *sii = SI_INFO(sih);
		uint32 bar0win, bar0win_after;

		/* save the bar0win */
		bar0win = OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));

		si_watchdog_reset(sih);

		bar0win_after = OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
		if (bar0win_after != bar0win) {
			SI_ERROR(("%s: bar0win before %08x, bar0win after %08x\n",
				__FUNCTION__, bar0win, bar0win_after));
			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32), bar0win);
		}
	}
	if (sperst_mask) {
		/* enable survive perst */
		si_pcie_survive_perst(sih, sperst_mask, sperst_val);
	}
#endif /* SURVIVE_PERST_ENAB */
}

void
si_pcie_ltr_war(si_t *sih)
{
}

void
si_pcie_hw_LTR_war(si_t *sih)
{
}

void
si_pciedev_reg_pm_clk_period(si_t *sih)
{
}

void
si_pciedev_crwlpciegen2(si_t *sih)
{
}

void
si_pcie_prep_D3(si_t *sih, bool enter_D3)
{
}
// Page.cs
//

using System;
using System.Collections.Generic;
using System.Html;
using jQueryApi;

[ScriptModule]
internal static class Page {

    static Page() {
        jQuery.OnDocumentReady(delegate() {
            // TODO: Add script that runs once the document is ready for being
            //       consumed by script.
            //       You can also add other classes comprising your application
            //       to the project.
        });
    }
}
// ArrayMapCallback.cs
// Script#/Libraries/CoreLib
// This source code is subject to terms and conditions of the Apache License, Version 2.0.
//

using System;
using System.Runtime.CompilerServices;

namespace System.Collections {

    [ScriptIgnoreNamespace]
    [ScriptImport]
    public delegate object ArrayMapCallback(object value, int index, Array array);
}
"use strict";

define('test', ['ss'], function(ss) {
  var $global = this;

  // ExpressionTests.App

  function App() {
  }
  var App$ = {
    get__foo: function() {
      return 0;
    },
    test: function(x) {
      var t = ss.typeOf(x);
      var t2 = ss.typeOf(x.toString());
      var t3 = ss.typeOf(this.get__foo());
      var t4 = ss.type('String');
      var t5 = ss.type('test.Foo');
      var b1 = ss.canAssign((Object), App);
      var b2 = ss.canAssign((ss.IDisposable), App);
      var b3 = ss.canAssign(t, App);
      var b4 = ss.instanceOf((App), new App());
      var b5 = ss.instanceOf((ss.IDisposable), new App());
      var b6 = ss.instanceOf(t, new App());
      var b7 = ss.isInterface(t) || ss.isClass(t);
      var n = ss.typeName(t);
    }
  };


  var $exports = ss.module('test', null,
    {
      App: [ App, App$, null ]
    });


  return $exports;
});
const exec = require('./exec');

exec('gulp clean');
exec('NODE_ENV=gh-pages gulp build-docs');
exec('git checkout gh-pages');
exec('git add -f _gh_pages');
exec('git commit --no-verify -m "update gh-pages"');
exec('git filter-branch --subdirectory-filter _gh_pages/ -f');
package org.pcap4j.packet;

import static org.junit.Assert.*;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.pcap4j.packet.IcmpV6EchoReplyPacket.IcmpV6EchoReplyHeader;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.packet.namednumber.IcmpV6Code;
import org.pcap4j.packet.namednumber.IcmpV6Type;
import org.pcap4j.packet.namednumber.IpNumber;
import org.pcap4j.packet.namednumber.IpVersion;
import org.pcap4j.util.MacAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings("javadoc")
public class IcmpV6EchoReplyPacketTest extends AbstractPacketTest {

  private static final Logger logger
    = LoggerFactory.getLogger(IcmpV6EchoReplyPacketTest.class);

  private final IcmpV6EchoReplyPacket packet;
  private final short identifier;
  private final short sequenceNumber;

  public IcmpV6EchoReplyPacketTest() {
    this.identifier = (short)1234;
    this.sequenceNumber = (short)4321;

    UnknownPacket.Builder unknownb = new UnknownPacket.Builder();
    unknownb.rawData(new byte[] { (byte)0, (byte)1, (byte)2, (byte)3 });

    IcmpV6EchoReplyPacket.Builder b = new IcmpV6EchoReplyPacket.Builder();
    b.identifier(identifier)
     .sequenceNumber(sequenceNumber)
     .payloadBuilder(unknownb);
    this.packet = b.build();
  }

  @Override
  protected Packet getPacket() {
    return packet;
  }

  @Override
  protected Packet getWholePacket() {
    Inet6Address srcAddr;
    Inet6Address dstAddr;
    try {
      srcAddr = (Inet6Address)InetAddress.getByName("2001:db8::3:2:1");
      dstAddr = (Inet6Address)InetAddress.getByName("2001:db8::3:2:2");
    } catch (UnknownHostException e) {
      throw new AssertionError();
    }
    IcmpV6CommonPacket.Builder icmpV6b = new IcmpV6CommonPacket.Builder();
    icmpV6b.type(IcmpV6Type.ECHO_REPLY)
           .code(IcmpV6Code.NO_CODE)
           .srcAddr(srcAddr)
           .dstAddr(dstAddr)
           .payloadBuilder(new SimpleBuilder(packet))
           .correctChecksumAtBuild(true);

    IpV6Packet.Builder ipv6b = new IpV6Packet.Builder();
    ipv6b.version(IpVersion.IPV6)
         .trafficClass(IpV6SimpleTrafficClass.newInstance((byte)0x12))
         .flowLabel(IpV6SimpleFlowLabel.newInstance(0x12345))
         .nextHeader(IpNumber.ICMPV6)
         .hopLimit((byte)100)
         .srcAddr(srcAddr)
         .dstAddr(dstAddr)
         .correctLengthAtBuild(true)
         .payloadBuilder(icmpV6b);

    EthernetPacket.Builder eb = new EthernetPacket.Builder();
    eb.dstAddr(MacAddress.getByName("fe:00:00:00:00:02"))
      .srcAddr(MacAddress.getByName("fe:00:00:00:00:01"))
      .type(EtherType.IPV6)
      .payloadBuilder(ipv6b)
      .paddingAtBuild(true);
    return eb.build();
  }

  @BeforeClass
  public static void setUpBeforeClass() throws Exception {
    logger.info(
      "########## " + IcmpV6EchoReplyPacketTest.class.getSimpleName() + " START ##########"
    );
  }

  @AfterClass
  public static void tearDownAfterClass() throws Exception {
  }

  @Test
  public void testNewPacket() {
    try {
      IcmpV6EchoReplyPacket p
        = IcmpV6EchoReplyPacket
            .newPacket(packet.getRawData(), 0, packet.getRawData().length);
      assertEquals(packet, p);
    } catch (IllegalRawDataException e) {
      throw new AssertionError(e);
    }
  }

  @Test
  public void testGetHeader() {
    IcmpV6EchoReplyHeader h = packet.getHeader();
    assertEquals(identifier, h.getIdentifier());
    assertEquals(sequenceNumber, h.getSequenceNumber());

    IcmpV6EchoReplyPacket.Builder b = packet.getBuilder();
    IcmpV6EchoReplyPacket p;

    b.identifier((short)0);
    b.sequenceNumber((short)0);
    p = b.build();
    assertEquals((short)0, (short)p.getHeader().getIdentifierAsInt());
    assertEquals((short)0, (short)p.getHeader().getSequenceNumberAsInt());

    b.identifier((short)10000);
    b.sequenceNumber((short)10000);
    p = b.build();
    assertEquals((short)10000, (short)p.getHeader().getIdentifierAsInt());
    assertEquals((short)10000, (short)p.getHeader().getSequenceNumberAsInt());

    b.identifier((short)32767);
    b.sequenceNumber((short)32767);
    p = b.build();
    assertEquals((short)32767, (short)p.getHeader().getIdentifierAsInt());
    assertEquals((short)32767, (short)p.getHeader().getSequenceNumberAsInt());

    b.identifier((short)-1);
    b.sequenceNumber((short)-1);
    p = b.build();
    assertEquals((short)-1, (short)p.getHeader().getIdentifierAsInt());
    assertEquals((short)-1, (short)p.getHeader().getSequenceNumberAsInt());

    b.identifier((short)-32768);
    b.sequenceNumber((short)-32768);
    p = b.build();
    assertEquals((short)-32768, (short)p.getHeader().getIdentifierAsInt());
    assertEquals((short)-32768, (short)p.getHeader().getSequenceNumberAsInt());
  }

}
<?php

/*
 * This file is part of ConfigServiceProvider.
 *
 * (c) Igor Wiedler <igor@wiedler.ch>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Silex\Application;
use Igorw\Silex\ConfigServiceProvider;

/**
 * @author Igor Wiedler <igor@wiedler.ch>
 * @author Jrme Macias <jerome.macias@gmail.com>
 */
class ConfigServiceProviderTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @dataProvider provideFilenames
     */
    public function testRegisterWithoutReplacement($filename)
    {
        $app = new Application();

        $app->register(new ConfigServiceProvider($filename));

        $this->assertSame(true, $app['debug']);
        $this->assertSame('%data%', $app['data']);
    }

    /**
     * @dataProvider provideFilenames
     */
    public function testRegisterWithReplacement($filename)
    {
        $app = new Application();

        $app->register(new ConfigServiceProvider($filename, array(
            'data' => 'test-replacement'
        )));

        $this->assertSame(true, $app['debug']);
        $this->assertSame('test-replacement', $app['data']);
    }

    /**
     * @dataProvider provideEmptyFilenames
     */
    public function testEmptyConfigs($filename)
    {
        $readConfigMethod = new \ReflectionMethod('Igorw\Silex\ConfigServiceProvider', 'readConfig');
        $readConfigMethod->setAccessible(true);

        $this->assertEquals(
            array(),
            $readConfigMethod->invoke(new ConfigServiceProvider($filename))
        );
    }

    /**
     * @dataProvider provideReplacementFilenames
     */
    public function testInFileReplacements($filename)
    {
        $app = new Application();

        $app->register(new ConfigServiceProvider($filename));

        $this->assertSame('/var/www', $app['%path%']);
        $this->assertSame('/var/www/web/images', $app['path.images']);
        $this->assertSame('/var/www/upload', $app['path.upload']);
        $this->assertSame('http://example.com', $app['%url%']);
        $this->assertSame('http://example.com/images', $app['url.images']);
    }
    /**
     * Currently not tested via testMergeConfigs as TOML seems to have problems
     * to create 'db.options' keys
     */
    public function testTomlMergeConfigs()
    {
        $app = new Application();

        $filenameBase = __DIR__."/Fixtures/config_base.toml";
        $filenameExtended = __DIR__."/Fixtures/config_extend.toml";

        $app->register(new ConfigServiceProvider($filenameBase));
        $app->register(new ConfigServiceProvider($filenameExtended));

        $this->assertSame('pdo_mysql', $app['db']['driver']);
        $this->assertSame('utf8', $app['db']['charset']);
        $this->assertSame('127.0.0.1', $app['db']['host']);
        $this->assertSame('mydatabase', $app['db']['dbname']);
        $this->assertSame('root', $app['db']['user']);
        $this->assertSame('', $app['db']['password']);

        $this->assertSame('123', $app['myproject']['param1']);
        $this->assertSame('456', $app['myproject']['param2']);
        $this->assertSame('456', $app['myproject']['param3']);
        $this->assertSame(array(4, 5, 6), $app['myproject']['param4']);
        $this->assertSame('456', $app['myproject']['param5']);

        $this->assertSame(array(1, 2, 3, 4), $app['keys']['set']);
    }

    /**
     * @dataProvider provideFilenames
     */
    public function testConfigWithPrefix($filename)
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider($filename, array(), null, 'prefix'));
        $this->assertNotNull($app['prefix']);
        $this->assertSame(true, $app['prefix']['debug']);
        $this->assertSame('%data%', $app['prefix']['data']);
    }

    /**
     * @dataProvider provideMergeFilenames
     */
    public function testMergeConfigsWithPrefix($filenameBase, $filenameExtended)
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider($filenameBase, array(), null, 'prefix'));
        $app->register(new ConfigServiceProvider($filenameExtended, array(), null, 'prefix'));

        $this->assertNotNull($app['prefix']);

        $this->assertSame('pdo_mysql', $app['prefix']['db.options']['driver']);
        $this->assertSame(null, $app['prefix']['db.options']['password']);

        $this->assertSame('123', $app['prefix']['myproject.test']['param1']);
        $this->assertSame('123', $app['prefix']['myproject.test']['param3']['param2A']);
        $this->assertSame(array(4, 5, 6), $app['prefix']['myproject.test']['param4']);

        $this->assertSame(array(1,2,3,4), $app['prefix']['test.noparent.key']['test']);
    }

    /**
     * @dataProvider provideMergeFilenames
     */
    public function testConfigsWithMultiplePrefixes($filenameBase, $filenameExtended)
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider($filenameBase, array(), null, 'base'));
        $app->register(new ConfigServiceProvider($filenameExtended, array(), null, 'extended'));

        $this->assertSame(null, $app['extended']['db.options']['password']);
        $this->assertSame('123', $app['base']['myproject.test']['param1']);
        $this->assertSame('123', $app['base']['myproject.test']['param3']['param2A']);
        $this->assertSame(array(4, 5, 6), $app['extended']['myproject.test']['param4']);

        $this->assertSame(array(1,2,3,4), $app['extended']['test.noparent.key']['test']);
    }

    /**
     * @dataProvider provideMergeFilenames
     */
    public function testMergeConfigs($filenameBase, $filenameExtended)
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider($filenameBase));
        $app->register(new ConfigServiceProvider($filenameExtended));

        $this->assertSame('pdo_mysql', $app['db.options']['driver']);
        $this->assertSame('utf8', $app['db.options']['charset']);
        $this->assertSame('127.0.0.1', $app['db.options']['host']);
        $this->assertSame('mydatabase', $app['db.options']['dbname']);
        $this->assertSame('root', $app['db.options']['user']);
        $this->assertSame(null, $app['db.options']['password']);

        $this->assertSame('123', $app['myproject.test']['param1']);
        $this->assertSame('456', $app['myproject.test']['param2']);
        $this->assertSame('123', $app['myproject.test']['param3']['param2A']);
        $this->assertSame('456', $app['myproject.test']['param3']['param2B']);
        $this->assertSame('456', $app['myproject.test']['param3']['param2C']);
        $this->assertSame(array(4, 5, 6), $app['myproject.test']['param4']);
        $this->assertSame('456', $app['myproject.test']['param5']);

        $this->assertSame(array(1,2,3,4), $app['test.noparent.key']['test']);
    }

    /**
     * @test
     * @expectedException RuntimeException
     * @expectedExceptionMessage Invalid JSON provided "Syntax error" in
     */
    public function invalidJsonShouldThrowException()
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider(__DIR__."/Fixtures/broken.json"));
    }

    /**
     * @test
     * @expectedException Symfony\Component\Yaml\Exception\ParseException
     */
    public function invalidYamlShouldThrowException()
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider(__DIR__."/Fixtures/broken.yml"));
    }

    /**
     * @test
     * @expectedException \Exception
     */
    public function invalidTomlShouldThrowException()
    {
        $app = new Application();
        $app->register(new ConfigServiceProvider(__DIR__."/Fixtures/broken.toml"));
    }

    public function provideFilenames()
    {
        return array(
            array(__DIR__."/Fixtures/config.php"),
            array(__DIR__."/Fixtures/config.json"),
            array(__DIR__."/Fixtures/config.yml"),
            array(__DIR__."/Fixtures/config.toml"),
        );
    }

    public function provideReplacementFilenames()
    {
        return array(
            array(__DIR__."/Fixtures/config_replacement.php"),
            array(__DIR__."/Fixtures/config_replacement.json"),
            array(__DIR__."/Fixtures/config_replacement.yml"),
            array(__DIR__."/Fixtures/config_replacement.toml"),
        );
    }

    public function provideEmptyFilenames()
    {
        return array(
            array(__DIR__."/Fixtures/config_empty.php"),
            array(__DIR__."/Fixtures/config_empty.json"),
            array(__DIR__."/Fixtures/config_empty.yml"),
            array(__DIR__."/Fixtures/config_empty.toml"),
        );
    }

    public function provideMergeFilenames()
    {
        return array(
            array(__DIR__."/Fixtures/config_base.php", __DIR__."/Fixtures/config_extend.php"),
            array(__DIR__."/Fixtures/config_base.json", __DIR__."/Fixtures/config_extend.json"),
            array(__DIR__."/Fixtures/config_base.yml", __DIR__."/Fixtures/config_extend.yml"),
        );
    }
}

#include "cpp/capi.cpp"
#include "cpp/govalue.cpp"
#include "cpp/govaluetype.cpp"
#include "cpp/idletimer.cpp"
#include "cpp/connector.cpp"

#include "cpp/moc_all.cpp"

#ifdef _WIN32
#include "cpp/mmemwin.cpp"
#endif
//
//  TEAttributesInspector.h
//  ThemeEngine
//
//  Created by Alexander Zielenski on 6/15/15.
//  Copyright  2015 Alex Zielenski. All rights reserved.
//

#import "TEInspectorDetailController.h"

@interface TEAttributesInspector : TEInspectorDetailController

@end
# AUTO-GENERATED FILE - DO NOT EDIT!! Use ldapmodify.
# CRC32 3af1a155
dn: cn={1}cosine
objectClass: olcSchemaConfig
cn: {1}cosine
olcAttributeTypes: {0}( 0.9.2342.19200300.100.1.2 NAME 'textEncodedORAddress' 
 EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.
 1466.115.121.1.15{256} )
olcAttributeTypes: {1}( 0.9.2342.19200300.100.1.4 NAME 'info' DESC 'RFC1274: g
 eneral information' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{2048} )
olcAttributeTypes: {2}( 0.9.2342.19200300.100.1.5 NAME ( 'drink' 'favouriteDri
 nk' ) DESC 'RFC1274: favorite drink' EQUALITY caseIgnoreMatch SUBSTR caseIgno
 reSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {3}( 0.9.2342.19200300.100.1.6 NAME 'roomNumber' DESC 'RFC1
 274: room number' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch S
 YNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {4}( 0.9.2342.19200300.100.1.7 NAME 'photo' DESC 'RFC1274: 
 photo (G3 fax)' SYNTAX 1.3.6.1.4.1.1466.115.121.1.23{25000} )
olcAttributeTypes: {5}( 0.9.2342.19200300.100.1.8 NAME 'userClass' DESC 'RFC12
 74: category of user' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMat
 ch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {6}( 0.9.2342.19200300.100.1.9 NAME 'host' DESC 'RFC1274: h
 ost computer' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTA
 X 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {7}( 0.9.2342.19200300.100.1.10 NAME 'manager' DESC 'RFC127
 4: DN of manager' EQUALITY distinguishedNameMatch SYNTAX 1.3.6.1.4.1.1466.115
 .121.1.12 )
olcAttributeTypes: {8}( 0.9.2342.19200300.100.1.11 NAME 'documentIdentifier' D
 ESC 'RFC1274: unique identifier of document' EQUALITY caseIgnoreMatch SUBSTR 
 caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {9}( 0.9.2342.19200300.100.1.12 NAME 'documentTitle' DESC '
 RFC1274: title of document' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstri
 ngsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {10}( 0.9.2342.19200300.100.1.13 NAME 'documentVersion' DES
 C 'RFC1274: version of document' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSu
 bstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {11}( 0.9.2342.19200300.100.1.14 NAME 'documentAuthor' DESC
  'RFC1274: DN of author of document' EQUALITY distinguishedNameMatch SYNTAX 1
 .3.6.1.4.1.1466.115.121.1.12 )
olcAttributeTypes: {12}( 0.9.2342.19200300.100.1.15 NAME 'documentLocation' DE
 SC 'RFC1274: location of document original' EQUALITY caseIgnoreMatch SUBSTR c
 aseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {13}( 0.9.2342.19200300.100.1.20 NAME ( 'homePhone' 'homeTe
 lephoneNumber' ) DESC 'RFC1274: home telephone number' EQUALITY telephoneNumb
 erMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121
 .1.50 )
olcAttributeTypes: {14}( 0.9.2342.19200300.100.1.21 NAME 'secretary' DESC 'RFC
 1274: DN of secretary' EQUALITY distinguishedNameMatch SYNTAX 1.3.6.1.4.1.146
 6.115.121.1.12 )
olcAttributeTypes: {15}( 0.9.2342.19200300.100.1.22 NAME 'otherMailbox' SYNTAX
  1.3.6.1.4.1.1466.115.121.1.39 )
olcAttributeTypes: {16}( 0.9.2342.19200300.100.1.26 NAME 'aRecord' EQUALITY ca
 seIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {17}( 0.9.2342.19200300.100.1.27 NAME 'mDRecord' EQUALITY c
 aseIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {18}( 0.9.2342.19200300.100.1.28 NAME 'mXRecord' EQUALITY c
 aseIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {19}( 0.9.2342.19200300.100.1.29 NAME 'nSRecord' EQUALITY c
 aseIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {20}( 0.9.2342.19200300.100.1.30 NAME 'sOARecord' EQUALITY 
 caseIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {21}( 0.9.2342.19200300.100.1.31 NAME 'cNAMERecord' EQUALIT
 Y caseIgnoreIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
olcAttributeTypes: {22}( 0.9.2342.19200300.100.1.38 NAME 'associatedName' DESC
  'RFC1274: DN of entry associated with domain' EQUALITY distinguishedNameMatc
 h SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
olcAttributeTypes: {23}( 0.9.2342.19200300.100.1.39 NAME 'homePostalAddress' D
 ESC 'RFC1274: home postal address' EQUALITY caseIgnoreListMatch SUBSTR caseIg
 noreListSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.41 )
olcAttributeTypes: {24}( 0.9.2342.19200300.100.1.40 NAME 'personalTitle' DESC 
 'RFC1274: personal title' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstring
 sMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {25}( 0.9.2342.19200300.100.1.41 NAME ( 'mobile' 'mobileTel
 ephoneNumber' ) DESC 'RFC1274: mobile telephone number' EQUALITY telephoneNum
 berMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.12
 1.1.50 )
olcAttributeTypes: {26}( 0.9.2342.19200300.100.1.42 NAME ( 'pager' 'pagerTelep
 honeNumber' ) DESC 'RFC1274: pager telephone number' EQUALITY telephoneNumber
 Match SUBSTR telephoneNumberSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1
 .50 )
olcAttributeTypes: {27}( 0.9.2342.19200300.100.1.43 NAME ( 'co' 'friendlyCount
 ryName' ) DESC 'RFC1274: friendly country name' EQUALITY caseIgnoreMatch SUBS
 TR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
olcAttributeTypes: {28}( 0.9.2342.19200300.100.1.44 NAME 'uniqueIdentifier' DE
 SC 'RFC1274: unique identifer' EQUALITY caseIgnoreMatch SYNTAX 1.3.6.1.4.1.14
 66.115.121.1.15{256} )
olcAttributeTypes: {29}( 0.9.2342.19200300.100.1.45 NAME 'organizationalStatus
 ' DESC 'RFC1274: organizational status' EQUALITY caseIgnoreMatch SUBSTR caseI
 gnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {30}( 0.9.2342.19200300.100.1.46 NAME 'janetMailbox' DESC '
 RFC1274: Janet mailbox' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5Subst
 ringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.26{256} )
olcAttributeTypes: {31}( 0.9.2342.19200300.100.1.47 NAME 'mailPreferenceOption
 ' DESC 'RFC1274: mail preference option' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
  )
olcAttributeTypes: {32}( 0.9.2342.19200300.100.1.48 NAME 'buildingName' DESC '
 RFC1274: name of building' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstrin
 gsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} )
olcAttributeTypes: {33}( 0.9.2342.19200300.100.1.49 NAME 'dSAQuality' DESC 'RF
 C1274: DSA Quality' SYNTAX 1.3.6.1.4.1.1466.115.121.1.19 SINGLE-VALUE )
olcAttributeTypes: {34}( 0.9.2342.19200300.100.1.50 NAME 'singleLevelQuality' 
 DESC 'RFC1274: Single Level Quality' SYNTAX 1.3.6.1.4.1.1466.115.121.1.13 SIN
 GLE-VALUE )
olcAttributeTypes: {35}( 0.9.2342.19200300.100.1.51 NAME 'subtreeMinimumQualit
 y' DESC 'RFC1274: Subtree Mininum Quality' SYNTAX 1.3.6.1.4.1.1466.115.121.1.
 13 SINGLE-VALUE )
olcAttributeTypes: {36}( 0.9.2342.19200300.100.1.52 NAME 'subtreeMaximumQualit
 y' DESC 'RFC1274: Subtree Maximun Quality' SYNTAX 1.3.6.1.4.1.1466.115.121.1.
 13 SINGLE-VALUE )
olcAttributeTypes: {37}( 0.9.2342.19200300.100.1.53 NAME 'personalSignature' D
 ESC 'RFC1274: Personal Signature (G3 fax)' SYNTAX 1.3.6.1.4.1.1466.115.121.1.
 23 )
olcAttributeTypes: {38}( 0.9.2342.19200300.100.1.54 NAME 'dITRedirect' DESC 'R
 FC1274: DIT Redirect' EQUALITY distinguishedNameMatch SYNTAX 1.3.6.1.4.1.1466
 .115.121.1.12 )
olcAttributeTypes: {39}( 0.9.2342.19200300.100.1.55 NAME 'audio' DESC 'RFC1274
 : audio (u-law)' SYNTAX 1.3.6.1.4.1.1466.115.121.1.4{25000} )
olcAttributeTypes: {40}( 0.9.2342.19200300.100.1.56 NAME 'documentPublisher' D
 ESC 'RFC1274: publisher of document' EQUALITY caseIgnoreMatch SUBSTR caseIgno
 reSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
olcObjectClasses: {0}( 0.9.2342.19200300.100.4.4 NAME ( 'pilotPerson' 'newPilo
 tPerson' ) SUP person STRUCTURAL MAY ( userid $ textEncodedORAddress $ rfc822
 Mailbox $ favouriteDrink $ roomNumber $ userClass $ homeTelephoneNumber $ hom
 ePostalAddress $ secretary $ personalTitle $ preferredDeliveryMethod $ busine
 ssCategory $ janetMailbox $ otherMailbox $ mobileTelephoneNumber $ pagerTelep
 honeNumber $ organizationalStatus $ mailPreferenceOption $ personalSignature 
 ) )
olcObjectClasses: {1}( 0.9.2342.19200300.100.4.5 NAME 'account' SUP top STRUCT
 URAL MUST userid MAY ( description $ seeAlso $ localityName $ organizationNam
 e $ organizationalUnitName $ host ) )
olcObjectClasses: {2}( 0.9.2342.19200300.100.4.6 NAME 'document' SUP top STRUC
 TURAL MUST documentIdentifier MAY ( commonName $ description $ seeAlso $ loca
 lityName $ organizationName $ organizationalUnitName $ documentTitle $ docume
 ntVersion $ documentAuthor $ documentLocation $ documentPublisher ) )
olcObjectClasses: {3}( 0.9.2342.19200300.100.4.7 NAME 'room' SUP top STRUCTURA
 L MUST commonName MAY ( roomNumber $ description $ seeAlso $ telephoneNumber 
 ) )
olcObjectClasses: {4}( 0.9.2342.19200300.100.4.9 NAME 'documentSeries' SUP top
  STRUCTURAL MUST commonName MAY ( description $ seeAlso $ telephonenumber $ l
 ocalityName $ organizationName $ organizationalUnitName ) )
olcObjectClasses: {5}( 0.9.2342.19200300.100.4.13 NAME 'domain' SUP top STRUCT
 URAL MUST domainComponent MAY ( associatedName $ organizationName $ descripti
 on $ businessCategory $ seeAlso $ searchGuide $ userPassword $ localityName $
  stateOrProvinceName $ streetAddress $ physicalDeliveryOfficeName $ postalAdd
 ress $ postalCode $ postOfficeBox $ streetAddress $ facsimileTelephoneNumber 
 $ internationalISDNNumber $ telephoneNumber $ teletexTerminalIdentifier $ tel
 exNumber $ preferredDeliveryMethod $ destinationIndicator $ registeredAddress
  $ x121Address ) )
olcObjectClasses: {6}( 0.9.2342.19200300.100.4.14 NAME 'RFC822localPart' SUP d
 omain STRUCTURAL MAY ( commonName $ surname $ description $ seeAlso $ telepho
 neNumber $ physicalDeliveryOfficeName $ postalAddress $ postalCode $ postOffi
 ceBox $ streetAddress $ facsimileTelephoneNumber $ internationalISDNNumber $ 
 telephoneNumber $ teletexTerminalIdentifier $ telexNumber $ preferredDelivery
 Method $ destinationIndicator $ registeredAddress $ x121Address ) )
olcObjectClasses: {7}( 0.9.2342.19200300.100.4.15 NAME 'dNSDomain' SUP domain 
 STRUCTURAL MAY ( ARecord $ MDRecord $ MXRecord $ NSRecord $ SOARecord $ CNAME
 Record ) )
olcObjectClasses: {8}( 0.9.2342.19200300.100.4.17 NAME 'domainRelatedObject' D
 ESC 'RFC1274: an object related to an domain' SUP top AUXILIARY MUST associat
 edDomain )
olcObjectClasses: {9}( 0.9.2342.19200300.100.4.18 NAME 'friendlyCountry' SUP c
 ountry STRUCTURAL MUST friendlyCountryName )
olcObjectClasses: {10}( 0.9.2342.19200300.100.4.20 NAME 'pilotOrganization' SU
 P ( organization $ organizationalUnit ) STRUCTURAL MAY buildingName )
olcObjectClasses: {11}( 0.9.2342.19200300.100.4.21 NAME 'pilotDSA' SUP dsa STR
 UCTURAL MAY dSAQuality )
olcObjectClasses: {12}( 0.9.2342.19200300.100.4.22 NAME 'qualityLabelledData' 
 SUP top AUXILIARY MUST dsaQuality MAY ( subtreeMinimumQuality $ subtreeMaximu
 mQuality ) )
structuralObjectClass: olcSchemaConfig
entryUUID: 7dad43c8-0d3b-1035-8e81-8186c64ef1f3
creatorsName: cn=config
createTimestamp: 20151022190440Z
entryCSN: 20151022190440.337724Z#000000#000#000000
modifiersName: cn=config
modifyTimestamp: 20151022190440Z
include:
  - makina-states.services_managers.circus.hooks
{%  set settings = salt['mc_circus.settings']() %}
{%  if salt['mc_nodetypes.has_system_services_manager']() %}
circus-hard-start:
  service.running:
    - names: {{settings.services}}
    - enable: True
    - watch:
      - mc_proxy: circus-pre-hard-restart
    - watch_in:
      - mc_proxy: circus-post-hard-restart
circus-start:
  service.running:
    - names: {{settings.services}}
    - enable: True
    - reload: True
    - watch:
      - mc_proxy: circus-pre-restart
    - watch_in:
      - mc_proxy: circus-post-restart
{%  endif %}
include:
  - makina-states.services.base.ntp.hooks
ntp-pkgs:
  pkg.{{salt['mc_pkgs.settings']()['installmode']}}:
    - pkgs:
      - ntp
      - ntpdate
      - libopts25
    - watch_in:
      - mc_proxy: ntp-post-install-hook
    - watch:
      - mc_proxy: ntp-pre-install-hook
import _ from 'lodash';

import ListField from '../list_field.js';

function getListFields() {
	return _.filter(this.getFields(), function(field) {
		return field instanceof ListField;
	});
};

export default getListFields;# LDAP Defaults
{% set data = salt['mc_ldap.settings']() %}
# !!!  MANAGED VIA SALT DO NOT EDIT !!!
# See ldap.conf(5) for details
# This file should be world readable but not world writable.
#SIZELIMIT	12
#TIMELIMIT	15
#DEREF		never
BASE       {{ data.ldap_base }}
URI        {{ data.ldap_uri }}
{% if data.ldap_cacert != '' %}
TLS_CACERT {{ data.ldap_cacert }}
{% endif %}
TLS_REQCERT allow
#!/usr/bin/env python
'''

.. _module_mc_provider:

mc_provider / provider functions
============================================



Useful functions to locate a particular host
or setting
'''

# -*- coding: utf-8 -*-
# Import python libs
import xmlrpclib
import logging
import urllib2
import requests
import mc_states.api
from salt.utils.odict import OrderedDict

import salt.exceptions

class ClientNotActivated(salt.exceptions.SaltException):
    """."""

__name = 'provider'
_marker = object()

log = logging.getLogger(__name__)

try:
    import ovh
    HAS_OVH = True
except ImportError:
    HAS_OVH = False


def settings():
    '''
    provider settings

        is
            booleans

            online
                are we on an online host
            ovh
                are we on an ovh host
            sys
                are we on an soyoustart host

        have_rpn
            online specific: do we have rpn

    '''
    @mc_states.api.lazy_subregistry_get(__salt__, __name)
    def _settings():
        grains = __grains__
        is_ovh = 'ovh' in __grains__['id']
        is_sys = __grains__['id'].startswith('sys-')
        is_online = 'online-dc' in __grains__['id']
        have_rpn = None
        ifaces = grains['ip_interfaces'].items()
        data = __salt__['mc_utils.defaults'](
            'makina-states.localsettings.provider', {
                'gandi': {
                    'default': {
                        'activated': False,
                        'api': 'https://rpc.gandi.net/xmlrpc/',
                        'api_key': None,
                    }
                },
                'ovh': {
                    'default': {
                        'activated': False,
                        'api': 'https://eu.api.ovh.com/1.0',
                        'endpoint': 'ovh-eu',
                        'login': None,
                        'password': None,
                        'application_name': None,
                        'application_description': None,
                        'application_key': None,
                        'application_secret': None,
                        'consumer_key': None,
                    }
                },
                'is': {
                    'online': is_online,
                    'ovh': is_ovh,
                    'sys': is_sys,
                },
                'have_rpn': have_rpn,
            })
        if data['is']['online'] and data['have_rpn'] is None:
            for ifc in ['eth1', 'em1']:
                if True in [ifc == a[0] for a in ifaces]:
                    data['have_rpn'] = True  # must stay none if not found
        return data
    return _settings()


def get_provider_opt(provider, opt, default=_marker, domain=None):
    data = settings()[provider]
    val = _marker
    if domain:
        val = data.get(domain, {}).get(opt, _marker)
    if val is _marker:
        val = data['default'].get(opt, _marker)
    if val is _marker:
        if default is not _marker:
            val = default
        else:
            raise KeyError(opt)
    return val


def get_ovh_opt(opt, default=None, domain=None):
    return get_provider_opt('ovh', opt, domain=domain)


def get_gandi_opt(opt, default=None, domain=None):
    return get_provider_opt('gandi', opt, domain=domain)


def ovh_auth(app_key=None):
    if not app_key:
        app_key = get_ovh_opt('application_key')
    headers = {"X-Ovh-Application": app_key,
               "Content-type": "application/json"}
    end_point = get_ovh_opt('api') + '/auth/credential'
    payload = __salt__['mc_utils.json_dump']({
        "accessRules": [
            {"method": "POST", "path": "/*"},
            {"method": "GET", "path": "/*"},
            {"method": "PUT", "path": "/*"},
            {"method": "DELETE", "path": "/*"}
        ],
        "redirection": "https://www.makina-corpus.com",
    })
    try:
        res = requests.post(end_point, data=payload, headers=headers)
        data = res.json()
    except (urllib2.HTTPError,) as exc:
        if exc.getcode() == 404:
            raise Exception('register a new app on'
                            ' https://eu.api.ovh.com/createApp/')
    return data


def gandi_client(**kw):
    domain = kw.get('domain', None)
    if not get_gandi_opt('activated', domain=domain):
        raise ClientNotActivated('gandi')
    uapi = get_gandi_opt('api', domain=domain)
    apikey = get_gandi_opt('api_key', domain=domain)
    api = xmlrpclib.ServerProxy(uapi)
    return api, apikey


def ovh_client(**kw):
    domain = kw.pop('domain', None)
    if not get_ovh_opt('activated', domain=domain):
        raise ClientNotActivated('ovh')
    if not HAS_OVH:
        raise ValueError(
            'Please install ovh bindings, pip install ovh')
    ckw = {}
    for i in [
        'application_key',
        'endpoint',
        'application_secret',
        'consumer_key'
    ]:
        ckw[i] = kw.setdefault(i, get_ovh_opt(i, domain=domain))
    client = ovh.Client(**ckw)
    return client


def have_rpn():
    _s = __salt__
    providers = _s['mc_provider.settings']()
    have_rpn = providers['have_rpn']
    return have_rpn
# vim:set et sts=4 ts=4 tw=80:
This software is licensed under the LGPLv2.1, included below.

As a special exception to the GNU Lesser General Public License version 2.1
("LGPL2.1"), the copyright holders of this Library give you permission to
convey to a third party a Combined Work that links statically or dynamically
to this Library without providing any Minimal Corresponding Source or
Minimal Application Code or providing the installation information,
provided that you comply with the other provisions of LGPL2.1
and provided that you meet, for the Application the terms and conditions
of the license(s) which apply to the Application.

Except as stated in this special exception, the provisions of LGPL2.1 will
continue to comply in full to this Library. If you modify this Library, you
may apply this exception to your version of this Library, but you are not
obliged to do so. If you do not wish to do so, delete this exception
statement from your version. This exception does not (and cannot) modify any
license terms which apply to the Application, with which you must still
comply.


                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
<?php
/**
 * This file is part of GameQ.
 *
 * GameQ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GameQ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

namespace GameQ\Tests;

/**
 * GameQ tests class
 *
 * @package GameQ\Tests
 */
class GameQ extends \PHPUnit_Framework_TestCase
{

    /**
     * Holds stub on setup
     *
     * @type \GameQ\GameQ
     */
    protected $stub;

    /**
     * Setup to create our stub
     */
    public function setUp()
    {

        $this->stub = $this->getMock('\GameQ\GameQ', null);
    }

    /**
     * Test factory
     */
    public function testFactory()
    {

        $this->assertInstanceOf('\GameQ\GameQ', \GameQ\GameQ::factory());
    }

    /**
     * Test getters and setters
     */
    public function testGetSetOptions()
    {

        // Test null return for missing option
        $this->assertNull($this->stub->invalidoption);

        $this->stub->option1 = 'value1';

        // Verify the property is correct
        $this->assertEquals('value1', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')['option1']);

        // Verify the pull is correct
        $this->assertEquals('value1', $this->stub->option1);

        // Use set option chainable
        $this->stub->setOption('option1', 'value2');

        // Verify the property is correct
        $this->assertEquals('value2', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')['option1']);

        // Verify the pull is correct
        $this->assertEquals('value2', $this->stub->option1);
    }

    /**
     * Test adding/removing servers
     */
    public function testAddServer()
    {

        // Define some servers
        $servers = [
            [
                \GameQ\Server::SERVER_HOST => '127.0.0.1:27015',
                \GameQ\Server::SERVER_TYPE => 'css',
            ],
            [
                \GameQ\Server::SERVER_HOST => '127.0.0.1:27016',
                \GameQ\Server::SERVER_TYPE => 'css',
            ],
            [
                \GameQ\Server::SERVER_HOST => '127.0.0.1:27017',
                \GameQ\Server::SERVER_TYPE => 'css',
            ],
        ];

        // Test single add server
        $this->stub->addServer($servers[0]);

        $this->assertCount(1, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        // Clear the servers
        $this->stub->clearServers();

        $this->assertCount(0, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        // Add multiple servers
        $this->stub->addServers($servers);

        $this->assertCount(3, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        $this->stub->clearServers();
    }

    /**
     * Test adding servers from files
     *
     * @depends testAddServer
     */
    public function testAddServersFromFiles()
    {

        // Test single file
        $this->stub->addServersFromFiles(__DIR__ . '/Protocols/Providers/server_list1.json');

        $this->assertCount(2, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        $this->stub->clearServers();

        // Test adding from json array of files
        $this->stub->addServersFromFiles([
            __DIR__ . '/Protocols/Providers/server_list1.json',
        ]);

        $this->assertCount(2, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        $this->stub->clearServers();

        // Test adding bad file
        $this->stub->addServersFromFiles([
            __DIR__ . '/Protocols/Providers/server_list_bad.json',
        ]);

        // No servers should exist
        $this->assertCount(0, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        $this->stub->clearServers();

        // Test inaccessible file
        $this->stub->addServersFromFiles(__DIR__ . '/Protocols/Providers/server_listDoesnotexist.json');

        // No servers should exist
        $this->assertCount(0, \PHPUnit_Framework_Assert::readAttribute($this->stub, 'servers'));

        $this->stub->clearServers();
    }

    /**
     * Test adding/removing filters
     */
    public function testFiltersAddRemove()
    {

        // Add filter
        $this->stub->addFilter('test_filter');

        $this->assertArrayHasKey('test_filter', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')
        ['filters']);

        // Remove filter
        $this->stub->removeFilter('test_filter');

        $this->assertArrayNotHasKey('test_filter', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')
        ['filters']);

        // Test for lower case always
        $this->stub->addFilter('tEst_fiLTEr');

        $this->assertArrayHasKey('test_filter', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')
        ['filters']);

        // Remove filter always lower case
        $this->stub->removeFilter('tEst_fiLTEr');

        $this->assertArrayNotHasKey('test_filter', \PHPUnit_Framework_Assert::readAttribute($this->stub, 'options')
        ['filters']);
    }

    /**
     * Test filter application
     */
    public function testFilterApply()
    {

        // Define some fake results
        $fakeResults = [
            'key1' => 'val1',
            'key2' => 'val2',
        ];

        // Create a mock server
        $server = $this->getMockBuilder('\GameQ\Server')
                       ->disableOriginalConstructor()
                       ->getMock();

        // Create a mock GameQ
        $gq_mock = $this->getMock('\GameQ\GameQ', null, [ ]);
        $gq_mock->setOption('debug', false);
        $gq_mock->removeFilter('normalize');
        $gq_mock->addFilter('test');

        // Reflect on GameQ class so we can parse
        $gameq = new \ReflectionClass($gq_mock);

        // Get the parse method so we can call it
        $method = $gameq->getMethod('doApplyFilters');

        // Set the method to accessible
        $method->setAccessible(true);

        $testResult = $method->invoke($gq_mock, $fakeResults, $server);

        $this->assertEquals($fakeResults, $testResult);
    }

    /**
     * Test for bad filter and no exception is thrown
     */
    public function testBadFilterException()
    {

        // Define some fake results
        $fakeResults = [
            'key1' => 'val1',
            'key2' => 'val2',
        ];

        // Create a mock server
        $server = $this->getMockBuilder('\GameQ\Server')
                       ->disableOriginalConstructor()
                       ->getMock();

        // Create a mock GameQ
        $gq_mock = $this->getMock('\GameQ\GameQ', null, [ ]);
        $gq_mock->setOption('debug', false);
        $gq_mock->removeFilter('normalize');
        $gq_mock->addFilter('some_bad_filter');

        // Reflect on GameQ class so we can parse
        $gameq = new \ReflectionClass($gq_mock);

        // Get the parse method so we can call it
        $method = $gameq->getMethod('doApplyFilters');

        // Set the method to accessible
        $method->setAccessible(true);

        // No changes should be made
        $testResult = $method->invoke($gq_mock, $fakeResults, $server);

        $this->assertEquals($fakeResults, $testResult);
    }
}
/*
 * Copyright (c) 2012 cocos2d-x.org
 * http://www.cocos2d-x.org
 *
 * Copyright 2012 Yannick Loriot. All rights reserved.
 * http://yannickloriot.com
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

#include "CCControlPotentiometer.h"

NS_CC_EXT_BEGIN

ControlPotentiometer::ControlPotentiometer()
: _value(0.0f)
, _minimumValue(0.0f)
, _maximumValue(0.0f)
, _thumbSprite(nullptr)
, _progressTimer(nullptr)
{

}

ControlPotentiometer::~ControlPotentiometer()
{
    CC_SAFE_RELEASE(_thumbSprite);
    CC_SAFE_RELEASE(_progressTimer);
}

ControlPotentiometer* ControlPotentiometer::create(const char* backgroundFile, const char* progressFile, const char* thumbFile)
{
    ControlPotentiometer* pRet = new ControlPotentiometer();
    if (pRet != NULL)
    {
        // Prepare track for potentiometer
        Sprite *backgroundSprite      = Sprite::create(backgroundFile);

        // Prepare thumb for potentiometer
        Sprite *thumbSprite           = Sprite::create(thumbFile);

        // Prepare progress for potentiometer
        ProgressTimer *progressTimer  = ProgressTimer::create(Sprite::create(progressFile));
        //progressTimer.type              = ProgressTimer::RADIALCW;
        if (pRet->initWithTrackSprite_ProgressTimer_ThumbSprite(backgroundSprite, progressTimer, thumbSprite))
        {
            pRet->autorelease();
        }
        else
        {
            CC_SAFE_DELETE(pRet);
        }
    }
    return pRet;
}

bool ControlPotentiometer::initWithTrackSprite_ProgressTimer_ThumbSprite(Sprite* trackSprite, ProgressTimer* progressTimer, Sprite* thumbSprite)
{
    if (Control::init())
    {
        setProgressTimer(progressTimer);
        setThumbSprite(thumbSprite);
        thumbSprite->setPosition(progressTimer->getPosition());
        
        addChild(thumbSprite, 2);
        addChild(progressTimer, 1);
        addChild(trackSprite);
        
        setContentSize(trackSprite->getContentSize());
        
        // Init default values
        _minimumValue           = 0.0f;
        _maximumValue           = 1.0f;
        setValue(_minimumValue);
        return true;
    }
    return false;
}

void ControlPotentiometer::setEnabled(bool enabled)
{
    Control::setEnabled(enabled);
    if (_thumbSprite != NULL)
    {
        _thumbSprite->setOpacity((enabled) ? 255 : 128);
    }
}

void ControlPotentiometer::setValue(float value)
{
    // set new value with sentinel
    if (value < _minimumValue)
    {
        value                   = _minimumValue;
    }
	
    if (value > _maximumValue) 
    {
        value                   = _maximumValue;
    }
    
    _value                      = value;
    
    // Update thumb and progress position for new value
    float percent               = (value - _minimumValue) / (_maximumValue - _minimumValue);
    _progressTimer->setPercentage(percent * 100.0f);
    _thumbSprite->setRotation(percent * 360.0f);
    
    sendActionsForControlEvents(Control::EventType::VALUE_CHANGED);    
}

float ControlPotentiometer::getValue()
{
    return _value;
}

void ControlPotentiometer::setMinimumValue(float minimumValue)
{
    _minimumValue       = minimumValue;
    
    if (_minimumValue >= _maximumValue)
    {
        _maximumValue   = _minimumValue + 1.0f;
    }
    
    setValue(_maximumValue);
}

float ControlPotentiometer::getMinimumValue()
{
    return _minimumValue;
}

void ControlPotentiometer::setMaximumValue(float maximumValue)
{
    _maximumValue       = maximumValue;
    
    if (_maximumValue <= _minimumValue)
    {
        _minimumValue   = _maximumValue - 1.0f;
    }
    
    setValue(_minimumValue);
}

float ControlPotentiometer::getMaximumValue()
{
    return _maximumValue;
}

bool ControlPotentiometer::isTouchInside(Touch * touch)
{
    Vec2 touchLocation   = this->getTouchLocation(touch);
    
    float distance          = this->distanceBetweenPointAndPoint(_progressTimer->getPosition(), touchLocation);

    return distance < MIN(getContentSize().width / 2, getContentSize().height / 2);
}

bool ControlPotentiometer::onTouchBegan(Touch *pTouch, Event *pEvent)
{
    if (!this->isTouchInside(pTouch) || !this->isEnabled() || !isVisible())
    {
        return false;
    }
    
    _previousLocation    = this->getTouchLocation(pTouch);
    
    this->potentiometerBegan(_previousLocation);
    
    return true;
}

void ControlPotentiometer::onTouchMoved(Touch *pTouch, Event *pEvent)
{
    Vec2 location    = this->getTouchLocation(pTouch);

    this->potentiometerMoved(location);
}

void ControlPotentiometer::onTouchEnded(Touch *pTouch, Event *pEvent)
{
    this->potentiometerEnded(Vec2::ZERO);
}

float ControlPotentiometer::distanceBetweenPointAndPoint(Vec2 point1, Vec2 point2)
{
    float dx = point1.x - point2.x;
    float dy = point1.y - point2.y;
    return sqrt(dx*dx + dy*dy);
}

float ControlPotentiometer::angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(
    Vec2 beginLineA, 
    Vec2 endLineA,
    Vec2 beginLineB,
    Vec2 endLineB)
{
    float a = endLineA.x - beginLineA.x;
    float b = endLineA.y - beginLineA.y;
    float c = endLineB.x - beginLineB.x;
    float d = endLineB.y - beginLineB.y;
    
    float atanA = atan2(a, b);
    float atanB = atan2(c, d);
    
    // convert radiants to degrees
    return (atanA - atanB) * 180 / M_PI;
}

void ControlPotentiometer::potentiometerBegan(Vec2 location)
{
    setSelected(true);
    getThumbSprite()->setColor(Color3B::GRAY);
}

void ControlPotentiometer::potentiometerMoved(Vec2 location)
{
    float angle       = this->angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(
        _progressTimer->getPosition(),
        location,
        _progressTimer->getPosition(),
        _previousLocation);
    
    // fix value, if the 12 o'clock position is between location and previousLocation
    if (angle > 180)
    {
        angle -= 360;
    }
    else if (angle < -180)
    {
        angle += 360;
    }

    setValue(_value + angle / 360.0f * (_maximumValue - _minimumValue));
    
    _previousLocation    = location;
}

void ControlPotentiometer::potentiometerEnded(Vec2 location)
{
    getThumbSprite()->setColor(Color3B::WHITE);
    setSelected(false);
}

NS_CC_EXT_END
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/overshoot_interpolator">
    <translate
        android:fromXDelta="0"
        android:toXDelta="-100%p"
        android:duration="500"/>
</set>/****************************************************************************
 Copyright (c) 2013      Zynga Inc.
 Copyright (c) 2013-2014 Chukong Technologies Inc.
 
 http://www.cocos2d-x.org
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

#ifndef _FontFreetype_h_
#define _FontFreetype_h_

#include "CCFont.h"
#include "base/CCData.h"

#include <string>
#include <ft2build.h>

#if (CC_TARGET_PLATFORM == CC_PLATFORM_WP8) || (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
#define generic GenericFromFreeTypeLibrary
#define internal InternalFromFreeTypeLibrary
#endif

#include FT_FREETYPE_H
#include FT_STROKER_H

#if (CC_TARGET_PLATFORM == CC_PLATFORM_WP8) || (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
#undef generic
#undef internal
#endif


NS_CC_BEGIN

class CC_DLL FontFreeType : public Font
{
public:
    static const int DistanceMapSpread;

    static FontFreeType * create(const std::string &fontName, int fontSize, GlyphCollection glyphs, const char *customGlyphs,bool distanceFieldEnabled = false,int outline = 0);

    static void shutdownFreeType();

    bool     isDistanceFieldEnabled() const { return _distanceFieldEnabled;}
    float    getOutlineSize() const { return _outlineSize; }
    void     renderCharAt(unsigned char *dest,int posX, int posY, unsigned char* bitmap,long bitmapWidth,long bitmapHeight); 

    virtual FontAtlas   * createFontAtlas() override;
    virtual int         * getHorizontalKerningForTextUTF16(const std::u16string& text, int &outNumLetters) const override;
    
    unsigned char       * getGlyphBitmap(unsigned short theChar, long &outWidth, long &outHeight, Rect &outRect,int &xAdvance);
    
    virtual int           getFontMaxHeight() const override;  
    virtual int           getFontAscender() const;

protected:
    
    FontFreeType(bool distanceFieldEnabled = false,int outline = 0);
    virtual ~FontFreeType();
    bool   createFontObject(const std::string &fontName, int fontSize);
    
private:

    bool initFreeType();
    FT_Library getFTLibrary();
    
    int  getHorizontalKerningForChars(unsigned short firstChar, unsigned short secondChar) const;
    unsigned char       * getGlyphBitmapWithOutline(unsigned short theChar, FT_BBox &bbox);
    
    static FT_Library _FTlibrary;
    static bool       _FTInitialized;
    FT_Face           _fontRef;
    FT_Stroker        _stroker;
    std::string       _fontName;
    bool              _distanceFieldEnabled;
    float             _outlineSize;
};

NS_CC_END

#endif
/**
 Copyright 2013 BlackBerry Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 Original file from GamePlay3D: http://gameplay3d.org

 This file was modified to fit the cocos2d-x project
 */

#ifndef MATHUTIL_H_
#define MATHUTIL_H_

#include "CCMathBase.h"

NS_CC_MATH_BEGIN

/**
 * Defines a math utility class.
 *
 * This is primarily used for optimized internal math operations.
 */
class MathUtil
{
    friend class Mat4;
    friend class Vec3;

public:

    /**
     * Updates the given scalar towards the given target using a smoothing function.
     * The given response time determines the amount of smoothing (lag). A longer
     * response time yields a smoother result and more lag. To force the scalar to
     * follow the target closely, provide a response time that is very small relative
     * to the given elapsed time.
     *
     * @param x the scalar to update.
     * @param target target value.
     * @param elapsedTime elapsed time between calls.
     * @param responseTime response time (in the same units as elapsedTime).
     */
    static void smooth(float* x, float target, float elapsedTime, float responseTime);

    /**
     * Updates the given scalar towards the given target using a smoothing function.
     * The given rise and fall times determine the amount of smoothing (lag). Longer
     * rise and fall times yield a smoother result and more lag. To force the scalar to
     * follow the target closely, provide rise and fall times that are very small relative
     * to the given elapsed time.
     *
     * @param x the scalar to update.
     * @param target target value.
     * @param elapsedTime elapsed time between calls.
     * @param riseTime response time for rising slope (in the same units as elapsedTime).
     * @param fallTime response time for falling slope (in the same units as elapsedTime).
     */
    static void smooth(float* x, float target, float elapsedTime, float riseTime, float fallTime);

private:

    inline static void addMatrix(const float* m, float scalar, float* dst);

    inline static void addMatrix(const float* m1, const float* m2, float* dst);

    inline static void subtractMatrix(const float* m1, const float* m2, float* dst);

    inline static void multiplyMatrix(const float* m, float scalar, float* dst);

    inline static void multiplyMatrix(const float* m1, const float* m2, float* dst);

    inline static void negateMatrix(const float* m, float* dst);

    inline static void transposeMatrix(const float* m, float* dst);

    inline static void transformVec4(const float* m, float x, float y, float z, float w, float* dst);

    inline static void transformVec4(const float* m, const float* v, float* dst);

    inline static void crossVec3(const float* v1, const float* v2, float* dst);

    MathUtil();
};

NS_CC_MATH_END

#define MATRIX_SIZE ( sizeof(float) * 16)

#ifdef USE_NEON
#include "MathUtilNeon.inl"
#else
#include "MathUtil.inl"
#endif

#endif
<?xml version="1.0"?>
<doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping" xsi="http://www.w3.org/2001/XMLSchema-instance" schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">
  <entity name="Entities\Meeting" repository-class="Repositories\Meeting" table="meeting" tableName="meeting">
    <id name="id" type="integer">
      <generator strategy="AUTO"/>
    </id>
    <field name="title" type="string" length="255" nullable="true"/>
    <field name="before_text" type="text" nullable="true"/>
    <field name="after_text" type="text" nullable="true"/>
    <field name="date" type="date" nullable="true"/>
    <field name="time" type="time" nullable="true"/>
    <field name="venue" type="string" length="255" nullable="true"/>
    <field name="venue_url" type="string" length="255" nullable="true"/>
    <field name="created_at" type="datetime" nullable="true"/>
    <field name="updated_by" type="integer" nullable="true"/>
    <field name="updated_at" type="datetime" nullable="true"/>
    <many-to-one field="CreatedBy" target-entity="Entities\User" inversed-by="Meetings">
      <join-columns>
        <join-column name="created_by" referenced-column-name="id"/>
      </join-columns>
    </many-to-one>
    <one-to-many field="MeetingItems" target-entity="Entities\MeetingItem" mapped-by="Meeting"/>
  </entity>
</doctrine-mapping>
= Installing Trac as CGI =

{{{
#!div class=important
  ''Please note that using Trac via CGI is the slowest deployment method available. It is slower than [TracModPython mod_python], [TracFastCgi FastCGI] and even [trac:TracOnWindowsIisAjp IIS/AJP] on Windows.''
}}}

CGI script is the entrypoint that web-server calls when a web-request to an application is made. To generate the `trac.cgi` script run:
{{{
trac-admin /path/to/env deploy /path/to/www/trac
}}}
`trac.cgi` will be in the `cgi-bin` folder inside the given path. ''Make sure it is executable by your web server''. This command also copies `static resource` files to a `htdocs` directory of a given destination.

== Apache web-server configuration ==

In [http://httpd.apache.org/ Apache] there are two ways to run Trac as CGI:

 1. Use a `ScriptAlias` directive that maps an URL to the `trac.cgi` script (recommended)
 2. Copy the `trac.cgi` file into the directory for CGI executables used by your web server (commonly named `cgi-bin`). You can also create a symbolic link, but in that case make sure that the `FollowSymLinks` option is enabled for the `cgi-bin` directory.

To make Trac available at `http://yourhost.example.org/trac` add `ScriptAlias` directive to Apache configuration file, changing `trac.cgi` path to match your installation:
{{{
ScriptAlias /trac /path/to/www/trac/cgi-bin/trac.cgi
}}}

 ''Note that this directive requires enabled `mod_alias` module.''

If you're using Trac with a single project you need to set its location using the `TRAC_ENV` environment variable:
{{{
<Location "/trac">
  SetEnv TRAC_ENV "/path/to/projectenv"
</Location>
}}}

Or to use multiple projects you can specify their common parent directory using the `TRAC_ENV_PARENT_DIR` variable:
{{{
<Location "/trac">
  SetEnv TRAC_ENV_PARENT_DIR "/path/to/project/parent/dir"
</Location>
}}}

 ''Note that the `SetEnv` directive requires enabled `mod_env` module. It is also possible to set TRAC_ENV in trac.cgi. Just add the following code between "try:" and "from trac.web ...":''

{{{
    import os
    os.environ['TRAC_ENV'] = "/path/to/projectenv"
}}}

 '' Or for TRAC_ENV_PARENT_DIR: ''

{{{
    import os
    os.environ['TRAC_ENV_PARENT_DIR'] = "/path/to/project/parent/dir"
}}}

If you are using the [http://httpd.apache.org/docs/suexec.html Apache suEXEC] feature please see [http://trac.edgewall.org/wiki/ApacheSuexec].

On some systems, you ''may'' need to edit the shebang line in the `trac.cgi` file to point to your real Python installation path. On a Windows system you may need to configure Windows to know how to execute a .cgi file (Explorer -> Tools -> Folder Options -> File Types -> CGI).

=== Using WSGI ===

You can run a [http://henry.precheur.org/python/how_to_serve_cgi WSGI handler] [http://pythonweb.org/projects/webmodules/doc/0.5.3/html_multipage/lib/example-webserver-web-wsgi-simple-cgi.html under CGI].  You can [wiki:TracModWSGI#Thetrac.wsgiscript write your own application function], or use the deployed trac.wsgi's application.

== Mapping Static Resources ==

See TracInstall#MappingStaticResources.

== Adding Authentication ==

See TracInstall#ConfiguringAuthentication.

----
See also:  TracGuide, TracInstall, [wiki:TracModWSGI], TracFastCgi, TracModPython<?php
namespace Amqp\Base\Config\Interfaces;

use Symfony\Component\Config\Definition\ConfigurationInterface;

interface Processor
{
    /**
     * Retrieves the configuration for the main amqp definitions
     *
     * @param NamedConfigInterface $configurator The configurator interface which wil validate the config
     *
     * @return array
     */
    public function getDefinition(NamedConfigInterface $configurator);
}rootProject.name='rxkotlin'
<?php
/**
 * Opulence
 *
 * @link      https://www.opulencephp.com
 * @copyright Copyright (C) 2016 David Young
 * @license   https://github.com/opulencephp/Opulence/blob/master/LICENSE.md
 */
namespace Opulence\Databases\Adapters\Pdo;

use Opulence\Databases\IConnection;
use Opulence\Databases\IDriver;
use Opulence\Databases\Providers\Provider;
use Opulence\Databases\Server;

/**
 * Defines the base class for PDO drivers
 */
abstract class Driver implements IDriver
{
    /** @var Provider The provider this driver uses */
    protected $provider = null;

    public function __construct()
    {
        $this->setProvider();
    }

    /**
     * @inheritdoc
     * @return Connection The PDO connection
     */
    public function connect(Server $server, array $connectionOptions = [], array $driverOptions = []) : IConnection
    {
        $dsn = $this->getDsn($server, $connectionOptions);

        return new Connection($this->provider, $server, $dsn, $driverOptions);
    }

    /**
     * Gets the DSN string to connect to a server through PDO
     *
     * @param Server $server The server to connect to
     * @param array $options The list of driver-specific options
     * @return string The DSN to use to connect to PDO
     */
    abstract protected function getDsn(Server $server, array $options = []) : string;

    /**
     * Sets the provider used by this driver's connections
     */
    abstract protected function setProvider();
} <?php
/**
 * Opulence
 *
 * @link      https://www.opulencephp.com
 * @copyright Copyright (C) 2016 David Young
 * @license   https://github.com/opulencephp/Opulence/blob/master/LICENSE.md
 */
namespace Opulence\Authentication\Clients\Orm;

use Opulence\Authentication\Clients\IClient;

/**
 * Defines the interface for client repositories to implement
 */
interface IClientRepository
{
    /**
     * Adds a client
     *
     * @param IClient $client The client to add
     */
    public function add(IClient $client);

    /**
     * Deletes a client
     *
     * @param IClient $client The client to delete
     */
    public function delete(IClient $client);

    /**
     * Gets the client with the input Id
     *
     * @param int|string $id The Id to get by
     * @return IClient The client with the input Id
     */
    public function getById($id);
}<?php
/**
 * Opulence
 *
 * @link      https://www.opulencephp.com
 * @copyright Copyright (C) 2016 David Young
 * @license   https://github.com/opulencephp/Opulence/blob/master/LICENSE.md
 */
namespace Opulence\Events;

/**
 * Defines the event class
 */
class Event implements IEvent
{
    /** @var bool Whether or not the propagation has stopped */
    protected $propagationIsStopped = false;

    /**
     * @inheritdoc
     */
    public function propagationIsStopped() : bool
    {
        return $this->propagationIsStopped;
    }

    /**
     * @inheritdoc
     */
    public function stopPropagation()
    {
        $this->propagationIsStopped = true;
    }
}<?php
/**
 * Opulence
 *
 * @link      https://www.opulencephp.com
 * @copyright Copyright (C) 2016 David Young
 * @license   https://github.com/opulencephp/Opulence/blob/master/LICENSE.md
 */
namespace Opulence\Authentication\Tokens\JsonWebTokens\Verification;

use Opulence\Authentication\Tokens\JsonWebTokens\JwtPayload;
use Opulence\Authentication\Tokens\JsonWebTokens\SignedJwt;

/**
 * Tests the subject verifier
 */
class SubjectVerifierTest extends \PHPUnit\Framework\TestCase
{
    /** @var SubjectVerifier The verifier to use in tests */
    private $verifier = null;
    /** @var SignedJwt|\PHPUnit_Framework_MockObject_MockObject The token to use in tests */
    private $jwt = null;
    /** @var JwtPayload|\PHPUnit_Framework_MockObject_MockObject The payload to use in tests */
    private $jwtPayload = null;

    /**
     * Sets up the tests
     */
    public function setUp()
    {
        $this->verifier = new SubjectVerifier("foo");
        $this->jwt = $this->getMockBuilder(SignedJwt::class)
            ->disableOriginalConstructor()
            ->getMock();
        $this->jwtPayload = $this->createMock(JwtPayload::class);
        $this->jwt->expects($this->any())
            ->method("getPayload")
            ->willReturn($this->jwtPayload);
    }

    /**
     * Tests an invalid subject
     */
    public function testInvalidSubject()
    {
        $this->jwtPayload->expects($this->once())
            ->method("getSubject")
            ->willReturn("bar");
        $this->assertFalse($this->verifier->verify($this->jwt, $error));
        $this->assertEquals(JwtErrorTypes::SUBJECT_INVALID, $error);
    }

    /**
     * Tests verifying valid token
     */
    public function testVerifyingValidToken()
    {
        $this->jwtPayload->expects($this->once())
            ->method("getSubject")
            ->willReturn("foo");
        $this->assertTrue($this->verifier->verify($this->jwt, $error));
        $this->assertNull($error);
    }
}<?php

namespace Csanquer\Silex\PdoServiceProvider\Tests\Config;

use Csanquer\Silex\PdoServiceProvider\Config\SqlSrvConfig;

/**
 * TestCase for SqlSrvConfig
 *
 * @author Charles Sanquer <charles.sanquer@gmail.com>
 *
 */
class SqlSrvConfigTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var SqlSrvConfig
     */
    protected $pdoConfig;

    public function setUp()
    {
        $this->pdoConfig = new SqlSrvConfig();
    }

    /**
     * @dataProvider dataProviderPrepareParameters
     */
    public function testPrepareParameters($params, $expected)
    {
        $result = $this->pdoConfig->prepareParameters($params);
        $this->assertEquals($expected, $result);
    }

    public function dataProviderPrepareParameters()
    {
        return array(
            array(
                array(
                    'dbname' => 'fake-db',
                    'user' => 'fake-user',
                    'password' => 'fake-password',
                ),
                array(
                    'dsn' => 'sqlsrv:port=1433;dbname=fake-db;server=localhost',
                    'user' => 'fake-user',
                    'password' => 'fake-password',
                    'options' => array(),
                    'attributes' => array(),
                ),
            ),
            array(
                array(
                    'host' => '127.0.0.1',
                    'port' => null,
                    'dbname' => 'fake-db',
                    'user' => 'fake-user',
                    'password' => 'fake-password',
                    'attributes' => array(),
                ),
                array(
                    'dsn' => 'sqlsrv:dbname=fake-db;server=127.0.0.1',
                    'user' => 'fake-user',
                    'password' => 'fake-password',
                    'options' => array(),
                    'attributes' => array(),
                ),
            ),
        );
    }
}
<?php

/*
 * This file is part of the puli/repository package.
 *
 * (c) Bernhard Schussek <bschussek@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Puli\Repository\Api\ChangeStream;

use Puli\Repository\Api\NoVersionFoundException;
use Puli\Repository\Api\Resource\PuliResource;
use Puli\Repository\Api\ResourceRepository;

/**
 * Tracks different versions of a resource.
 *
 * @since  1.0
 *
 * @author Titouan Galopin <galopintitouan@gmail.com>
 * @author Bernhard Schussek <bschussek@gmail.com>
 */
interface ChangeStream
{
    /**
     * Stores a new version of a resource.
     *
     * @param PuliResource $resource The resource to store.
     */
    public function append(PuliResource $resource);

    /**
     * Removes all versions stored for a path.
     *
     * @param string $path The Puli path.
     */
    public function purge($path);

    /**
     * Returns whether the stream contains any version for a path.
     *
     * @param string $path The Puli path.
     *
     * @return bool Returns `true` if a version can be found and `false` otherwise.
     */
    public function contains($path);

    /**
     * Removes all contents of the stream.
     */
    public function clear();

    /**
     * Returns all versions of a resource.
     *
     * @param string             $path       The Puli path to look for.
     * @param ResourceRepository $repository The repository to attach the
     *                                       resources to.
     *
     * @return VersionList The versions of the resource.
     *
     * @throws NoVersionFoundException If no version is found for the path.
     */
    public function getVersions($path, ResourceRepository $repository = null);
}
// Copyright (c) 2002-2016 "Neo Technology,"
// Network Engine for Objects in Lund AB [http://neotechnology.com]
// 
// This file is part of Neo4j.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
using System.Collections.Generic;
using FluentAssertions;
using Neo4j.Driver.Internal.Messaging;
using Xunit;

namespace Neo4j.Driver.Tests
{
    public class MessageTests
    {
        public class MessageToStringMethod
        {
            public static IEnumerable<object[]> MessageData => new[]
            {
                new object[] {new FailureMessage("CODE", "MESSAGE"), "FAILURE code=CODE, message=MESSAGE"},
                new object[] {new InitMessage("mydriver", new Dictionary<string, object>()), "INIT `mydriver`"},
                new object[] {new SuccessMessage(new Dictionary<string, object>()), "SUCCESS []"},
                new object[] {new DiscardAllMessage(), "DISCARDALL"},
                new object[] {new IgnoredMessage(), "IGNORED"},
                new object[] {new PullAllMessage(), "PULLALL"},
                new object[]
                {
                    new RecordMessage(new object[] {1, "a string", new[] {3, 4}}),
                    "RECORD [1, a string, [3, 4]]"
                },
                new object[] {new ResetMessage(), "RESET"},
                new object[]
                {
                    new RunMessage("A statement", new Dictionary<string, object>
                    {
                        {"key1", 1},
                        {"key2", new[] {2, 4}}
                    }),
                    "RUN `A statement` [{key1 : 1}, {key2 : [2, 4]}]"
                }
            };

            [Theory, MemberData("MessageData")]
            internal void ShouldPrintTheMessageAsExpected(IMessage message, string expected)
            {
                message.ToString().Should().Be(expected);
            }
        }
    }
}<?php

namespace Tests\Extensions\Gedmo\Mappings\Tree;

use Gedmo\Tree\Entity\MappedSuperclass\AbstractClosure;
use LaravelDoctrine\Fluent\Builders\Field;
use LaravelDoctrine\Fluent\Extensions\Gedmo\Mappings\Tree\AbstractClosureMapping;
use Tests\Extensions\Gedmo\Mappings\MappingTestCase;

class AbstractClosureMappingTest extends MappingTestCase
{
    public function configureMocks()
    {
        $this->builder->shouldReceive('integer')->with('id')->once()->andReturn($this->field);
        $this->builder->shouldReceive('integer')->with('depth')->once()->andReturn(\Mockery::mock(Field::class));

        $this->field->shouldReceive('unsigned')->once()->andReturnSelf();
        $this->field->shouldReceive('primary')->once()->andReturnSelf();
        $this->field->shouldReceive('generatedValue')->once()->with(
            $this->generatedValueExpectation()
        )->andReturnSelf();
    }

    protected function getMappingClass()
    {
        return AbstractClosureMapping::class;
    }

    protected function getMappedClass()
    {
        return AbstractClosure::class;
    }
}
<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class Profile extends BaseProfile
{

}package de.lessvoid.nifty.elements.render;

import de.lessvoid.nifty.elements.Element;
import de.lessvoid.nifty.render.NiftyRenderEngine;
import de.lessvoid.nifty.tools.Color;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.Random;

/**
 * The ElementRenderer for a Panel.
 *
 * @author void
 */
public class PanelRenderer implements ElementRenderer {
  /**
   * the background color when used otherwise null.
   */
  @Nullable
  private Color backgroundColor;

  @Nullable
  private Color debugColor;

  /**
   * Default constructor.
   */
  public PanelRenderer() {
  }

  /**
   * render it.
   *
   * @param element the widget we're connected to
   * @param r       the renderDevice we should use
   */
  @Override
  public void render(@Nonnull final Element element, @Nonnull final NiftyRenderEngine r) {
    if (element.getNifty().isDebugOptionPanelColors()) {
      r.saveStates();
      r.setColor(getDebugColor());
      r.renderQuad(element.getX(), element.getY(), element.getWidth(), element.getHeight());
      r.restoreStates();
      return;
    }

    if (backgroundColor != null) {
      r.saveStates();
      if (!r.isColorChanged()) {
        if (r.isColorAlphaChanged()) {
          r.setColorIgnoreAlpha(backgroundColor);
        } else {
          r.setColor(backgroundColor);
        }
      }
      r.renderQuad(element.getX(), element.getY(), element.getWidth(), element.getHeight());
      r.restoreStates();
    }
  }

  @Nonnull
  private Color getDebugColor() {
    if (debugColor != null) {
      return debugColor;
    }
    final Random rnd = new Random();
    debugColor = new Color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), .5f);
    return debugColor;
  }

  public void setBackgroundColor(@Nullable final Color backgroundColor) {
    this.backgroundColor = backgroundColor;
  }

  @Nullable
  public Color getBackgroundColor() {
    return backgroundColor;
  }
}
package de.lessvoid.nifty.controls;

import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import de.lessvoid.nifty.controls.listbox.ListBoxItemProcessor;
import de.lessvoid.nifty.elements.Element;
import de.lessvoid.nifty.elements.render.TextRenderer;
import de.lessvoid.nifty.spi.render.RenderFont;


/**
 * The ListBox interface is the Nifty control API view of a Nifty ListBox control.
 *
 * @param <T>
 * @author void
 */
public interface ListBox<T> extends NiftyControl {
  /**
   * Change the {@link SelectionMode} to a new one.
   *
   * @param listBoxSelectionMode the new {@link SelectionMode} to use
   * @param forceSelection       if set to true will not allow de selecting the last item in the selection and
   *                             it will automatically select the first item added. when set to false it's possible
   *                             to have no
   *                             selection at all.
   */
  void changeSelectionMode(@Nonnull SelectionMode listBoxSelectionMode, boolean forceSelection);

  /**
   * Change the ListBoxViewConverter for this ListBox.
   *
   * @param viewConverter ListBoxViewConverter
   */
  void setListBoxViewConverter(@Nonnull ListBoxViewConverter<T> viewConverter);

  /**
   * Add a item to the ListBox.
   *
   * @param newItem the item to add
   */
  void addItem(@Nonnull T newItem);

  /**
   * Insert the given item at the given index.
   *
   * @param item  item
   * @param index the index to insert the item.
   */
  void insertItem(@Nonnull T item, int index);

  /**
   * Retrieve the number of items in the ListBox.
   *
   * @return number of items.
   */
  int itemCount();

  /**
   * Clear all items from this ListBox.
   */
  void clear();

  /**
   * Select the item with the given index in the ListBox. This might change the currently selected item if the {@link
   * SelectionMode#Single} is used or it will add to the selection if {@link SelectionMode#Multiple} is used.
   *
   * @param selectionIndex the item index to select in the ComboBox
   */
  void selectItemByIndex(final int selectionIndex);

  /**
   * Select the item in the ListBox.
   *
   * @param item the item to select
   */
  void selectItem(@Nonnull final T item);

  /**
   * Select the next item. This will only work in SingleSelection mode and when there currently
   * is an element selected.
   */
  void selectNext();

  /**
   * Select the previous item. This will only work in SingleSelection mode and when there currently
   * is an element selected.
   */
  void selectPrevious();

  /**
   * Deselect the item with the given itemIndex.
   *
   * @param itemIndex item index to deselect
   */
  void deselectItemByIndex(int itemIndex);

  /**
   * Deselect the given item.
   *
   * @param item item to deselect.
   */
  void deselectItem(@Nonnull T item);

  /**
   * Get the current selection.
   *
   * @return list of the selected items in this ListBox.
   */
  @Nonnull
  List<T> getSelection();

  /**
   * Get the current selection as a list of indices.
   *
   * @return list of indices for the current selection
   */
  @Nonnull
  List<Integer> getSelectedIndices();

  /**
   * Remove an item from the ListBox by index.
   *
   * @param itemIndex remove the item with the given index from the ListBox
   */
  void removeItemByIndex(int itemIndex);

  /**
   * Remove the given item from the ListBox.
   *
   * @param item the item to remove from the ListBox
   */
  void removeItem(@Nonnull T item);

  /**
   * Get all items of this ListBox.
   *
   * @return list of all items
   */
  @Nonnull
  List<T> getItems();

  /**
   * Make sure the given item is visible. This can also be used to make sure
   * you can see the element after a new item has been added to the ListBox.
   *
   * @param item the item
   */
  void showItem(@Nonnull T item);

  /**
   * Make sure the given item is visible.
   *
   * @param itemIndex the item index to make visible
   */
  void showItemByIndex(int itemIndex);

  /**
   * Change the current focus item to the item given. The focus item is the item
   * you can change with the cursor keys. It just marks the item it does not change
   * the selection.
   *
   * @param item the item to set the focus to
   */
  void setFocusItem(@Nullable T item);

  /**
   * Change the current focus item to the given index.
   *
   * @param itemIndex the new focus item
   */
  void setFocusItemByIndex(int itemIndex);

  /**
   * Get the current item that has the focus.
   *
   * @return the item that has the focus
   */
  @Nullable
  T getFocusItem();

  /**
   * Get the index of the current focus item.
   *
   * @return the index of the current focus item.
   */
  int getFocusItemIndex();

  /**
   * Add all items to the ListBox.
   *
   * @param itemsToAdd all items to add
   */
  void addAllItems(@Nonnull Collection<T> itemsToAdd);

  /**
   * Remove all items given in the List from this ListBox.
   *
   * @param itemsToRemove list of items to remove
   */
  void removeAllItems(@Nonnull Collection<T> itemsToRemove);

  /**
   * Sort all items using natural ordering.
   */
  void sortAllItems();

  /**
   * Returns the number of items this ListBox can display without being scrolled.
   *
   * @return number of display items
   */
  int getDisplayItemCount();

  /**
   * Sort all items using the given comparator.
   */
  void sortAllItems(@Nullable Comparator<T> comparator);

  /**
   * Refresh the Listbox display. You can use that when you've made changes to the
   * underlying model classes. This just displays all currently visible elements.
   */
  void refresh();

  void addItemProcessor(@Nonnull ListBoxItemProcessor processor);
  
  /**
   * Get the Horizontal scrollbar of this listBox.
   * @return the Horizontal scrollbar 
   * @see de.lessvoid.nifty.controls.Scrollbar
   */
  Scrollbar getHorizontalScrollbar();
  
  /**
   * Get the Vertical scrollbar of this listBox.
   * @return the Vertical scrollbar
   * @see de.lessvoid.nifty.controls.Scrollbar
   */
  Scrollbar getVerticalScrollbar();
  
  /**
   * The ListBoxSelectionMode determines how the ListBox handles selections.
   *
   * @author void
   */
  public enum SelectionMode {
    /**
     * Allows only a single item to be selected.
     * This is the default selection mode.
     */
    Single,

    /**
     * Allows multiple items to be selected.
     */
    Multiple,

    /**
     * Does not allow any selection at all.
     */
    Disabled
  }

  /**
   * You'll need to implement this interface to change the way your model class T needs
   * to be displayed in the ListBox. If you omit it then Nifty will use its default
   * implementation which simply calls T.toString();
   *
   * @param <T>
   * @author void
   */
  public interface ListBoxViewConverter<T> {

    /**
     * Display the given item in the given element.
     *
     * @param listBoxItem the element to display the item in
     * @param item        the item to display
     */
    void display(@Nonnull Element listBoxItem, @Nonnull T item);

    /**
     * Return the width in pixel of the given item rendered for the given element.
     *
     * @param element the element to render
     * @param item    the item to render
     * @return the width of the element after the item has been applied to it
     */
    int getWidth(@Nonnull Element element, @Nonnull T item);
  }

  /**
   * A simple implementation of ListBoxViewConverter that will just use item.toString().
   * This is the default SimpleListBoxViewConverter used when you don't set a different implementation.
   *
   * @param <T>
   * @author void
   */
  public class ListBoxViewConverterSimple<T> implements ListBoxViewConverter<T> {
    private final Logger log = Logger.getLogger(ListBoxViewConverterSimple.class.getName());

    @Override
    public void display(@Nonnull final Element element, @Nonnull final T item) {
      TextRenderer renderer = element.getRenderer(TextRenderer.class);
      if (renderer == null) {
        log.warning(
            "you're using the ListBoxViewConverterSimple but there is no TextRenderer on the listBoxElement."
                + "You've probably changed the item template but did not provided your own "
                + "ListBoxViewConverter to the ListBox.");
        return;
      }
      renderer.setText(item.toString());
    }

    @Override
    public int getWidth(@Nonnull final Element element, @Nonnull final T item) {
      TextRenderer renderer = element.getRenderer(TextRenderer.class);
      if (renderer == null) {
        log.warning(
            "you're using the ListBoxViewConverterSimple but there is no TextRenderer on the listBoxElement."
                + "You've probably changed the item template but did not provided your own "
                + "ListBoxViewConverter to the ListBox.");
        return 0;
      }
      final RenderFont font = renderer.getFont();
      if (font != null) {
        final String resultText = element.getNifty().specialValuesReplace(item.toString());
        return font.getWidth(resultText);
      }
      return 0;
    }
  }
}
package de.lessvoid.nifty.render.image.renderstrategy;

import de.lessvoid.nifty.layout.Box;
import de.lessvoid.nifty.spi.render.RenderDevice;
import de.lessvoid.nifty.spi.render.RenderImage;
import de.lessvoid.nifty.tools.Color;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class RenderDirectlyStrategy implements RenderStrategy {

  @Override
  public void setParameters(@Nullable String parameters) {
    if (parameters != null) {
      throw new IllegalArgumentException("Trying to parse [" + this.getClass().getName()
          + "] : expected no parameters, found [" + parameters + "].");
    }
  }

  @Override
  public void render(
      @Nonnull final RenderDevice renderDevice,
      @Nonnull final RenderImage image,
      @Nonnull final Box sourceArea,
      final int x,
      final int y,
      final int width,
      final int height,
      @Nonnull final Color color,
      final float scale) {
    final int centerX = x + width / 2;
    final int centerY = y + height / 2;

    renderDevice.renderImage(
        image,
        sourceArea.getX() + x, sourceArea.getY() + y, sourceArea.getWidth(), sourceArea.getHeight(),
        sourceArea.getX(), sourceArea.getY(), sourceArea.getWidth(), sourceArea.getHeight(),
        color, scale, centerX, centerY);
  }
}
package de.lessvoid.nifty.sound.openal.slick;

import org.lwjgl.BufferUtils;
import org.lwjgl.openal.AL10;

import java.io.IOException;
import java.nio.IntBuffer;
import java.util.logging.Logger;

/**
 * A sound implementation wrapped round a player which reads (and potentially) rereads
 * a stream. This supplies streaming audio
 *
 * @author kevin
 * @author Nathan Sweet <misc@n4te.com>
 * @author Rockstar playAsMusic cleanup
 */
public class StreamSound extends AudioImpl {
  private final Logger log = Logger.getLogger(StreamSound.class.getName());
  /**
   * The player we're going to ask to stream data
   */
  private final OpenALStreamPlayer player;

  /**
   * Create a new sound wrapped round a stream
   *
   * @param player The stream player we'll use to access the stream
   */
  public StreamSound(OpenALStreamPlayer player) {
    this.player = player;
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#isPlaying()
   */
  @Override
  public boolean isPlaying() {
    return SoundStore.get().isPlaying(player);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#playAsMusic(float, float, boolean)
   */
  @Override
  public int playAsMusic(float pitch, float gain, boolean loop) {
    try {
      cleanUpSource();

      player.setup(pitch);
      player.play(loop);
      SoundStore.get().setStream(player);
    } catch (IOException e) {
      log.warning("Failed to read OGG source: " + player.getSource());
    }

    return SoundStore.get().getSource(0);
  }

  /**
   * Clean up the buffers applied to the sound source
   */
  private void cleanUpSource() {
    SoundStore store = SoundStore.get();

    AL10.alSourceStop(store.getSource(0));
    IntBuffer buffer = BufferUtils.createIntBuffer(1);
    int queued = AL10.alGetSourcei(store.getSource(0), AL10.AL_BUFFERS_QUEUED);

    while (queued > 0) {
      AL10.alSourceUnqueueBuffers(store.getSource(0), buffer);
      queued--;
    }

    AL10.alSourcei(store.getSource(0), AL10.AL_BUFFER, 0);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#playAsSoundEffect(float, float, boolean, float, float, float)
   */
  @Override
  public int playAsSoundEffect(float pitch, float gain, boolean loop, float x, float y, float z) {
    return playAsMusic(pitch, gain, loop);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#playAsSoundEffect(float, float, boolean)
   */
  @Override
  public int playAsSoundEffect(float pitch, float gain, boolean loop) {
    return playAsMusic(pitch, gain, loop);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#stop()
   */
  @Override
  public void stop() {
    SoundStore.get().setStream(null);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#setPosition(float)
   */
  @Override
  public boolean setPosition(float position) {
    return player.setPosition(position);
  }

  /**
   * @see org.newdawn.slick.openal.AudioImpl#getPosition()
   */
  @Override
  public float getPosition() {
    return player.getPosition();
  }
}
package de.lessvoid.nifty.loaderv2.types.apply;

import de.lessvoid.nifty.elements.Element;
import de.lessvoid.nifty.elements.render.ImageRenderer;
import de.lessvoid.nifty.elements.render.PanelRenderer;
import de.lessvoid.nifty.render.NiftyImage;
import de.lessvoid.nifty.render.NiftyRenderEngine;
import de.lessvoid.nifty.render.image.ImageMode;
import de.lessvoid.nifty.render.image.ImageModeHelper;
import de.lessvoid.nifty.screen.Screen;
import de.lessvoid.xml.xpp3.Attributes;

import javax.annotation.Nonnull;
import java.util.logging.Logger;

public class ApplyRendererPanel implements ApplyRenderer {
  private static final Logger log = Logger.getLogger(ApplyRendererPanel.class.getName());
  @Nonnull
  private final Convert convert;

  public ApplyRendererPanel(@Nonnull final Convert convertParam) {
    convert = convertParam;
  }

  @Override
  public void apply(
      @Nonnull final Screen screen,
      @Nonnull final Element element,
      @Nonnull final Attributes attributes,
      @Nonnull final NiftyRenderEngine renderEngine) {
    PanelRenderer panelRenderer = element.getRenderer(PanelRenderer.class);
    if (panelRenderer == null) {
      return;
    }
    panelRenderer.setBackgroundColor(convert.color(attributes.get("backgroundColor")));

    ImageRenderer imageRenderer = element.getRenderer(ImageRenderer.class);
    if (imageRenderer == null) {
      return;
    }

    String backgroundImage = attributes.get("backgroundImage");
    if (backgroundImage == null) {
      return;
    }

    NiftyImage image =
        renderEngine.createImage(
            screen,
            backgroundImage,
            attributes.getAsBoolean("filter", Convert.DEFAULT_IMAGE_FILTER));
    if (image == null) {
      return;
    }

    String areaProviderProperty = ImageModeHelper.getAreaProviderProperty(attributes.getAttributes());
    String renderStrategyProperty = ImageModeHelper.getRenderStrategyProperty(attributes.getAttributes());
    ImageMode imageMode = convert.imageMode(areaProviderProperty, renderStrategyProperty);

    image.setImageMode(imageMode);
    imageRenderer.setImage(image);
  }
}
<html>
<body>
	<p>Lorem:</p>
	<p>
		<font color="#B7D1FF">Lorem</font>
	</p>
	<img src="images/logo.png" width="200" height="3" align="left" />
	<img src="images/logo.png" width="200" height="3" align="left" />
	<img src="images/logo.png" width="200" height="3" align="left" />
	<p>Lorem: 0%</p>
	<p>Lorem: 20%</p>
	<img src="images/logo.png" width="200" height="3" align="left" />
	<img src="images/logo.png" width="200" height="3" align="left" />
	<img src="images/logo.png" width="200" height="3" align="left" />
	<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy</p>
</body>
</html>
<?php

/*
 * This file is part of the symfony package.
 * (c) Fabien Potencier <fabien.potencier@symfony-project.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * sfWidgetFormI18nChoiceCountry represents a country choice widget.
 *
 * @package    symfony
 * @subpackage widget
 * @author     Fabien Potencier <fabien.potencier@symfony-project.com>
 * @version    SVN: $Id: sfWidgetFormI18nChoiceCountry.class.php 23810 2009-11-12 11:07:44Z Kris.Wallsmith $
 */
class sfWidgetFormI18nChoiceCountry extends sfWidgetFormChoice
{
  /**
   * Constructor.
   *
   * Available options:
   *
   *  * culture:   The culture to use for internationalized strings
   *  * countries: An array of country codes to use (ISO 3166)
   *  * add_empty: Whether to add a first empty value or not (false by default)
   *               If the option is not a Boolean, the value will be used as the text value
   *
   * @param array $options     An array of options
   * @param array $attributes  An array of default HTML attributes
   *
   * @see sfWidgetFormChoice
   */
  protected function configure($options = array(), $attributes = array())
  {
    parent::configure($options, $attributes);

    $this->addOption('culture');
    $this->addOption('countries');
    $this->addOption('add_empty', false);

    // populate choices with all countries
    $culture = isset($options['culture']) ? $options['culture'] : 'en';

    $countries = sfCultureInfo::getInstance($culture)->getCountries(isset($options['countries']) ? $options['countries'] : null);

    $addEmpty = isset($options['add_empty']) ? $options['add_empty'] : false;
    if (false !== $addEmpty)
    {
      $countries = array_merge(array('' => true === $addEmpty ? '' : $addEmpty), $countries);
    }

    $this->setOption('choices', $countries);
  }
}
/*
 * Copyright 2010-2016, Tarantool AUTHORS, please see AUTHORS file.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 *    copyright notice, this list of conditions and the
 *    following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * <COPYRIGHT HOLDER> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "coeio_file.h"
#include "coeio.h"
#include "fiber.h"
#include "say.h"
#include <stdio.h>
#include <stdlib.h>


/**
 * A context of libeio request for any
 * coeio task.
 */
struct coeio_file_task {
	ssize_t result;
	int errorno;
	struct fiber *fiber;
	bool done;

	union {
		struct {
			int fd;
			struct stat *buf;
		} fstat;

		struct {
			struct stat *buf;
			const char *pathname;
		} lstat;

		struct {
			const char *pattern;
			int flags;
			int (*errfunc) (const char *epath, int eerrno);
			glob_t *pglob;
		} glob;

		struct {
			int fd;
			off_t offset;
			int whence;
		} lseek;

		struct {
			int fd;
			const void *buf;
			size_t count;
		} write;

		struct {
			int fd;
			void *buf;
			size_t count;
		} read;

		struct {
			const char *pathname;
			char *buf;
			size_t bufsize;
		} readlink;

		struct {
			char *tpl;
		} tempdir;
	};
};

#define INIT_COEIO_FILE(name)			\
	struct coeio_file_task name;		\
	memset(&name, 0, sizeof(name));		\
	name.fiber = fiber();			\

/** A callback invoked by eio when a task is complete. */
static int
coeio_complete(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;

	eio->errorno = req->errorno;
	eio->done = true;
	eio->result = req->result;

	fiber_wakeup(eio->fiber);
	return 0;
}

/**
 * Synchronously (from cooperative multitasking point of view)
 * wait for task completion.
 */
static ssize_t
coeio_wait_done(eio_req *req, struct coeio_file_task *eio)
{
	if (!req) {
		errno = ENOMEM;
		return -1;
	}

	while (!eio->done)
		fiber_yield();

	errno = eio->errorno;
	return eio->result;
}

int
coeio_open(const char *path, int flags, mode_t mode)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_open(path, flags, mode, 0,
				coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_close(int fd)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_close(fd, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

ssize_t
coeio_pwrite(int fd, const void *buf, size_t count, off_t offset)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_write(fd, (void *) buf, count, offset,
				 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

ssize_t
coeio_pread(int fd, void *buf, size_t count, off_t offset)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_read(fd, buf, count,
				offset, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_write(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = write(eio->write.fd, eio->write.buf, eio->write.count);
	eio->errorno = errno;
}

ssize_t
coeio_write(int fd, const void *buf, size_t count)
{
	INIT_COEIO_FILE(eio);
	eio.write.buf = buf;
	eio.write.count = count;
	eio.write.fd = fd;
	eio_req *req = eio_custom(coeio_do_write, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_read(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = read(eio->read.fd, eio->read.buf, eio->read.count);
	req->errorno = errno;
}

ssize_t
coeio_read(int fd, void *buf, size_t count)
{
	INIT_COEIO_FILE(eio);
	eio.read.buf = buf;
	eio.read.count = count;
	eio.read.fd = fd;
	eio_req *req = eio_custom(coeio_do_read, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}


static void
coeio_do_lseek(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result =
		lseek(eio->lseek.fd, eio->lseek.offset, eio->lseek.whence);
	req->errorno = errno;
}

off_t
coeio_lseek(int fd, off_t offset, int whence)
{
	INIT_COEIO_FILE(eio);

	eio.lseek.whence = whence;
	eio.lseek.offset = offset;
	eio.lseek.fd = fd;

	eio_req *req = eio_custom(coeio_do_lseek, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_lstat(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = lstat(eio->lstat.pathname, eio->lstat.buf);
	req->errorno = errno;
}

int
coeio_lstat(const char *pathname, struct stat *buf)
{
	INIT_COEIO_FILE(eio);
	eio.lstat.pathname = pathname;
	eio.lstat.buf = buf;
	eio_req *req = eio_custom(coeio_do_lstat, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_stat(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = stat(eio->lstat.pathname, eio->lstat.buf);
	req->errorno = errno;
}

int
coeio_stat(const char *pathname, struct stat *buf)
{
	INIT_COEIO_FILE(eio);
	eio.lstat.pathname = pathname;
	eio.lstat.buf = buf;
	eio_req *req = eio_custom(coeio_do_stat, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_fstat(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = fstat(eio->fstat.fd, eio->fstat.buf);
	req->errorno = errno;
}

int
coeio_fstat(int fd, struct stat *stat)
{
	INIT_COEIO_FILE(eio);
	eio.fstat.fd = fd;
	eio.fstat.buf = stat;

	eio_req *req = eio_custom(coeio_do_fstat, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_rename(const char *oldpath, const char *newpath)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_rename(oldpath, newpath, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);

}

int
coeio_unlink(const char *pathname)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_unlink(pathname, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_ftruncate(int fd, off_t length)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_ftruncate(fd, length, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_truncate(const char *path, off_t length)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_truncate(path, length, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_glob(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = glob(eio->glob.pattern,
			   eio->glob.flags, eio->glob.errfunc, eio->glob.pglob);
	req->errorno = errno;
}

int
coeio_glob(const char *pattern, int flags,
		int (*errfunc) (const char *epath, int eerrno),
		glob_t *pglob)
{
	INIT_COEIO_FILE(eio);
	eio.glob.pattern = pattern;
	eio.glob.flags = flags;
	eio.glob.errfunc = errfunc;
	eio.glob.pglob = pglob;
	eio_req *req =
		eio_custom(coeio_do_glob, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_chown(const char *path, uid_t owner, gid_t group)
{
	INIT_COEIO_FILE(eio);
	eio_req *req =
		eio_chown(path, owner, group, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_chmod(const char *path, mode_t mode)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_chmod(path, mode, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_mkdir(const char *pathname, mode_t mode)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_mkdir(pathname, mode, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_rmdir(const char *pathname)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_rmdir(pathname, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_link(const char *oldpath, const char *newpath)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_link(oldpath, newpath, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_symlink(const char *target, const char *linkpath)
{
	INIT_COEIO_FILE(eio);
	eio_req *req =
		eio_symlink(target, linkpath, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_readlink(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	req->result = readlink(eio->readlink.pathname,
			       eio->readlink.buf, eio->readlink.bufsize);
	req->errorno = errno;
}

int
coeio_readlink(const char *pathname, char *buf, size_t bufsize)
{
	INIT_COEIO_FILE(eio);
	eio.readlink.pathname = pathname;
	eio.readlink.buf = buf;
	eio.readlink.bufsize = bufsize;
	eio_req *req = eio_custom(coeio_do_readlink, 0,
				  coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

static void
coeio_do_tempdir(eio_req *req)
{
	struct coeio_file_task *eio = (struct coeio_file_task *)req->data;
	char *res = mkdtemp(eio->tempdir.tpl);
	req->errorno = errno;
	if (res == NULL) {
		req->result = -1;
	} else {
		req->result = 0;
	}
}

int
coeio_tempdir(char *path, size_t path_len)
{
	INIT_COEIO_FILE(eio);

	if (path_len < sizeof("/tmp/XXXXXX") + 1) {
		errno = ENOMEM;
		return -1;
	}

	snprintf(path, path_len, "/tmp/XXXXXX");

	eio.tempdir.tpl = path;
	eio_req *req =
		eio_custom(coeio_do_tempdir, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_sync()
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_sync(0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_fsync(int fd)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_fsync(fd, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}

int
coeio_fdatasync(int fd)
{
	INIT_COEIO_FILE(eio);
	eio_req *req = eio_fdatasync(fd, 0, coeio_complete, &eio);
	return coeio_wait_done(req, &eio);
}
package wurmcraft.wurmatron.common.utils.mekanism;

import mekanism.api.gas.Gas;
import mekanism.api.gas.GasRegistry;
import wurmcraft.wurmatron.common.fluid.WurmTweaksFluid;

public class MekanismRegistry {

		public static Gas copper;
		public static Gas gold;
		public static Gas platinum;
		public static Gas iron;
		public static Gas bismuth;
		public static Gas zinc;
		public static Gas nickel;
		public static Gas tin;
		public static Gas silver;
		public static Gas lead;

		public static Gas copperPure;
		public static Gas goldPure;
		public static Gas platinumPure;
		public static Gas ironPure;
		public static Gas bismuthPure;
		public static Gas zincPure;
		public static Gas nickelPure;
		public static Gas tinPure;
		public static Gas silverPure;
		public static Gas leadPure;

		public static void addGases () {
				copper = new Gas(WurmTweaksFluid.fluidCopper);
				gold = new Gas(WurmTweaksFluid.fluidGold);
				platinum = new Gas(WurmTweaksFluid.fluidPlatinum);
				iron = new Gas(WurmTweaksFluid.fluidWroughtIron);
				bismuth = new Gas(WurmTweaksFluid.fluidBismuth);
				zinc = new Gas(WurmTweaksFluid.fluidZinc);
				nickel = new Gas(WurmTweaksFluid.fluidNickel);
				tin = new Gas(WurmTweaksFluid.fluidTin);
				silver = new Gas(WurmTweaksFluid.fluidSilver);
				lead = new Gas(WurmTweaksFluid.fluidLead);
				copperPure = new Gas(WurmTweaksFluid.pureFluidCopper);
				goldPure = new Gas(WurmTweaksFluid.pureFluidGold);
				platinumPure = new Gas(WurmTweaksFluid.pureFluidPlatinum);
				ironPure = new Gas(WurmTweaksFluid.pureFluidWroughtIron);
				bismuthPure = new Gas(WurmTweaksFluid.pureFluidBismuth);
				zincPure = new Gas(WurmTweaksFluid.pureFluidZinc);
				nickelPure = new Gas(WurmTweaksFluid.pureFluidNickel);
				tinPure = new Gas(WurmTweaksFluid.pureFluidTin);
				silverPure = new Gas(WurmTweaksFluid.pureFluidSilver);
				leadPure = new Gas(WurmTweaksFluid.pureFluidLead);
				GasRegistry.register(copper);
				GasRegistry.register(gold);
				GasRegistry.register(platinum);
				GasRegistry.register(iron);
				GasRegistry.register(bismuth);
				GasRegistry.register(zinc);
				GasRegistry.register(nickel);
				GasRegistry.register(tin);
				GasRegistry.register(silver);
				GasRegistry.register(lead);
				GasRegistry.register(copperPure);
				GasRegistry.register(goldPure);
				GasRegistry.register(platinumPure);
				GasRegistry.register(ironPure);
				GasRegistry.register(bismuthPure);
				GasRegistry.register(zincPure);
				GasRegistry.register(nickelPure);
				GasRegistry.register(tinPure);
				GasRegistry.register(silverPure);
				GasRegistry.register(leadPure);
		}
}
iterate = dofile('utils.lua').iterate
---
...
test_run = require('test_run').new()
---
...
test_run:cmd("push filter '(error: .builtin/.*[.]lua):[0-9]+' to '\\1'")
---
- true
...
# Tree single-part unique
---
...
space = box.schema.space.create('tweedledum')
---
...
idx1 = space:create_index('primary', { type = 'tree', parts = {1, 'str'}, unique = true})
---
...
-- Tree single-part non-unique
idx2 = space:create_index('i1', { type = 'tree', parts = {2, 'str'}, unique = false})
---
...
-- Tree multi-part unique
idx3 = space:create_index('i2', { type = 'tree', parts = {2, 'str', 3, 'str'}, unique = true})
---
...
-- Tree multi-part non-unique
idx4 = space:create_index('i3', { type = 'tree', parts = {3, 'str', 4, 'str'}, unique = false })
---
...
-- Hash single-part unique
idx5 = space:create_index('i4', { type = 'hash', parts = {1, 'str'}, unique = true})
---
...
-- Hash multi-part unique
idx6 = space:create_index('i5', { type = 'hash', parts = {2, 'str', 3, 'str'}, unique = true})
---
...
space:insert{'pid_001', 'sid_001', 'tid_998', 'a'}
---
- ['pid_001', 'sid_001', 'tid_998', 'a']
...
space:insert{'pid_002', 'sid_001', 'tid_997', 'a'}
---
- ['pid_002', 'sid_001', 'tid_997', 'a']
...
space:insert{'pid_003', 'sid_002', 'tid_997', 'b'}
---
- ['pid_003', 'sid_002', 'tid_997', 'b']
...
space:insert{'pid_005', 'sid_002', 'tid_996', 'b'}
---
- ['pid_005', 'sid_002', 'tid_996', 'b']
...
space:insert{'pid_007', 'sid_003', 'tid_996', 'a'}
---
- ['pid_007', 'sid_003', 'tid_996', 'a']
...
space:insert{'pid_011', 'sid_004', 'tid_996', 'c'}
---
- ['pid_011', 'sid_004', 'tid_996', 'c']
...
space:insert{'pid_013', 'sid_005', 'tid_996', 'b'}
---
- ['pid_013', 'sid_005', 'tid_996', 'b']
...
space:insert{'pid_017', 'sid_006', 'tid_996', 'a'}
---
- ['pid_017', 'sid_006', 'tid_996', 'a']
...
space:insert{'pid_019', 'sid_005', 'tid_995', 'a'}
---
- ['pid_019', 'sid_005', 'tid_995', 'a']
...
space:insert{'pid_023', 'sid_005', 'tid_994', 'a'}
---
- ['pid_023', 'sid_005', 'tid_994', 'a']
...
-------------------------------------------------------------------------------
-- Iterator: tree single-part unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'primary', 0, 1)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.ALL)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.EQ)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.REQ)
---
- - $pid_023$
  - $pid_019$
  - $pid_017$
  - $pid_013$
  - $pid_011$
  - $pid_007$
  - $pid_005$
  - $pid_003$
  - $pid_002$
  - $pid_001$
...
iterate('tweedledum', 'primary', 0, 1, box.index.GE)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.GT)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.LE)
---
- - $pid_023$
  - $pid_019$
  - $pid_017$
  - $pid_013$
  - $pid_011$
  - $pid_007$
  - $pid_005$
  - $pid_003$
  - $pid_002$
  - $pid_001$
...
iterate('tweedledum', 'primary', 0, 1, box.index.LT)
---
- - $pid_023$
  - $pid_019$
  - $pid_017$
  - $pid_013$
  - $pid_011$
  - $pid_007$
  - $pid_005$
  - $pid_003$
  - $pid_002$
  - $pid_001$
...
iterate('tweedledum', 'primary', 0, 1, box.index.EQ, 'pid_003')
---
- - $pid_003$
...
iterate('tweedledum', 'primary', 0, 1, box.index.REQ, 'pid_003')
---
- - $pid_003$
...
iterate('tweedledum', 'primary', 0, 1, box.index.EQ, 'pid_666')
---
- []
...
iterate('tweedledum', 'primary', 0, 1, box.index.REQ, 'pid_666')
---
- []
...
iterate('tweedledum', 'primary', 0, 1, box.index.GE, 'pid_001')
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.GT, 'pid_001')
---
- - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'primary', 0, 1, box.index.GE, 'pid_999')
---
- []
...
iterate('tweedledum', 'primary', 0, 1, box.index.GT, 'pid_999')
---
- []
...
iterate('tweedledum', 'primary', 0, 1, box.index.LE, 'pid_002')
---
- - $pid_002$
  - $pid_001$
...
iterate('tweedledum', 'primary', 0, 1, box.index.LT, 'pid_002')
---
- - $pid_001$
...
iterate('tweedledum', 'primary', 0, 1, box.index.LE, 'pid_000')
---
- []
...
iterate('tweedledum', 'primary', 0, 1, box.index.LT, 'pid_000')
---
- []
...
-------------------------------------------------------------------------------
-- Iterator: tree single-part non-unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'i1', 1, 2, box.index.ALL)
---
- - $sid_001$
  - $sid_001$
  - $sid_002$
  - $sid_002$
  - $sid_003$
  - $sid_004$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.EQ)
---
- - $sid_001$
  - $sid_001$
  - $sid_002$
  - $sid_002$
  - $sid_003$
  - $sid_004$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.REQ)
---
- - $sid_006$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_004$
  - $sid_003$
  - $sid_002$
  - $sid_002$
  - $sid_001$
  - $sid_001$
...
iterate('tweedledum', 'i1', 1, 2, box.index.GE)
---
- - $sid_001$
  - $sid_001$
  - $sid_002$
  - $sid_002$
  - $sid_003$
  - $sid_004$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.GT)
---
- - $sid_001$
  - $sid_001$
  - $sid_002$
  - $sid_002$
  - $sid_003$
  - $sid_004$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.LE)
---
- - $sid_006$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_004$
  - $sid_003$
  - $sid_002$
  - $sid_002$
  - $sid_001$
  - $sid_001$
...
iterate('tweedledum', 'i1', 1, 2, box.index.LT)
---
- - $sid_006$
  - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_004$
  - $sid_003$
  - $sid_002$
  - $sid_002$
  - $sid_001$
  - $sid_001$
...
iterate('tweedledum', 'i1', 1, 2, box.index.EQ, 'sid_005')
---
- - $sid_005$
  - $sid_005$
  - $sid_005$
...
iterate('tweedledum', 'i1', 1, 2, box.index.REQ, 'sid_005')
---
- - $sid_005$
  - $sid_005$
  - $sid_005$
...
iterate('tweedledum', 'i1', 1, 2, box.index.GE, 'sid_005')
---
- - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.GT, 'sid_005')
---
- - $sid_006$
...
iterate('tweedledum', 'i1', 1, 2, box.index.GE, 'sid_999')
---
- []
...
iterate('tweedledum', 'i1', 1, 2, box.index.GT, 'sid_999')
---
- []
...
iterate('tweedledum', 'i1', 1, 2, box.index.LE, 'sid_005')
---
- - $sid_005$
  - $sid_005$
  - $sid_005$
  - $sid_004$
  - $sid_003$
  - $sid_002$
  - $sid_002$
  - $sid_001$
  - $sid_001$
...
iterate('tweedledum', 'i1', 1, 2, box.index.LT, 'sid_005')
---
- - $sid_004$
  - $sid_003$
  - $sid_002$
  - $sid_002$
  - $sid_001$
  - $sid_001$
...
iterate('tweedledum', 'i1', 1, 2, box.index.LE, 'sid_000')
---
- []
...
iterate('tweedledum', 'i1', 1, 2, box.index.LT, 'sid_000')
---
- []
...
-------------------------------------------------------------------------------
-- Iterator: tree multi-part unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'i2', 1, 3, box.index.ALL)
---
- - $sid_001$tid_997$
  - $sid_001$tid_998$
  - $sid_002$tid_996$
  - $sid_002$tid_997$
  - $sid_003$tid_996$
  - $sid_004$tid_996$
  - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.EQ)
---
- - $sid_001$tid_997$
  - $sid_001$tid_998$
  - $sid_002$tid_996$
  - $sid_002$tid_997$
  - $sid_003$tid_996$
  - $sid_004$tid_996$
  - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.REQ)
---
- - $sid_006$tid_996$
  - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GE)
---
- - $sid_001$tid_997$
  - $sid_001$tid_998$
  - $sid_002$tid_996$
  - $sid_002$tid_997$
  - $sid_003$tid_996$
  - $sid_004$tid_996$
  - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GT)
---
- - $sid_001$tid_997$
  - $sid_001$tid_998$
  - $sid_002$tid_996$
  - $sid_002$tid_997$
  - $sid_003$tid_996$
  - $sid_004$tid_996$
  - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LE)
---
- - $sid_006$tid_996$
  - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LT)
---
- - $sid_006$tid_996$
  - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.EQ, 'sid_005')
---
- - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.EQ, 'sid_005', 'tid_995')
---
- - $sid_005$tid_995$
...
iterate('tweedledum', 'i2', 1, 3, box.index.EQ, 'sid_005', 'tid_999')
---
- []
...
iterate('tweedledum', 'i2', 1, 3, box.index.REQ, 'sid_005')
---
- - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
...
iterate('tweedledum', 'i2', 1, 3, box.index.REQ, 'sid_005', 'tid_995')
---
- - $sid_005$tid_995$
...
iterate('tweedledum', 'i2', 1, 3, box.index.REQ, 'sid_005', 'tid_999')
---
- []
...
iterate('tweedledum', 'i2', 1, 3, box.index.GE, 'sid_005')
---
- - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GT, 'sid_005')
---
- - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GE, 'sid_005', 'tid_995')
---
- - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GT, 'sid_005', 'tid_995')
---
- - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GE, 'sid_005', 'tid_999')
---
- - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GT, 'sid_005', 'tid_999')
---
- - $sid_006$tid_996$
...
iterate('tweedledum', 'i2', 1, 3, box.index.GE, 'sid_999')
---
- []
...
iterate('tweedledum', 'i2', 1, 3, box.index.GT, 'sid_999')
---
- []
...
iterate('tweedledum', 'i2', 1, 3, box.index.LE, 'sid_005')
---
- - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LT, 'sid_005')
---
- - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LE, 'sid_005', 'tid_997')
---
- - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LT, 'sid_005', 'tid_997')
---
- - $sid_005$tid_996$
  - $sid_005$tid_995$
  - $sid_005$tid_994$
  - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LE, 'sid_005', 'tid_000')
---
- - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LT, 'sid_005', 'tid_000')
---
- - $sid_004$tid_996$
  - $sid_003$tid_996$
  - $sid_002$tid_997$
  - $sid_002$tid_996$
  - $sid_001$tid_998$
  - $sid_001$tid_997$
...
iterate('tweedledum', 'i2', 1, 3, box.index.LE, 'sid_000')
---
- []
...
iterate('tweedledum', 'i2', 1, 3, box.index.LT, 'sid_000')
---
- []
...
-------------------------------------------------------------------------------
-- Iterator: tree multi-part non-unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'i3', 2, 4, box.index.ALL)
---
- - $tid_994$a$
  - $tid_995$a$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$c$
  - $tid_997$a$
  - $tid_997$b$
  - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.EQ)
---
- - $tid_994$a$
  - $tid_995$a$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$c$
  - $tid_997$a$
  - $tid_997$b$
  - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.REQ)
---
- - $tid_998$a$
  - $tid_997$b$
  - $tid_997$a$
  - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_995$a$
  - $tid_994$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.GE)
---
- - $tid_994$a$
  - $tid_995$a$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$c$
  - $tid_997$a$
  - $tid_997$b$
  - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.GT)
---
- - $tid_994$a$
  - $tid_995$a$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$c$
  - $tid_997$a$
  - $tid_997$b$
  - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.LE)
---
- - $tid_998$a$
  - $tid_997$b$
  - $tid_997$a$
  - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_995$a$
  - $tid_994$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.LT)
---
- - $tid_998$a$
  - $tid_997$b$
  - $tid_997$a$
  - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_995$a$
  - $tid_994$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.EQ, 'tid_996')
---
- - $tid_996$a$
  - $tid_996$a$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$c$
...
iterate('tweedledum', 'i3', 2, 4, box.index.EQ, 'tid_996', 'a')
---
- - $tid_996$a$
  - $tid_996$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.EQ, 'tid_996', 'z')
---
- []
...
iterate('tweedledum', 'i3', 2, 4, box.index.REQ, 'tid_996')
---
- - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.REQ, 'tid_996', 'a')
---
- - $tid_996$a$
  - $tid_996$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.REQ, 'tid_996', '0')
---
- []
...
iterate('tweedledum', 'i3', 2, 4, box.index.GE, 'tid_997')
---
- - $tid_997$a$
  - $tid_997$b$
  - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.GT, 'tid_997')
---
- - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.GE, 'tid_998')
---
- - $tid_998$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.GT, 'tid_998')
---
- []
...
iterate('tweedledum', 'i3', 2, 4, box.index.LE, 'tid_997')
---
- - $tid_997$b$
  - $tid_997$a$
  - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_995$a$
  - $tid_994$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.LT, 'tid_997')
---
- - $tid_996$c$
  - $tid_996$b$
  - $tid_996$b$
  - $tid_996$a$
  - $tid_996$a$
  - $tid_995$a$
  - $tid_994$a$
...
iterate('tweedledum', 'i3', 2, 4, box.index.LE, 'tid_000')
---
- []
...
iterate('tweedledum', 'i3', 2, 4, box.index.LT, 'tid_000')
---
- []
...
iterate('tweedledum', 'i3', 2, 4, box.index.LT, 'tid_996', 'to', 'many', 'keys')
---
- error: Invalid key part count (expected [0..2], got 4)
...
-------------------------------------------------------------------------------
-- Iterator: hash single-part unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'i4', 0, 1)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'i4', 0, 1, box.index.ALL)
---
- - $pid_001$
  - $pid_002$
  - $pid_003$
  - $pid_005$
  - $pid_007$
  - $pid_011$
  - $pid_013$
  - $pid_017$
  - $pid_019$
  - $pid_023$
...
iterate('tweedledum', 'i4', 0, 1, box.index.EQ)
---
- error: Invalid key part count in an exact match (expected 1, got 0)
...
iterate('tweedledum', 'i4', 0, 1, box.index.EQ, 'pid_003')
---
- - $pid_003$
...
iterate('tweedledum', 'i4', 0, 1, box.index.EQ, 'pid_666')
---
- []
...
-------------------------------------------------------------------------------
-- Iterator: hash multi-part unique
-------------------------------------------------------------------------------
iterate('tweedledum', 'i5', 1, 3, box.index.ALL)
---
- - $sid_001$tid_997$
  - $sid_001$tid_998$
  - $sid_002$tid_996$
  - $sid_002$tid_997$
  - $sid_003$tid_996$
  - $sid_004$tid_996$
  - $sid_005$tid_994$
  - $sid_005$tid_995$
  - $sid_005$tid_996$
  - $sid_006$tid_996$
...
iterate('tweedledum', 'i5', 1, 3, box.index.EQ, 'sid_005')
---
- error: Invalid key part count in an exact match (expected 2, got 1)
...
iterate('tweedledum', 'i5', 1, 3, box.index.EQ, 'sid_005', 'tid_995')
---
- - $sid_005$tid_995$
...
iterate('tweedledum', 'i5', 1, 3, box.index.EQ, 'sid_005', 'tid_999')
---
- []
...
iterate('tweedledum', 'i5', 1, 3, box.index.EQ, 'sid_005', 'tid_995', 'a')
---
- error: Invalid key part count (expected [0..2], got 3)
...
-------------------------------------------------------------------------------
-- Iterator: various
-------------------------------------------------------------------------------
space.index['primary']:pairs({}, {iterator = -666 })
---
- error: Index 'primary' (TREE) of space 'tweedledum' (memtx) does not support requested
    iterator type
...
-- Test cases for #123: box.index.count does not check arguments properly
space.index['primary']:pairs(function() end, { iterator = box.index.EQ })
---
- error: 'builtin/msgpackffi.lua: can not encode Lua type: ''function'''
...
-- Check that iterators successfully invalidated when index deleted
gen, param, state = space.index['i1']:pairs(nil, { iterator = box.index.GE })
---
...
index_space = box.space[box.schema.INDEX_ID]
---
...
_ = index_space:delete{space.id, space.index['i1'].id}
---
...
type(_)
---
- cdata
...
gen(param, state)
---
- null
...
space:drop()
---
...
-------------------------------------------------------------------------------
-- Iterator: https://github.com/tarantool/tarantool/issues/464
-- Iterator safety after changing schema
-------------------------------------------------------------------------------
space = box.schema.space.create('test', {temporary=true})
---
...
idx1 = space:create_index('primary', {type='HASH',unique=true})
---
...
idx2 = space:create_index('t1', {type='TREE',unique=true})
---
...
idx3 = space:create_index('t2', {type='TREE',unique=true})
---
...
box.space.test:insert{0}
---
- [0]
...
box.space.test:insert{1}
---
- [1]
...
gen1, param1, state1 = space.index.t1:pairs({}, {iterator = box.index.ALL})
---
...
gen1(param1, state1)
---
- <iterator state>
- [0]
...
gen2, param2, state2 = space.index.t2:pairs({}, {iterator = box.index.ALL})
---
...
gen2(param2, state2)
---
- <iterator state>
- [0]
...
id = space.index.t1.id
---
...
box.schema.index.drop(space.id, id)
---
...
gen1(param1, state1)
---
- null
...
gen2(param2, state2)
---
- <iterator state>
- [1]
...
gen2, param2, state2 = space.index.t2:pairs({}, {iterator = box.index.ALL})
---
...
gen2(param2, state2)
---
- <iterator state>
- [0]
...
gen2(param2, state2)
---
- <iterator state>
- [1]
...
space:drop()
---
...
-------------------------------------------------------------------------------
-- Iterator: https://github.com/tarantool/tarantool/issues/498
-- Iterator is not checked for wrong type; accept lowercase iterator
-------------------------------------------------------------------------------
space = box.schema.space.create('test', {temporary=true})
---
...
idx1 = space:create_index('primary', {type='TREE',unique=true})
---
...
space:insert{0}
---
- [0]
...
space:insert{1}
---
- [1]
...
gen, param, state = space.index.primary:pairs({}, {iterator = 'ALL'})
---
...
gen(param, state)
---
- <iterator state>
- [0]
...
gen(param, state)
---
- <iterator state>
- [1]
...
gen(param, state)
---
- null
...
gen, param, state = space.index.primary:pairs({}, {iterator = 'all'})
---
...
gen(param, state)
---
- <iterator state>
- [0]
...
gen(param, state)
---
- <iterator state>
- [1]
...
gen, param, state = space.index.primary:pairs({}, {iterator = 'mistake'})
---
- error: Unknown iterator type 'mistake'
...
space:select({}, {iterator = box.index.ALL})
---
- - [0]
  - [1]
...
space:select({}, {iterator = 'all'})
---
- - [0]
  - [1]
...
space:select({}, {iterator = 'mistake'})
---
- error: Unknown iterator type 'mistake'
...
space:drop()
---
...
-------------------------------------------------------------------------------
--  Restore GE iterator for HASH https://github.com/tarantool/tarantool/issues/836
-------------------------------------------------------------------------------
space = box.schema.space.create('test', {temporary=true})
---
...
idx1 = space:create_index('primary', {type='hash',unique=true})
---
...
for i = 0,5 do space:insert{i} end
---
...
space:select(2)
---
- - [2]
...
space:select(5, {iterator="GE"})
---
- error: Index 'primary' (HASH) of space 'test' (memtx) does not support requested
    iterator type
...
space:select(nil, {iterator="GE"})
---
- error: Invalid key part count in an exact match (expected 1, got 0)
...
space:select(5, {iterator="GT"})
---
- []
...
l = space:select(nil, {limit=2, iterator="GT"})
---
...
l
---
- - [0]
  - [1]
...
l = space:select(l[#l][1], {limit=2, iterator="GT"})
---
...
l
---
- - [2]
  - [3]
...
l = space:select(l[#l][1], {limit=2, iterator="GT"})
---
...
l
---
- - [4]
  - [5]
...
l = space:select(l[#l][1], {limit=2, iterator="GT"})
---
...
l
---
- []
...
space:drop()
---
...
iterate = nil
---
...
package tb.common.inventory;

import java.util.Iterator;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

import DummyCore.Utils.BlockStateMetadata;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.InventoryPlayer;
import net.minecraft.init.Items;
import net.minecraft.inventory.ContainerRepair;
import net.minecraft.inventory.ICrafting;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.InventoryBasic;
import net.minecraft.inventory.InventoryCraftResult;
import net.minecraft.inventory.Slot;
import net.minecraft.item.ItemStack;
import net.minecraft.util.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.common.ForgeHooks;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import tb.init.TBBlocks;

public class ContainerThaumicAnvil extends ContainerRepair{

	private IInventory outputSlot = new InventoryCraftResult();
    IInventory inputSlots = new InventoryBasic("Repair", true, 2)
    {
        public void markDirty()
        {
            super.markDirty();
            ContainerThaumicAnvil.this.onCraftMatrixChanged(this);
        }
    };
    private String repairedItemName;
    private final EntityPlayer thePlayer;
    private World w;
    private int x;
    private int y;
    private int z;
    
	public ContainerThaumicAnvil(InventoryPlayer inv, final World w, final BlockPos pos, EntityPlayer p)
	{
		super(inv, w, pos, p);
		thePlayer = p;
		
		this.crafters.clear();
		this.inventoryItemStacks.clear();
		this.inventorySlots.clear();
		
		this.w = w;
		this.x = pos.getX();
		this.y = pos.getY();
		this.z = pos.getZ();
		
		final World fw = w;
		final int fx = x;
		final int fy = y;
		final int fz = z;
		
        this.addSlotToContainer(new Slot(this.inputSlots, 0, 27, 47));
        this.addSlotToContainer(new Slot(this.inputSlots, 1, 76, 47));
        this.addSlotToContainer(new Slot(this.outputSlot, 2, 134, 47)
        {
            public boolean isItemValid(ItemStack stk)
            {
                return false;
            }
            
            public boolean canTakeStack(EntityPlayer p_82869_1_)
            {
                return (p_82869_1_.capabilities.isCreativeMode || p_82869_1_.experienceLevel >= ContainerThaumicAnvil.this.maximumCost) && ContainerThaumicAnvil.this.maximumCost > 0 && this.getHasStack();
            }
            public void onPickupFromSlot(EntityPlayer p_82870_1_, ItemStack p_82870_2_)
            {
                if (!p_82870_1_.capabilities.isCreativeMode)
                {
                    p_82870_1_.addExperienceLevel(-ContainerThaumicAnvil.this.maximumCost);
                }

                float breakChance = ForgeHooks.onAnvilRepair(p_82870_1_, p_82870_2_, ContainerThaumicAnvil.this.inputSlots.getStackInSlot(0), ContainerThaumicAnvil.this.inputSlots.getStackInSlot(1))/3;

                ContainerThaumicAnvil.this.inputSlots.setInventorySlotContents(0, (ItemStack)null);

                if (ContainerThaumicAnvil.this.materialCost > 0)
                {
                    ItemStack itemstack1 = ContainerThaumicAnvil.this.inputSlots.getStackInSlot(1);

                    if (itemstack1 != null && itemstack1.stackSize > ContainerThaumicAnvil.this.materialCost)
                    {
                        itemstack1.stackSize -= ContainerThaumicAnvil.this.materialCost;
                        ContainerThaumicAnvil.this.inputSlots.setInventorySlotContents(1, itemstack1);
                    }
                    else
                    {
                    	ContainerThaumicAnvil.this.inputSlots.setInventorySlotContents(1, (ItemStack)null);
                    }
                }
                else
                {
                	ContainerThaumicAnvil.this.inputSlots.setInventorySlotContents(1, (ItemStack)null);
                }

                ContainerThaumicAnvil.this.maximumCost = 0;

                if (!p_82870_1_.capabilities.isCreativeMode && !fw.isRemote && fw.getBlockState(new BlockPos(fx, fy, fz)).getBlock() == TBBlocks.thaumicAnvil && p_82870_1_.getRNG().nextFloat() < breakChance)
                {
                    int i1 = BlockStateMetadata.getBlockMetadata(fw, fx, fy, fz);
                    int l = i1 % 3;
                    ++l;

                    if (l > 2)
                    {
                        fw.setBlockToAir(new BlockPos(fx,fy,fz));
                        fw.playAuxSFX(1020, new BlockPos(fx,fy,fz), 0);
                    }
                    else
                    {
                        fw.setBlockState(new BlockPos(fx,fy,fz), fw.getBlockState(new BlockPos(fx, fy, fz)).getBlock().getStateFromMeta(i1-1));
                        fw.playAuxSFX(1021, new BlockPos(fx,fy,fz), 0);
                    }
                }
                else if (!fw.isRemote)
                {
                	fw.playAuxSFX(1021, new BlockPos(fx,fy,fz), 0);
                }
            }
        });
        
        int i;

        for (i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 9; ++j)
            {
                this.addSlotToContainer(new Slot(inv, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
            }
        }

        for (i = 0; i < 9; ++i)
        {
            this.addSlotToContainer(new Slot(inv, i, 8 + i * 18, 142));
        }
	}
	
    public void onCraftMatrixChanged(IInventory p_75130_1_)
    {
        super.onCraftMatrixChanged(p_75130_1_);

        if (p_75130_1_ == this.inputSlots)
        {
            this.updateRepairOutput();
        }
    }
    
    @SuppressWarnings({ "unchecked", "rawtypes" })
	public void updateRepairOutput()
    {
        ItemStack itemstack = this.inputSlots.getStackInSlot(0);
        this.maximumCost = 0;
        int i = 0;
        byte b0 = 0;
        int j = 0;

        if (itemstack == null)
        {
            this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
            this.maximumCost = 0;
        }
        else
        {
            ItemStack itemstack1 = itemstack.copy();
            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);
            Map map = EnchantmentHelper.getEnchantments(itemstack1);
            boolean flag = false;
            int k2 = b0 + itemstack.getRepairCost() + (itemstack2 == null ? 0 : itemstack2.getRepairCost());
            this.materialCost = 0;
            int k;
            int l;
            int i1;
            int k1;
            int l1;
            Iterator iterator1;
            Enchantment enchantment;

            if (itemstack2 != null)
            {
                if (!ForgeHooks.onAnvilChange(this, itemstack, itemstack2, outputSlot, repairedItemName, k2)) return;
                flag = itemstack2.getItem() == Items.enchanted_book && Items.enchanted_book.getEnchantments(itemstack2).tagCount() > 0;

                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2))
                {
                    k = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);

                    if (k <= 0)
                    {
                        this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
                        this.maximumCost = 0;
                        return;
                    }

                    for (l = 0; k > 0 && l < itemstack2.stackSize; ++l)
                    {
                        i1 = itemstack1.getItemDamage() - k;
                        itemstack1.setItemDamage(i1);
                        i += Math.max(1, k / 100) + map.size();
                        k = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
                    }

                    this.materialCost = l;
                }
                else
                {
                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable()))
                    {
                        this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
                        this.maximumCost = 0;
                        return;
                    }

                    if (itemstack1.isItemStackDamageable() && !flag)
                    {
                        k = itemstack.getMaxDamage() - itemstack.getItemDamage();
                        l = itemstack2.getMaxDamage() - itemstack2.getItemDamage();
                        i1 = l + itemstack1.getMaxDamage() * 12 / 100;
                        int j1 = k + i1;
                        k1 = itemstack1.getMaxDamage() - j1;

                        if (k1 < 0)
                        {
                            k1 = 0;
                        }

                        if (k1 < itemstack1.getItemDamage())
                        {
                            itemstack1.setItemDamage(k1);
                            i += Math.max(1, i1 / 100);
                        }
                    }

                    Map map1 = EnchantmentHelper.getEnchantments(itemstack2);
                    iterator1 = map1.keySet().iterator();

                    while (iterator1.hasNext())
                    {
                        i1 = ((Integer)iterator1.next()).intValue();
                        enchantment = Enchantment.getEnchantmentById(i1);
                        k1 = map.containsKey(Integer.valueOf(i1)) ? ((Integer)map.get(Integer.valueOf(i1))).intValue() : 0;
                        l1 = ((Integer)map1.get(Integer.valueOf(i1))).intValue();
                        int i3;

                        if (k1 == l1)
                        {
                            ++l1;
                            i3 = l1;
                        }
                        else
                        {
                            i3 = Math.max(l1, k1);
                        }

                        l1 = i3;
                        int i2 = l1 - k1;
                        boolean flag1 = enchantment.canApply(itemstack);

                        if (this.thePlayer.capabilities.isCreativeMode || itemstack.getItem() == Items.enchanted_book)
                        {
                            flag1 = true;
                        }

                        Iterator iterator = map.keySet().iterator();

                        while (iterator.hasNext())
                        {
                            int j2 = ((Integer)iterator.next()).intValue();

                            Enchantment e2 = Enchantment.getEnchantmentById(j2);
                            if (j2 != i1 && !(enchantment.canApplyTogether(e2) && e2.canApplyTogether(enchantment))) //Forge BugFix: Let Both enchantments veto being together
                            {
                                flag1 = false;
                                i += i2;
                            }
                        }

                        if (flag1)
                        {
                            if (l1 > enchantment.getMaxLevel())
                            {
                                l1 = enchantment.getMaxLevel();
                            }

                            map.put(Integer.valueOf(i1), Integer.valueOf(l1));
                            int l2 = 0;

                            switch (enchantment.getWeight())
                            {
                                case 1:
                                    l2 = 8;
                                    break;
                                case 2:
                                    l2 = 4;
                                //$FALL-THROUGH$
							case 3:
                                case 4:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                default:
                                    break;
                                case 5:
                                    l2 = 2;
                                    break;
                                case 10:
                                    l2 = 1;
                            }

                            if (flag)
                            {
                                l2 = Math.max(1, l2 / 2);
                            }

                            i += l2 * i2;
                        }
                    }
                }
            }

            if (StringUtils.isBlank(this.repairedItemName))
            {
                if (itemstack.hasDisplayName())
                {
                    j = itemstack.isItemStackDamageable() ? 7 : itemstack.stackSize * 5;
                    i += j;
                    itemstack1.clearCustomName();
                }
            }
            else if (!this.repairedItemName.equals(itemstack.getDisplayName()))
            {
                j = itemstack.isItemStackDamageable() ? 7 : itemstack.stackSize * 5;
                i += j;

                if (itemstack.hasDisplayName())
                {
                    k2 += j / 2;
                }

                itemstack1.setStackDisplayName(this.repairedItemName);
            }

            k = 0;

            for (iterator1 = map.keySet().iterator(); iterator1.hasNext(); k2 += k + k1 * l1)
            {
                i1 = ((Integer)iterator1.next()).intValue();
                enchantment = Enchantment.getEnchantmentById(i1);
                k1 = ((Integer)map.get(Integer.valueOf(i1))).intValue();
                l1 = 0;
                ++k;

                switch (enchantment.getWeight())
                {
                    case 1:
                        l1 = 8;
                        break;
                    case 2:
                        l1 = 4;
                    //$FALL-THROUGH$
				case 3:
                    case 4:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    default:
                        break;
                    case 5:
                        l1 = 2;
                        break;
                    case 10:
                        l1 = 1;
                }

                if (flag)
                {
                    l1 = Math.max(1, l1 / 2);
                }
            }

            if (flag)
            {
                k2 = Math.max(1, k2 / 2);
            }

            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) itemstack1 = null;

            this.maximumCost = k2 + i;

            if (i <= 0)
            {
                itemstack1 = null;
            }

            if (j == i && j > 0 && this.maximumCost >= 60)
            {
                this.maximumCost = 59;
            }

            if (this.maximumCost >= 60 && !this.thePlayer.capabilities.isCreativeMode)
            {
                itemstack1 = null;
            }

            if (itemstack1 != null)
            {
                l = itemstack1.getRepairCost();

                if (itemstack2 != null && l < itemstack2.getRepairCost())
                {
                    l = itemstack2.getRepairCost();
                }

                if (itemstack1.hasDisplayName())
                {
                    l -= 9;
                }

                if (l < 0)
                {
                    l = 0;
                }

                l += 2;
                
                EnchantmentHelper.setEnchantments(map, itemstack1);
            }

            this.outputSlot.setInventorySlotContents(0, itemstack1);
            this.detectAndSendChanges();
        }
    }
    
    public void onCraftGuiOpened(ICrafting p_75132_1_)
    {
        super.onCraftGuiOpened(p_75132_1_);
        p_75132_1_.sendProgressBarUpdate(this, 0, this.maximumCost);
    }
    
    @SideOnly(Side.CLIENT)
    public void updateProgressBar(int p_75137_1_, int p_75137_2_)
    {
        if (p_75137_1_ == 0)
        {
            this.maximumCost = p_75137_2_;
        }
    }
    
    public void onContainerClosed(EntityPlayer p_75134_1_)
    {
        super.onContainerClosed(p_75134_1_);

        if (!this.w.isRemote)
        {
            for (int i = 0; i < this.inputSlots.getSizeInventory(); ++i)
            {
                ItemStack itemstack = this.inputSlots.removeStackFromSlot(i);

                if (itemstack != null)
                {
                    p_75134_1_.dropPlayerItemWithRandomChoice(itemstack, false);
                }
            }
        }
    }
    
    public boolean canInteractWith(EntityPlayer playerIn)
    {
        return this.w.getBlockState(new BlockPos(x,y,z)).getBlock() != TBBlocks.thaumicAnvil ? false : playerIn.getDistanceSq(x + 0.5D, y + 0.5D, z + 0.5D) <= 64.0D;
    }

    public ItemStack transferStackInSlot(EntityPlayer p_82846_1_, int p_82846_2_)
    {
        ItemStack itemstack = null;
        Slot slot = (Slot)this.inventorySlots.get(p_82846_2_);

        if (slot != null && slot.getHasStack())
        {
            ItemStack itemstack1 = slot.getStack();
            itemstack = itemstack1.copy();

            if (p_82846_2_ == 2)
            {
                if (!this.mergeItemStack(itemstack1, 3, 39, true))
                {
                    return null;
                }

                slot.onSlotChange(itemstack1, itemstack);
            }
            else if (p_82846_2_ != 0 && p_82846_2_ != 1)
            {
                if (p_82846_2_ >= 3 && p_82846_2_ < 39 && !this.mergeItemStack(itemstack1, 0, 2, false))
                {
                    return null;
                }
            }
            else if (!this.mergeItemStack(itemstack1, 3, 39, false))
            {
                return null;
            }

            if (itemstack1.stackSize == 0)
            {
                slot.putStack((ItemStack)null);
            }
            else
            {
                slot.onSlotChanged();
            }

            if (itemstack1.stackSize == itemstack.stackSize)
            {
                return null;
            }

            slot.onPickupFromSlot(p_82846_1_, itemstack1);
        }

        return itemstack;
    }
    
    public void updateItemName(String p_82850_1_)
    {
        this.repairedItemName = p_82850_1_;

        if (this.getSlot(2).getHasStack())
        {
            ItemStack itemstack = this.getSlot(2).getStack();

            if (StringUtils.isBlank(p_82850_1_))
            {
                itemstack.clearCustomName();
            }
            else
            {
                itemstack.setStackDisplayName(this.repairedItemName);
            }
        }

        this.updateRepairOutput();
    }

}
@MethodsReturnNonnullByDefault
@ParametersAreNonnullByDefault
package com.whammich.sstow;

import mcp.MethodsReturnNonnullByDefault;
import javax.annotation.ParametersAreNonnullByDefault;mod_name=SoulShards-TOW
package_group=com.whammich.sstow
mod_version=2.4.5

mc_version=1.9.4
forge_version=12.17.0.1968
mappings_version=snapshot_20160619
curse_id=226958

lendinglibrary_version=1.0.1-12
jei_version=3.6.6.215
waila_version=1.7.0-B3
bloodmagic_version=2.0.1-44
theoneprobe_version=1.0.9-22
mantle_version=0.10.2.jenkins149
tconstruct_version=2.3.2.jenkins255package flaxbeard.steamcraft.misc;

import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;

public class ItemStackUtility {
    /**
     * A performance-friendly cache of all the equipment slots.
     */
    public static final EntityEquipmentSlot[] EQUIPMENT_SLOTS = EntityEquipmentSlot.values();

	/**
	 * "Mostly" equal; returns true if the item and meta are the same (don't care about stacksize).
	 * 
	 * @param stack1
	 * @param stack2
	 * @return
	 */
	public static boolean areItemStacksMostlyEqual(ItemStack stack1, ItemStack stack2){
		return stack1.getItem().equals(stack2.getItem()) && stack1.getItemDamage() == stack2.getItemDamage();
	}

	public static EntityEquipmentSlot getSlotFromIndex(int index) {
        for (EntityEquipmentSlot slot : EQUIPMENT_SLOTS) {
            if (slot.getSlotIndex() == index) {
                return slot;
            }
        }
        return null;
    }
}
package com.feed_the_beast.ftbu.config;

import com.feed_the_beast.ftbl.api.config.ConfigEntryBool;
import com.feed_the_beast.ftbl.api.config.ConfigEntryDouble;
import com.feed_the_beast.ftbl.api.config.ConfigEntryInt;
import com.feed_the_beast.ftbl.api.config.ConfigEntryString;
import com.latmod.lib.annotations.Info;
import com.latmod.lib.annotations.NumberBounds;

public class FTBUConfigBackups
{
    @NumberBounds(min = 0, max = 100)
    @Info({"The number of backup files to keep", "More backups = more space used", "0 - Disabled"})
    public static final ConfigEntryInt backups_to_keep = new ConfigEntryInt(12);

    @NumberBounds(min = 0.05D, max = 600D)
    @Info({"Timer in hours", "1.0 - backups every hour", "6.0 - backups every 6 hours", "0.5 - backups every 30 minutes"})
    public static final ConfigEntryDouble backup_timer = new ConfigEntryDouble(2D);

    @NumberBounds(min = 0, max = 9)
    @Info({"0 - Disabled (output = folders)", "1 - Best speed", "9 - Smallest file size"})
    public static final ConfigEntryInt compression_level = new ConfigEntryInt(1);

    @Info("Absolute path to backups folder")
    public static final ConfigEntryString folder = new ConfigEntryString("");

    @Info("Prints (current size | total size) when backup is done")
    public static final ConfigEntryBool display_file_size = new ConfigEntryBool(true);

    @Info("Run backup in a separated Thread (recommended)")
    public static final ConfigEntryBool use_separate_thread = new ConfigEntryBool(true);

    @Info("Backups won't run if no players had been online")
    public static final ConfigEntryBool need_online_players = new ConfigEntryBool(true);

    public static long backupMillis()
    {
        return (long) (backup_timer.getAsInt() * 3600D * 1000D);
    }
}package com.feed_the_beast.ftbu.cmd;

import com.feed_the_beast.ftbl.api.cmd.CommandLM;
import com.feed_the_beast.ftbl.util.FTBLib;
import com.latmod.lib.util.LMFileUtils;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

import javax.annotation.Nonnull;
import java.io.File;

public class CmdRestart extends CommandLM
{
    public CmdRestart()
    {
        super("restart");
    }

    public static void restart()
    {
        LMFileUtils.newFile(new File(FTBLib.folderMinecraft, "autostart.stamp"));
        FTBLib.getServer().initiateShutdown();
    }

    @Override
    public void execute(@Nonnull MinecraftServer server, @Nonnull ICommandSender ics, @Nonnull String[] args) throws CommandException
    {
        restart();
    }
}package flaxbeard.steamcraft;

import flaxbeard.steamcraft.api.SteamcraftRegistry;
import flaxbeard.steamcraft.api.book.*;
import flaxbeard.steamcraft.api.exosuit.ExosuitPlate;
import flaxbeard.steamcraft.integration.CrossMod;
import flaxbeard.steamcraft.item.armor.exosuit.ItemExosuitArmor;
import flaxbeard.steamcraft.misc.DrillHeadMaterial;
import net.minecraft.client.resources.I18n;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.oredict.OreDictionary;

import org.apache.commons.lang3.tuple.MutablePair;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import static flaxbeard.steamcraft.init.blocks.SteamNetworkBlocks.Blocks.*;
import static flaxbeard.steamcraft.init.blocks.OreBlocks.Blocks.*;
import static flaxbeard.steamcraft.init.blocks.CastingBlocks.Blocks.*;
import static flaxbeard.steamcraft.init.blocks.SteamMachineryBlocks.Blocks.*;
import static flaxbeard.steamcraft.init.items.tools.GadgetItems.Items.*;
import static flaxbeard.steamcraft.init.items.CraftingComponentItems.Items.*;
import static flaxbeard.steamcraft.init.items.firearms.FirearmItems.Items.*;
import static flaxbeard.steamcraft.init.items.firearms.FirearmUpgradeItems.Items.*;
import static flaxbeard.steamcraft.init.items.firearms.FirearmAmmunitionItems.Items.*;
import static flaxbeard.steamcraft.init.items.MetalcastingItems.Items.*;
import static flaxbeard.steamcraft.init.items.MetalItems.Items.*;
import static flaxbeard.steamcraft.init.items.armor.ArmorItems.Items.*;
import static flaxbeard.steamcraft.init.items.tools.ToolItems.Items.*;
import static flaxbeard.steamcraft.init.items.tools.ToolUpgradeItems.Items.*;
import static flaxbeard.steamcraft.init.items.armor.ExosuitUpgradeItems.Items.*;
import static flaxbeard.steamcraft.init.items.armor.ExosuitUpgradeItems.PlateItems.*;
import static flaxbeard.steamcraft.init.misc.DefaultCrucibleLiquids.Liquids.*;

public class SteamcraftBook {
    //Here's a secret for all of you addon devs: Setting the category of a research to the name of an existing research, with a ! at the beginning, will append to that research instead of making its own.

    // TODO: Change if (Config.XXX) to if (thing.isEnabled())
    public static void registerBookResearch() {
        if (Config.hasAllCrucial) {
            registerBasics();
            registerFirearms();
            registerCasting();
            registerGadgets();
            registerSteamPower();
            registerExosuit();
            //registerAuto();
            /* registerMisc(); Uncomment this when shit is added to it.*/
        }

    }

    public static void registerBasics() {
        SteamcraftRegistry.addCategory("category.Basics.name");

        SteamcraftRegistry.addResearch(
          "research.Book.name",
          "category.Basics.name",
          new BookPageItem("research.Book.name", "research.Book.0", new ItemStack(BOOK.getItem())),
          new BookPageCrafting("", "book")
        );

        SteamcraftRegistry.addResearch(
          "research.Ores.name",
          "category.Basics.name",
          new BookPageItem(
            "research.Ores.name",
            "research.Ores.0",
            OVERWORLD_COPPER_ORE.createItemStack(),
            OVERWORLD_ZINC_ORE.createItemStack()
          )
        );

        SteamcraftRegistry.addResearch(
          "research.Bits.name",
          "category.Basics.name",
          new BookPageItem(
            "research.Bits.name",
            "research.Bits.0",
            BRASS_PISTON.createItemStack(),
            BRASS_TURBINE.createItemStack()
          ),
          new BookPageCrafting("", "piston1", "piston2"),
          new BookPageText("research.Bits.name", "research.Bits.1"),
          new BookPageCrafting("", "turbine1", "turbine2")
        );

        SteamcraftRegistry.addResearch(
          "research.SteamSystem.name",
          "category.Basics.name",
          new BookPageItem(
            "research.SteamSystem.name",
            "research.SteamSystem.0",
            new ItemStack(BOILER.getBlock(), 1, 0),
            new ItemStack(PIPE.getBlock(), 1, 0)
          ),
          new BookPageText("research.SteamSystem.name", "research.SteamSystem.1"),
          new BookPageText("research.SteamSystem.name", "research.SteamSystem.2"),
          new BookPageText("research.SteamSystem.name", "research.SteamSystem.3"),
          new BookPageText("research.SteamSystem.name", "research.SteamSystem.4"),
          new BookPageText("research.SteamSystem.name", "research.SteamSystem.5")
        );

        SteamcraftRegistry.addResearch(
          "research.Camouflage.name",
          "category.Basics.name",
          new BookPageItem(
            "research.Camouflage.name",
            "research.Camouflage.0",
            new ItemStack(PIPE.getBlock()),
            new ItemStack(Blocks.STONEBRICK)),
          new BookPageText("research.Camouflage.name", "research.Camouflage.1")
        );
    }

    public static void registerFirearms() {
        if (Config.enableFirearms || Config.enableRL) {
            SteamcraftRegistry.addCategory("category.Flintlock.name");
            SteamcraftRegistry.addResearch("research.Parts.name", "category.Flintlock.name",
              new BookPageItem("research.Parts.name", "research.Parts.0",
                BLUNDERBUSS_BARREL.createItemStack(),
                FLINTLOCK.createItemStack(),
                GUN_STOCK.createItemStack(),
                IRON_BARREL.createItemStack()
              ),
              new BookPageCrafting("", "stock"), new BookPageCrafting("", "barrel1", "barrel2"),
              new BookPageCrafting("", "blunderBarrel1", "blunderBarrel2"),
              new BookPageCrafting("", "flintlock1", "flintlock2"));
        }
        if (Config.enableFirearms) {
            SteamcraftRegistry.addResearch("research.Musket.name", "category.Flintlock.name",
              new BookPageItem("research.Musket.name", "research.Musket.0", new ItemStack(MUSKET.getItem())),
              new BookPageCrafting("", "cartridge1", "cartridge2", "cartridge3", "cartridge4"),
              new BookPageCrafting("", "musket"));
            if (Config.enableSpyglass) {
                SteamcraftRegistry.addResearch("research.EnhancementSpyglass.name", "!research.Musket.name",
                  new BookPageItem("research.EnhancementSpyglass.name", "research.EnhancementSpyglass.0", true,
                    new ItemStack(SPYGLASS.getItem())));
            }
            if (Config.enableEnhancementAblaze) {
                SteamcraftRegistry.addResearch("research.EnhancementAblaze.name", "!research.Musket.name",
                  new BookPageItem("research.EnhancementAblaze.name", "research.EnhancementAblaze.0", true,
                    new ItemStack(BLAZE_BARREL.getItem())), new BookPageCrafting("", "ablaze"));
            }
            if (Config.enableEnhancementSpeedloader) {
                SteamcraftRegistry.addResearch("research.EnhancementSpeedloader.name", "!research.Musket.name",
                  new BookPageItem("research.EnhancementSpeedloader.name", "research.EnhancementSpeedloader.0", true,
                    new ItemStack(BOLT_ACTION.getItem())),
                  new BookPageCrafting("", "speedloader1", "speedloader2"));
            }
            SteamcraftRegistry.addResearch("research.Blunderbuss.name", "category.Flintlock.name",
              new BookPageItem("research.Blunderbuss.name", "research.Blunderbuss.0",
                new ItemStack(BLUNDERBUSS.getItem())), new BookPageCrafting("", "blunderbuss"));
            if (Config.enableEnhancementAblaze) {
                SteamcraftRegistry.addResearch("research.EnhancementAblaze2.name", "!research.Blunderbuss.name",
                  new BookPageItem("research.EnhancementAblaze2.name", "research.EnhancementAblaze2.0", true,
                    new ItemStack(BLAZE_BARREL.getItem())), new BookPageCrafting("", "ablaze"));
            }
            if (Config.enableEnhancementSpeedloader) {
                SteamcraftRegistry.addResearch("research.EnhancementSpeedloader2.name", "!research.Blunderbuss.name",
                  new BookPageItem("research.EnhancementSpeedloader2.name", "research.EnhancementSpeedloader2.0", true,
                    new ItemStack(BOLT_ACTION.getItem())), new BookPageCrafting("", "speedloader1", "speedloader2"));
            }
            if (Config.enableEnhancementRecoil) {
                SteamcraftRegistry.addResearch("research.EnhancementRecoil.name", "!research.Blunderbuss.name",
                  new BookPageItem("research.EnhancementRecoil.name", "research.EnhancementRecoil.0", true,
                    new ItemStack(RECOIL_PAD.getItem())), new BookPageCrafting("", "recoil"));
            }
            SteamcraftRegistry.addResearch("research.Pistol.name", "category.Flintlock.name",
              new BookPageItem("research.Pistol.name", "research.Pistol.0", new ItemStack(PISTOL.getItem())),
              new BookPageCrafting("", "pistol"));
            if (Config.enableEnhancementRevolver) {
                SteamcraftRegistry.addResearch("research.EnhancementRevolver.name", "!research.Pistol.name",
                  new BookPageItem("research.EnhancementRevolver.name", "research.EnhancementRevolver.0", true,
                    new ItemStack(REVOLVER_CHAMBER.getItem())), new BookPageCrafting("", "revolver1", "revolver2"));
            }
            if (Config.enableEnhancementSilencer) {
                SteamcraftRegistry.addResearch("research.EnhancementSilencer.name", "!research.Pistol.name",
                  new BookPageItem("research.EnhancementSilencer.name", "research.EnhancementSilencer.0", true,
                    new ItemStack(MAKESHIFT_SUPPRESSOR.getItem())), new BookPageCrafting("", "silencer"));
            }
            if (Config.enableEnhancementSpeedy) {
                SteamcraftRegistry.addResearch("research.EnhancementSpeedy.name", "!research.Pistol.name",
                  new BookPageItem("research.EnhancementSpeedy.name", "research.EnhancementSpeedy.0", true,
                    new ItemStack(BREECH.getItem())), new BookPageCrafting("", "speedy1", "speedy2"));
            }
        }
        if (Config.enableRL) {
            SteamcraftRegistry.addResearch("research.RocketLauncher.name", "category.Flintlock.name",
              new BookPageItem("research.RocketLauncher.name", "research.RocketLauncher.0",
                new ItemStack(ROCKET_LAUNCHER.getItem())),
              new BookPageCrafting("", "rocket1", "rocket2", "rocket3", "rocket4"));
            if (Config.enableEnhancementFastRockets) {
                SteamcraftRegistry.addResearch("research.EnhancementFastRockets.name", "!research.RocketLauncher.name",
                  new BookPageItem("research.EnhancementFastRockets.name", "research.EnhancementFastRockets.0", true,
                    new ItemStack(STREAMLINED_BARREL.getItem())), new BookPageCrafting("", "fastRockets"));
            }
            if (Config.enableEnhancementAmmo) {
                SteamcraftRegistry.addResearch("research.EnhancementAmmo.name", "!research.RocketLauncher.name",
                  new BookPageItem("research.EnhancementAmmo.name", "research.EnhancementAmmo.0", true,
                    new ItemStack(EXTENDED_MAGAZINE.getItem())), new BookPageCrafting("", "ammo1", "ammo2"));
            }
            if (Config.enableEnhancementAirStrike) {
                SteamcraftRegistry.addResearch("research.EnhancementAirStrike.name", "!research.RocketLauncher.name",
                  new BookPageItem("research.EnhancementAirStrike.name", "research.EnhancementAirStrike.0", true,
                    new ItemStack(AIR_STRIKE_CONVERSION_KIT.getItem())),
                  new BookPageCrafting("", "airStrike1", "airStrike2"));
            }
            SteamcraftRegistry.addResearch("research.Rockets.name", "category.Flintlock.name");
            if (Config.enableRocket) {
                SteamcraftRegistry.addResearch("research.Rocket.name", "!research.Rockets.name",
                  new BookPageItem("research.Rocket.name", "research.Rocket.0", true, new ItemStack(ROCKET.getItem())),
                  new BookPageCrafting("", "normalRocket1", "normalRocket2"));
            }
            if (Config.enableRocketConcussive) {
                if (Config.enableRocket) {
                    SteamcraftRegistry.addResearch("research.RocketConcussive.name", "!research.Rockets.name",
                      new BookPageItem("research.RocketConcussive.name", "research.RocketConcussive.0", true,
                        new ItemStack(CONCUSSIVE_ROCKET.getItem())), new BookPageCrafting("", "concussiveRocket"));
                } else {
                    SteamcraftRegistry.addResearch("research.RocketConcussive.name", "!research.Rockets.name",
                      new BookPageItem("research.RocketConcussive.name", "research.RocketConcussive.0", true,
                        new ItemStack(CONCUSSIVE_ROCKET.getItem())),
                      new BookPageCrafting("", "concussiveRocket1", "concussiveRocket2"));
                }
            }
            if (Config.enableRocketMining) {
                SteamcraftRegistry.addResearch("research.RocketMining.name", "!research.Rockets.name",
                  new BookPageItem("research.RocketMining.name", "research.RocketMining.0", true,
                    new ItemStack(MINING_ROCKET.getItem())), new BookPageCrafting("", "miningRocket"));
            }
        }
    }

    public static void registerCasting() {
        SteamcraftRegistry.addCategory("category.MetalCasting.name");
        if (Config.enableCrucible) {
            SteamcraftRegistry.addResearch("research.Crucible.name", "category.MetalCasting.name",
              new BookPageItem("research.Crucible.name", "research.Crucible.0",
                new ItemStack(CRUCIBLE.getBlock())),
              new BookPageText("research.Crucible.name", "research.Crucible.1"), new BookPageCrafting("", "crucible"));
            if (Config.enableHellCrucible) {
                SteamcraftRegistry.addResearch("research.HellCrucible.name", "category.MetalCasting.name",
                  new BookPageItem("research.HellCrucible.name", "research.HellCrucible.0",
                    new ItemStack(NETHER_CRUCIBLE.getBlock())), new BookPageCrafting("", "hellCrucible"));
            }
        }
        if (Config.enableMold) {
            SteamcraftRegistry.addResearch("research.Mold.name", "category.MetalCasting.name",
              new BookPageItem("research.Mold.name", "research.Mold.0",
                new ItemStack(MOLD.getBlock())), new BookPageText("research.Mold.name", "research.Mold.1"),
              new BookPageCrafting("", "mold"));
            SteamcraftRegistry.addResearch("research.Molds.name", "category.MetalCasting.name",
              new BookPageItem("research.Molds.name", "research.Molds.0", new ItemStack(PLATE_MOLD.getItem()),
                new ItemStack(INGOT_MOLD.getItem()), new ItemStack(NUGGET_MOLD.getItem())),
              new BookPageCrafting("", "blankMold"), new BookPageCrafting("", "carving"));
        }
        SteamcraftRegistry.addResearch("research.Plates.name", "category.MetalCasting.name",
          new BookPageItem("research.Plates.name", "research.Plates.0",
            COPPER_PLATE.createItemStack(),
            ZINC_PLATE.createItemStack(),
            GOLD_PLATE.createItemStack(),
            IRON_PLATE.createItemStack(),
            BRASS_PLATE.createItemStack(),
            GILDED_IRON_PLATE.createItemStack()));
        SteamcraftRegistry.addResearch("research.Brass.name", "category.MetalCasting.name",
          new BookPageItem("research.Brass.name", "research.Brass.0", BRASS_INGOT.createItemStack()),
          new BookPageAlloy("", BRASS_LIQUID.getLiquid(), BRASS_LIQUID.getLiquid().recipe));

        if (Config.enableCrucible) {
            SteamcraftRegistry.addResearch("research.GildedGold.name", "category.MetalCasting.name",
              new BookPageItem("research.GildedGold.name", "research.GildedGold.0", GILDED_IRON_INGOT.createItemStack()),
              new BookPageText("research.GildedGold.name", "research.GildedGold.1"),
              new BookPageDip("", GOLD_LIQUID.getLiquid(), 1, new ItemStack(Items.IRON_INGOT), GILDED_IRON_PLATE.createItemStack()));
        }
    }

    public static void registerGadgets() {
        SteamcraftRegistry.addCategory("category.Gadgets.name");

        if (Config.enableWrench) {
            SteamcraftRegistry.addResearch("research.Wrench.name", "category.Gadgets.name",
              new BookPageItem("research.Wrench.name", "research.Wrench.0", new ItemStack(WRENCH.getItem())),
              new BookPageText("research.Wrench.name", "research.Wrench.1"),
              new BookPageCrafting("", "wrench1", "wrench2"));
        }
        if (Config.enableSpyglass) {
            SteamcraftRegistry.addResearch("research.Spyglass.name", "category.Gadgets.name",
              new BookPageItem("research.Spyglass.name", "research.Spyglass.0", new ItemStack(SPYGLASS.getItem())),
              new BookPageCrafting("", "spyglass1", "spyglass2"));
        }
        if (Config.enableSurvivalist) {
            if (CrossMod.BAUBLES) {
                SteamcraftRegistry.addResearch("research.Survivalist.name", "category.Gadgets.name",
                  new BookPageItem("research.Survivalist.name", "research.SurvivalistBaubles.0", new ItemStack(SURVIVALIST_TOOLKIT.getItem())),
                  new BookPageCrafting("", "survivalist"));
            } else {
                SteamcraftRegistry.addResearch("research.Survivalist.name", "category.Gadgets.name",
                  new BookPageItem("research.Survivalist.name", "research.Survivalist.0", new ItemStack(SURVIVALIST_TOOLKIT.getItem())),
                  new BookPageCrafting("", "survivalist"));
            }
        }
        if (Config.enableCanister) {
            ItemStack output = new ItemStack(Items.DIAMOND_SWORD);
            output.setTagCompound(new NBTTagCompound());
            output.getTagCompound().setInteger("canned", 0);
            SteamcraftRegistry.addResearch("research.Canister.name", "category.Gadgets.name",
              new BookPageItem("research.Canister.name", "research.Canister.0", new ItemStack(ITEM_CANISTER.getItem())),
              new BookPageCrafting("", "canister"),
              new BookPageCrafting("", true, output, Items.DIAMOND_SWORD, ITEM_CANISTER.getItem()));
        }
        if (Config.enableTopHat) {
            SteamcraftRegistry.addResearch("research.TopHat.name", "category.Gadgets.name",
              new BookPageItem("research.TopHat.name", "research.TopHat.0", new ItemStack(TOP_HAT.getItem())),
              new BookPageCrafting("", "hat"));
            if (Config.enableEmeraldHat) {
                SteamcraftRegistry.addResearch("research.TopHatEmerald.name", "category.Gadgets.name",
                  new BookPageItem("research.TopHatEmerald.name", "research.TopHatEmerald.0",
                    new ItemStack(ENTREPRENEUR_TOP_HAT.getItem())), new BookPageCrafting("", "hatEmerald"));
            }
        }
        if (Config.enableGoggles) {
            SteamcraftRegistry.addResearch("research.Goggles.name", "category.Gadgets.name",
              new BookPageItem("research.Goggles.name", "research.Goggles.0", new ItemStack(GOGGLES.getItem()),
                new ItemStack(MONOCLE.getItem())),
              new BookPageCrafting("", "goggles1", "goggles2"),
              new BookPageCrafting("", "monocle1", "monocle2"));
        }

        if (Config.enableSteamCell) {
            SteamcraftRegistry.addResearch("research.SteamCell.name", "category.Gadgets.name",
              new BookPageItem("research.SteamCell.name", "research.SteamCell.0",
                new ItemStack(STEAM_CELL_EMPTY.getItem()),
                new ItemStack(STEAM_CELL_FULL.getItem())),
              new BookPageCrafting("", "steamcell"));
        }

        if (Config.enableSteamCellBauble && CrossMod.BAUBLES) {
            SteamcraftRegistry.addResearch("research.SteamCellFiller.name", "category.Gadgets.name",
              new BookPageItem("research.SteamCellFiller.name", "research.SteamCellFiller.0",
                new ItemStack(STEAM_CELL_FILLER.getItem())),
              new BookPageCrafting("", "steamcellFiller"));
        }
    }

    public static void registerSteamTools() {
        if (!Config.enableSteamTools) {
            return;
        }
        SteamcraftRegistry.addCategory("category.SteamTools.name");
        SteamcraftRegistry.addResearch("research.SteamTools.name", "category.SteamTools.name",
          new BookPageItem("research.SteamTools.name", "research.SteamTools.0",
            new ItemStack(STEAM_DRILL.getItem()),
            new ItemStack(STEAM_SAW.getItem()),
            new ItemStack(STEAM_SHOVEL.getItem())),
          new BookPageText("research.SteamTools.name", "research.SteamTools.1"),
          new BookPageCrafting("", "drill1", "drill2", "drill3", "drill4"),
          new BookPageCrafting("", "axe1", "axe2", "axe3", "axe4"),
          new BookPageCrafting("", "shovel1", "shovel2", "shovel3", "shovel4")
        );

        SteamcraftRegistry.addResearch("research.SteamDrillHead.name", "category.SteamTools.name");

        ArrayList<String> drillMatsArray = new ArrayList<>();
        for (DrillHeadMaterial material : DrillHeadMaterial.materials.values()) {
            String loc = material.locName;
            String string = I18n.hasKey(loc) ? I18n.format(loc) : material.materialName;
            drillMatsArray.add(string);
        }

        StringBuilder drillMats = new StringBuilder();
        String delimiter = I18n.format("steamcraft.book.listjoiner");
        Iterator iter = drillMatsArray.iterator();
        while (iter.hasNext()) {
            drillMats.append(iter.next());
            if (iter.hasNext()) {
                drillMats.append(delimiter);
            }
        }

        SteamcraftRegistry.addResearch("research.DrillHeads.name", "!research.SteamDrillHead.name",
          new BookPageItem("research.DrillHeads.name", "research.DrillHeads.0",
            new Object[] { drillMats.toString() }, true,
            new ItemStack(DRILL_HEAD.getItem())), new BookPage(""));

        if (Config.enableFortune) {
            SteamcraftRegistry.addResearch("research.MultiplicativeResonator.name",
              "!research.SteamDrillHead.name",
              new BookPageItem("research.MultiplicativeResonator.name",
                "research.MultiplicativeResonator.0", true,
                new ItemStack(MULTIPLICATIVE_RESONATOR.getItem())),
              new BookPageCrafting("", "multiplicativeResonator"));
        }

        if (Config.enableBigDrill) {
            SteamcraftRegistry.addResearch("research.BigDrill.name",
              "!research.SteamDrillHead.name",
              new BookPageItem("research.BigDrill.name", "research.BigDrill.0", true,
                new ItemStack(BIG_DRILL.getItem())),
              new BookPageCrafting("", "bigDrill"));
        }

        if (Config.enableBattleDrill) {
            SteamcraftRegistry.addResearch("research.BattleDrill.name",
              "!research.SteamDrillHead.name",
              new BookPageItem("research.BattleDrill.name", "research.BattleDrill.0", true,
                new ItemStack(BATTLE_DRILL.getItem())),
              new BookPageCrafting("", "battleDrill"));
        }

        if (Config.enablePreciseCuttingHead) {
            SteamcraftRegistry.addResearch("research.PreciseCuttingHead.name",
              "!research.SteamDrillHead.name",
              new BookPageItem("research.PreciseCuttingHead.name",
                "research.PreciseCuttingHead.0", true, new ItemStack(PRECISE_CUTTING_HEAD.getItem())),
              new BookPageCrafting("", "preciseCuttingHead"));
        }

        if (Config.enableStoneGrinder) {
            SteamcraftRegistry.addResearch("research.StoneGrinder.name",
              "!research.SteamDrillHead.name",
              new BookPageItem("research.StoneGrinder.name", "research.StoneGrinder.0", true,
                new ItemStack(STONE_GRINDER.getItem())),
              new BookPageCrafting("", "stoneGrinder"));
        }

        if (Config.enableThermalDrill) {
            SteamcraftRegistry.addResearch("research.ThermalDrill.name",
              "!research.SteamDrillHead.name", new BookPageItem("research.ThermalDrill.name",
                "research.ThermalDrill.0", true, new ItemStack(THERMAL_DRILL.getItem())),
              new BookPageCrafting("", "thermalDrill"));
        }

        if (Config.enableChargePlacer) {
            SteamcraftRegistry.addResearch("research.CalamityInjector.name",
              "!research.SteamDrillHead.name", new BookPageItem("research.CalamityInjector.name",
                "research.CalamityInjector.0", true, new ItemStack(CHARGE_PLACER.getItem())),
              new BookPageCrafting("", "chargePlacer"));
        }

        SteamcraftRegistry.addResearch("research.SteamDrillCore.name", "category.SteamTools.name");

        if (Config.enableInternalProcessingUnit) {
            SteamcraftRegistry.addResearch("research.InternalProcessingUnit.name",
              "!research.SteamDrillCore.name", new BookPageItem(
                "research.InternalProcessingUnit.name", "research.InternalProcessingUnit.0", true,
                new ItemStack(INTERNAL_PROCESSING_UNIT.getItem())),
              new BookPageCrafting("", "internalProcessingUnit"));
        }

        SteamcraftRegistry.addResearch("research.SteamSawHead.name", "category.SteamTools.name");

        if (Config.enableForestFire) {
            SteamcraftRegistry.addResearch("research.ForestFire.name",
              "!research.SteamSawHead.name", new BookPageItem("research.ForestFire.name",
                "research.ForestFire.0", true, new ItemStack(FOREST_FIRE.getItem())),
              new BookPageCrafting("", "forestFire"));
        }

        if (Config.enableTreeFeller) {
            SteamcraftRegistry.addResearch("research.TimberChain.name",
              "!research.SteamSawHead.name", new BookPageItem("research.TimberChain.name",
                "research.TimberChain.0", true, new ItemStack(TIMBER_CHAIN.getItem())),
              new BookPageCrafting("", "treeFeller"));
        }

        if (Config.enableLeafBlower) {
            SteamcraftRegistry.addResearch("research.LeafBlower.name",
              "!research.SteamSawHead.name", new BookPageItem("research.LeafBlower.name",
                "research.LeafBlower.0", true, new ItemStack(LEAF_BLOWER.getItem())),
              new BookPageCrafting("", "leafBlower"));
        }

        if (Config.enableChainsaw) {
            SteamcraftRegistry.addResearch("research.Chainsaw.name", "!research.SteamSawHead.name",
              new BookPageItem("research.Chainsaw.name", "research.Chainsaw.0", true,
                new ItemStack(CHAINSAW.getItem())), new BookPageCrafting("", "chainsaw"));
        }

        SteamcraftRegistry.addResearch("research.SteamSawCore.name", "category.SteamTools.name");

        SteamcraftRegistry.addResearch("research.SteamShovelHead.name", "category.SteamTools.name");

        if (Config.enableBackhoe) {
            SteamcraftRegistry.addResearch("research.Backhoe.name",
              "!research.SteamShovelHead.name", new BookPageItem("research.Backhoe.name",
                "research.Backhoe.0", true, new ItemStack(BACKHOE.getItem())),
              new BookPageCrafting("", "backhoe"));
        }

        if (Config.enableCultivator) {
            SteamcraftRegistry.addResearch("research.Cultivator.name",
              "!research.SteamShovelHead.name", new BookPageItem("research.Cultivator.name",
                "research.Cultivator.0", true, new ItemStack(CULTIVATOR.getItem())),
              new BookPageCrafting("", "cultivator"));
        }

        if (Config.enableRotaryBlades) {
            SteamcraftRegistry.addResearch("research.RotaryBlades.name",
              "!research.SteamShovelHead.name", new BookPageItem("research.RotaryBlades.name",
                "research.RotaryBlades.0", true, new ItemStack(ROTARY_BLADES.getItem())),
              new BookPageCrafting("", "rotaryBlades"));
        }

        SteamcraftRegistry.addResearch("research.SteamShovelCore.name", "category.SteamTools.name");

        if (Config.enableSifter) {
            SteamcraftRegistry.addResearch("research.Sifter.name", "!research.SteamShovelCore.name",
              new BookPageItem("research.Sifter.name", "research.Sifter.0", true,
                new ItemStack(SIFTER.getItem())), new BookPageCrafting("", "sifter"));
        }

        SteamcraftRegistry.addResearch("research.SteamUniversalCore.name", "category.SteamTools.name");

        if (Config.enableOverclocker) {
            SteamcraftRegistry.addResearch("research.Overclocker.name",
              "!research.SteamUniversalCore.name", new BookPageItem("research.Overclocker.name",
                "research.Overclocker.0", true, new ItemStack(OVERCLOCKER.getItem())),
              new BookPageCrafting("", "overclocker"));
        }

        if (Config.enableAutosmelting) {
            SteamcraftRegistry.addResearch("research.ExothermicProjector.name",
              "!research.SteamUniversalCore.name",
              new BookPageItem("research.ExothermicProjector.name",
                "research.ExothermicProjector.0", true, new ItemStack(EXOTHERMIC_PROJECTOR.getItem())),
              new BookPageCrafting("", "autosmelting"));
        }

        if (Config.enableTheVoid) {
            SteamcraftRegistry.addResearch("research.TheVoid.name",
              "!research.SteamUniversalCore.name", new BookPageItem("research.TheVoid.name",
                "research.TheVoid.0", true, new ItemStack(THE_VOID.getItem())),
              new BookPageCrafting("", "theVoid"));
        }
    }

    public static void registerSteamPower() {
        SteamcraftRegistry.addCategory("category.SteamPower.name");
        SteamcraftRegistry.addResearch("research.Boiler.name", "category.SteamPower.name",
          new BookPageItem("research.Boiler.name", "research.Boiler.0", new ItemStack(BOILER.getBlock())),
          new BookPageCrafting("", "boiler1", "boiler2"));

        if (Config.enableFlashBoiler) {
            SteamcraftRegistry.addResearch("research.FlashBoiler.name", "category.SteamPower.name",
              new BookPageItem("research.FlashBoiler.name", "research.FlashBoiler.0", new ItemStack(FLASH_BOILER.getBlock())),
              new BookPageText("research.FlashBoiler.name", "research.FlashBoiler.1"),
              new BookPageCrafting("", "flashBoiler1", "flashBoiler2"));
        }
        SteamcraftRegistry.addResearch("research.Pipe.name", "category.SteamPower.name",
          new BookPageItem("research.Pipe.name", "research.Pipe.0", new ItemStack(PIPE.getBlock())),
          new BookPageCrafting("", "pipe1", "pipe2"),
          new BookPageText("research.Pipe.name", "research.Pipe.1"),
          new BookPageCrafting("", "valvePipe"));

        if (Config.enableRuptureDisc) {
            SteamcraftRegistry.addResearch("research.RuptureDisc.name", "category.SteamPower.name",
              new BookPageItem("research.RuptureDisc.name", "research.RuptureDisc.0", new ItemStack(RUPTURE_DISC.getBlock())),
              new BookPageText("research.RuptureDisc.name", "research.RuptureDisc.1"),
              new BookPageCrafting("", "disc"));
        }

        if (Config.enableHorn) {
            SteamcraftRegistry.addResearch("research.Whistle.name", "category.SteamPower.name",
              new BookPageItem("research.Whistle.name", "research.Whistle.0", new ItemStack(STEAM_WHISTLE.getBlock())),
              new BookPageCrafting("", "whistle1", "whistle2"));
        }

        if (Config.enableGauge) {
            SteamcraftRegistry.addResearch("research.Gauge.name", "category.SteamPower.name",
              new BookPageItem("research.Gauge.name", "research.Gauge.0", new ItemStack(STEAM_GAUGE.getBlock())),
              new BookPageCrafting("", "gauge"));
        }
        SteamcraftRegistry.addResearch("research.Tank.name", "category.SteamPower.name",
          new BookPageItem("research.Tank.name", "research.Tank.0", new ItemStack(TANK.getBlock())),
          new BookPageCrafting("", "tank1", "tank2"));
        SteamcraftRegistry.addResearch("research.CreativeTank.name", "category.NOTREAL.name",
          new BookPageItem("research.CreativeTank.name", "research.CreativeTank.0", new ItemStack(Items.BOWL)));
        SteamcraftRegistry.bookRecipes.put(new ItemStack(TANK.getBlock(), 1, 1), MutablePair.of("research.CreativeTank.name", 0));

        if (Config.enableCharger) {
            SteamcraftRegistry.addResearch("research.Filler.name", "category.SteamPower.name",
              new BookPageItem("research.Filler.name", "research.Filler.0", new ItemStack(STEAM_FILLER.getBlock())),
              new BookPageText("research.Filler.name", "research.Filler.1"),
              new BookPageCrafting("", "filler1", "filler2"));
        }

        if (Config.enableChargingPad && Config.enableCharger) {
            SteamcraftRegistry.addResearch("research.FillingPad.name", "category.SteamPower.name",
              new BookPageItem("research.FillingPad.name", "research.FillingPad.0", new ItemStack(FILLING_PAD.getBlock())),
              new BookPageCrafting("", "fillingPad1", "fillingPad2"));
        }

        if (Config.enableHeater) {
            SteamcraftRegistry.addResearch("research.Heater.name", "category.SteamPower.name",
              new BookPageItem("research.Heater.name", "research.Heater.0", new ItemStack(STEAM_HEATER.getBlock())),
              new BookPageCrafting("", "heater1", "heater2"));
        }

        if (Config.enableMortar && Config.enableAstrolabe) {
            SteamcraftRegistry.addResearch("research.ItemMortar.name", "category.SteamPower.name",
              new BookPageItem("research.ItemMortar.name", "research.ItemMortar.0", new ItemStack(ITEM_MORTAR.getBlock())),
              new BookPageText("research.ItemMortar.name", "research.ItemMortar.1"),
              new BookPageCrafting("", "astrolabe"),
              new BookPageCrafting("", "itemMortar2", "itemMortar3"));
        }

        if (Config.enableHammer) {
            SteamcraftRegistry.addResearch("research.Hammer.name", "category.SteamPower.name",
              new BookPageItem("research.Hammer.name", "research.Hammer.0", new ItemStack(STEAM_HAMMER.getBlock())),
              new BookPageText("research.Hammer.name", "research.Hammer.1"),
              new BookPageCrafting("", "hammer1", "hammer2"));
        }
        if (Config.enablePump) {
            SteamcraftRegistry.addResearch("research.Screw.name", "category.SteamPower.name",
              new BookPageItem("research.Screw.name", "research.Screw.0", new ItemStack(ARCHIMEDES_SCREW.getBlock())),
              new BookPageCrafting("", "pump1", "pump2"));
        }

        if (Config.enableSmasher) {
            SteamcraftRegistry.addResearch("research.Smasher.name", "category.SteamPower.name",
              new BookPageItem("research.Smasher.name", "research.Smasher.0", new ItemStack(ROCK_SMASHER.getBlock())),
              new BookPageText("research.Smasher.name", "research.Smasher.1"),
              new BookPageCrafting("", "smasher1", "smasher2", "smasher3", "smasher4"));
        }

        if (Config.enableThumper) {
            SteamcraftRegistry.addResearch("research.Thumper.name", "category.SteamPower.name",
              new BookPageItem("research.Thumper.name", "research.Thumper.0", new ItemStack(THUMPER.getBlock())),
              new BookPageText("research.Thumper.name", "research.Thumper.1"),
              new BookPageCrafting("", "thumper1", "thumper2"));
        }

        if (Config.enableFan) {
            SteamcraftRegistry.addResearch("research.Fan.name", "category.SteamPower.name",
              new BookPageItem("research.Fan.name", "research.Fan.0", new ItemStack(FAN.getBlock())),
              new BookPageCrafting("", "fan1", "fan2"));
            if (Config.enableVacuum) {
                SteamcraftRegistry.addResearch("research.Vacuum.name", "category.SteamPower.name",
                  new BookPageItem("research.Vacuum.name", "research.Vacuum.0", new ItemStack(VACUUM.getBlock())),
                  new BookPageCrafting("", "vacuum1", "vacuum2"));
            }
        }

        if (Config.enableFluidSteamConverter) {
            SteamcraftRegistry.addResearch("research.FSC.name", "category.SteamPower.name",
              new BookPageItem("research.FSC.name", "research.FSC.0", new ItemStack(PRESSURE_CONVERTER.getBlock())),
              new BookPageCrafting("", "fsc1", "fsc2"),
              new BookPageText("", "research.FSC.1"),
              new BookPageText("", "research.FSC.2"));
        }

    }

    public static void registerExosuit() {
        if (Config.enableExosuit && Config.enableEngineering) {
            SteamcraftRegistry.addCategory("category.Exosuit.name");
            SteamcraftRegistry.addResearch("research.Exosuit.name", "category.Exosuit.name",
              new BookPageItem("research.Exosuit.name", "research.Exosuit.0",
                new ItemStack(EXOSUIT_HEADPIECE.getItem()),
                new ItemStack(EXOSUIT_CHESTPIECE.getItem()),
                new ItemStack(EXOSUIT_LEGPIECE.getItem()),
                new ItemStack(EXOSUIT_FOOTPIECE.getItem())),
              new BookPageText("research.Exosuit.name", "research.Exosuit.1"),
              new BookPageCrafting("", "engineering1", "engineering2"),
              new BookPageCrafting("", "exoHead"),
              new BookPageCrafting("", "exoBody"),
              new BookPageCrafting("", "exoLegs"),
              new BookPageCrafting("", "exoFeet")
            );
            ItemStack[] stacks = new ItemStack[4];
            for (int i = 0; i < 4; i++) {
                ItemStack stack = new ItemStack(EXOSUIT_CHESTPIECE.getItem());
                stack.setTagCompound(new NBTTagCompound());
                ItemStack plate = null;
                Collection<ExosuitPlate> values = SteamcraftRegistry.plates.values();
                Object item = values.toArray(new ExosuitPlate[values.size()])[i].getItem();
                if (item instanceof String) {
                    if (OreDictionary.getOres((String) item).size() > 0) {
                        plate = OreDictionary.getOres((String) item).get(0);
                    }
                } else if (item instanceof ItemStack) {
                    plate = (ItemStack) item;
                }
                ((ItemExosuitArmor) stack.getItem()).setInventorySlotContents(stack, 1, plate);
                stacks[i] = stack;
            }
            SteamcraftRegistry.addResearch("research.ExoTank.name", "category.Exosuit.name",
              new BookPageItem("research.ExoTank.name", "research.ExoTank.0", new ItemStack(TANK.getBlock())));
            SteamcraftRegistry.addResearch("research.ExoTankBase.name", "!research.ExoTank.name",
              new BookPageItem("research.ExoTankBase.name", "research.ExoTankBase.0", true, new ItemStack(TANK.getBlock())));
            if (Config.enableReinforcedTank) {
                SteamcraftRegistry.addResearch("research.ExoTankReinforced.name", "!research.ExoTank.name",
                  new BookPageItem("research.ExoTankReinforced.name", "research.ExoTankReinforced.0", true,
                    new ItemStack(REINFORCED_TANK.getItem())),
                  new BookPageCrafting("", "reinforcedTank1", "reinforcedTank2"));
            }
            if (Config.enableUberReinforcedTank) {
                SteamcraftRegistry.addResearch("research.ExoTankUberReinforced.name", "!research.ExoTank.name",
                  new BookPageItem("research.ExoTankUberReinforced.name", "research.ExoTankUberReinforced.0", true,
                    new ItemStack(UBER_REINFORCED_TANK.getItem())),
                  new BookPageCrafting("", "uberReinforcedTank1", "uberReinforcedTank2"));
            }

            SteamcraftRegistry.addResearch("research.ExoPlates.name", "category.Exosuit.name",
              new BookPageItem("research.ExoPlates.name", "research.ExoPlates.0", stacks),
              new BookPageText("", "research.ExoPlates.1"));

            if (Config.enableCopperPlate) {
                SteamcraftRegistry.addResearch("research.PlateCopper.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateCopper.name", "research.PlateCopper.0", true, COPPER_EXO.createItemStack()),
                  new BookPageCrafting("", "exoCopper"));
            }
            if (Config.enableIronPlate) {
                SteamcraftRegistry.addResearch("research.PlateIron.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateIron.name", "research.PlateIron.0", true, IRON_EXO.createItemStack()),
                  new BookPageCrafting("", "exoIron"));
            }
            if (Config.enableBrassPlate) {
                SteamcraftRegistry.addResearch("research.PlateBrass.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateBrass.name", "research.PlateBrass.0", true, BRASS_EXO.createItemStack()),
                  new BookPageCrafting("", "exoBrass"));
            }
            if (Config.enableGoldPlate) {
                SteamcraftRegistry.addResearch("research.PlateGold.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateGold.name", "research.PlateGold.0", true, GOLD_EXO.createItemStack()),
                  new BookPageCrafting("", "exoGold"));
            }
            if (Config.enableGildedIronPlate) {
                SteamcraftRegistry.addResearch("research.PlateGilded.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateGilded.name", "research.PlateGilded.0", true, GILDED_IRON_EXO.createItemStack()),
                  new BookPageCrafting("", "exoGildedIron"));
            }
            if (Config.enableLeadPlate && OreDictionary.getOres("ingotLead").size() > 0) {
                SteamcraftRegistry.addResearch("research.PlateLead.name", "!research.ExoPlates.name",
                  new BookPageItem("research.PlateLead.name", "research.PlateLead.0", true, LEAD_EXO.createItemStack()),
                  new BookPageCrafting("", "exoLead"));
            }
            ItemStack[] stacks2 = new ItemStack[4];
            for (int i = 0; i < 4; i++) {
                ItemStack stack = new ItemStack(EXOSUIT_CHESTPIECE.getItem());
                stack.setTagCompound(new NBTTagCompound());
                ItemStack dye = new ItemStack(Items.DYE, 1, i);
                ((ItemExosuitArmor) stack.getItem()).setInventorySlotContents(stack, 2, dye);
                stacks2[i] = stack;
            }
            SteamcraftRegistry.addResearch("research.ExoVanity.name", "category.Exosuit.name",
              new BookPageItem("research.ExoVanity.name", "research.ExoVanity.0", stacks2));
            SteamcraftRegistry.addResearch("research.ExoDyes.name", "!research.ExoVanity.name",
              new BookPageItem("research.ExoDyes.name", "research.ExoDyes.0", true,
                new ItemStack(Items.DYE, 1, 0), new ItemStack(Items.DYE, 1, 1), new ItemStack(Items.DYE, 1, 2),
                new ItemStack(Items.DYE, 1, 3)));
            if (Config.enableEnderShroud) {
                SteamcraftRegistry.addResearch("research.EnderShroud.name", "!research.ExoVanity.name",
                  new BookPageItem("research.EnderShroud.name", "research.EnderShroud.0", true, new ItemStack(ENDER_SHROUD.getItem())),
                  new BookPageCrafting("", "enderShroud"));
            }
            SteamcraftRegistry.addResearch("research.ExoHeadHelm.name", "category.Exosuit.name");
            if (Config.enableTopHat) {
                SteamcraftRegistry.addResearch("research.ExoTopHat.name", "!research.ExoHeadHelm.name",
                  new BookPageItem("research.ExoTopHat.name", "research.ExoTopHat.0", true,
                    new ItemStack(TOP_HAT.getItem()), new ItemStack(ENTREPRENEUR_TOP_HAT.getItem())),
                  new BookPage(""));
            }
            if (Config.enableFrequencyShifter) {
                SteamcraftRegistry.addResearch(
                  "research.FrequencyShifter.name",
                  "!research.ExoHeadHelm.name",
                  new BookPageItem("research.FrequencyShifter.name", "research.FrequencyShifter.0",
                    true, new ItemStack(FREQUENCY_SHIFTER.getItem())),
                  new BookPageCrafting("", "frequencyShifter")
                );
            }

            SteamcraftRegistry.addResearch("research.ExoHeadGoggle.name", "category.Exosuit.name");
            if (Config.enableGoggles) {
                SteamcraftRegistry.addResearch("research.ExoGoggles.name", "!research.ExoHeadGoggle.name",
                  new BookPageItem("research.ExoGoggles.name", "research.ExoGoggles.0", true,
                    new ItemStack(GOGGLES.getItem()), new ItemStack(MONOCLE.getItem())),
                  new BookPage(""));
            }
            if (Config.enableRebreather) {
                SteamcraftRegistry.addResearch(
                  "research.Rebreather.name",
                  "!research.ExoHeadGoggle.name",
                  new BookPageItem("research.Rebreather.name", "research.Rebreather.0", true, new ItemStack(REBREATHER.getItem())),
                  new BookPageCrafting("", "rebreather")
                );
            }
            if (Config.enableDragonRoar) {
                SteamcraftRegistry.addResearch(
                  "research.DragonRoar.name",
                  "!research.ExoHeadGoggle.name",
                  new BookPageItem("research.DragonRoar.name", "research.DragonRoar.0", true, new ItemStack(DRAGON_ROAR.getItem())),
                  new BookPageCrafting("", "dragonRoar")
                );
            }

            SteamcraftRegistry.addResearch("research.ExoBack.name", "category.Exosuit.name");
            if (Config.enableJetpack) {
                SteamcraftRegistry.addResearch("research.Jetpack.name", "!research.ExoBack.name",
                  new BookPageItem("research.Jetpack.name", "research.Jetpack.0", true, new ItemStack(JETPACK.getItem())),
                  new BookPageCrafting("", "jetpack1", "jetpack2"));
            }
            if (Config.enableWings) {
                SteamcraftRegistry.addResearch("research.Wings.name", "!research.ExoBack.name",
                  new BookPageItem("research.Wings.name", "research.Wings.0", true, new ItemStack(WINGS.getItem())),
                  new BookPageCrafting("", "wings1", "wings2"));
            }

            SteamcraftRegistry.addResearch("research.ExoArm.name", "category.Exosuit.name");
            if (Config.enablePowerFist) {
                SteamcraftRegistry.addResearch("research.Fist.name", "!research.ExoArm.name",
                  new BookPageItem("research.Fist.name", "research.Fist.0", true, new ItemStack(POWER_FIST.getItem())),
                  new BookPageCrafting("", "powerFist1", "powerFist2"));
            }
            if (Config.enableExtendoFist) {
                SteamcraftRegistry.addResearch("research.ExtendoFist.name", "!research.ExoArm.name",
                  new BookPageItem("research.ExtendoFist.name", "research.ExtendoFist.0", true, new ItemStack(EXTENDO_FIST.getItem())),
                  new BookPageCrafting("", "extendoFist1", "extendoFist2"));
            }
            if (Config.enablePitonDeployer) {
                SteamcraftRegistry.addResearch("research.PitonDeployer.name", "!research.ExoArm.name",
                  new BookPageItem("research.PitonDeployer.name", "research.PitonDeployer.0", true, new ItemStack(PITON_DEPLOYER.getItem())),
                  new BookPageCrafting("", "pitonDeployer"));
            }
            if (Config.enablePistonPush) {
                SteamcraftRegistry.addResearch(
                  "research.PistonPush.name",
                  "!research.ExoArm.name",
                  new BookPageItem("research.PistonPush.name", "research.PistonPush.0", true, new ItemStack(PISTON_PUSH.getItem())),
                  new BookPageCrafting("", "pistonPush")
                );
            }

            SteamcraftRegistry.addResearch("research.ExoHip.name", "category.Exosuit.name");
            if (Config.enableThrusters) {
                SteamcraftRegistry.addResearch("research.Thrusters.name", "!research.ExoHip.name",
                  new BookPageItem("research.Thrusters.name", "research.Thrusters.0", true, new ItemStack(THRUSTERS.getItem())),
                  new BookPageCrafting("", "thrusters1", "thrusters2"));
            }
            if (Config.enableCanningMachine) {
                SteamcraftRegistry.addResearch("research.Canner.name", "!research.ExoHip.name",
                  new BookPageItem("research.Canner.name", "research.Canner.0", true, new ItemStack(CANNING_MACHINE.getItem())),
                  new BookPageCrafting("", "canner1", "canner2", "canner3", "canner4"));
            }
            if (Config.enableReloadingHolsters) {
                SteamcraftRegistry.addResearch("research.ReloadingHolsters.name", "!research.ExoHip.name",
                  new BookPageItem("research.ReloadingHolsters.name", "research.ReloadingHolsters.0", true, new ItemStack(RELOADING_HOLSTERS.getItem())),
                  new BookPageCrafting("", "reloadingHolsters")
                );
            }

            SteamcraftRegistry.addResearch("research.ExoLeg.name", "category.Exosuit.name");
            if (Config.enableRunAssist) {
                SteamcraftRegistry.addResearch("research.RunAssist.name", "!research.ExoLeg.name",
                  new BookPageItem("research.RunAssist.name", "research.RunAssist.0", true, new ItemStack(RUN_ASSIST.getItem())),
                  new BookPageCrafting("", "runAssist1", "runAssist2"));
            }
            if (Config.enableStealthUpgrade) {
                SteamcraftRegistry.addResearch("research.StealthUpgrade.name", "!research.ExoLeg.name",
                  new BookPageItem("research.StealthUpgrade.name", "research.StealthUpgrade.0", true, new ItemStack(STEALTH.getItem())),
                  new BookPageCrafting("", "stealthUpgrade"));
            }
            SteamcraftRegistry.addResearch("research.ExoHeel.name", "category.Exosuit.name");
            if (Config.enableFallAssist) {
                SteamcraftRegistry.addResearch("research.FallAssist.name", "!research.ExoHeel.name",
                  new BookPageItem("research.FallAssist.name", "research.FallAssist.0", true, new ItemStack(FALL_ASSIST.getItem())),
                  new BookPageCrafting("", "noFall"));
            }
            if (Config.enableAnchorHeels) {
                boolean lead = Config.enableLeadPlate &&
                  OreDictionary.getOres("ingotLead").size() > 0 && !Config.enableAnchorAnvilRecipe;
                String research = lead ? "research.AnchorHeelsLead.0" : "research.AnchorHeelsIron.0";
                SteamcraftRegistry.addResearch("research.AnchorHeels.name", "!research.ExoHeel.name",
                  new BookPageItem("research.AnchorHeels.name", research, true, new ItemStack(ANCHOR_HEELS.getItem())),
                  new BookPageCrafting("", "anchorHeels"));
            }
            SteamcraftRegistry.addResearch("research.ExoFoot.name", "category.Exosuit.name");
            if (Config.enableDoubleJump) {
                SteamcraftRegistry.addResearch("research.DoubleJump.name", "!research.ExoFoot.name",
                  new BookPageItem("research.DoubleJump.name", "research.DoubleJump.0", true, new ItemStack(DOUBLE_JUMP.getItem())),
                  new BookPageCrafting("", "doubleJump1", "doubleJump2"));
            }
            if (Config.enableHydrophobic) {
                SteamcraftRegistry.addResearch("research.Hydrophobic.name", "!research.ExoFoot.name",
                  new BookPageItem("research.Hydrophobic.name", "research.Hydrophobic.0", true, new ItemStack(HYDROPHOBIC_COATINGS.getItem())),
                  new BookPageCrafting("", "hydrophobic")
                );
            }
            if (Config.enablePyrophobic) {
                SteamcraftRegistry.addResearch("research.Pyrophobic.name", "!research.ExoFoot.name",
                  new BookPageItem("research.Pyrophobic.name", "research.Pyrophobic.0", true, new ItemStack(PYROPHOBIC_COATINGS.getItem())),
                  new BookPageCrafting("", "pyrophobic")
                );
            }
            if (Config.enableJumpAssist) {
                SteamcraftRegistry.addResearch("research.JumpAssist.name", "!research.ExoFoot.name",
                  new BookPageItem("research.JumpAssist.name", "research.JumpAssist.0", true, new ItemStack(JUMP_ASSIST.getItem())),
                  new BookPageCrafting("", "jumpAssist1", "jumpAssist2"));
            }
        }
    }
}
(*
Copyright (2010-2014) INCUBAID BVBA

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*)


type t = int64

let stamp_to buffer (t:t) = Llio.int64_to buffer t

let input_stamp ic = Llio.input_int64 ic

let to_s = Int64.to_string

let (<=) i j = Int64.compare i j <= 0
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2001, Eric D. Friedman All Rights Reserved.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
///////////////////////////////////////////////////////////////////////////////

package gnu.trove.iterator;

//////////////////////////////////////////////////
// THIS IS A GENERATED CLASS. DO NOT HAND EDIT! //
//////////////////////////////////////////////////


/**
 * Iterator for long collections.
 */
public interface TLongIterator extends TIterator {
    /**
     * Advances the iterator to the next element in the underlying collection
     * and returns it.
     *
     * @return the next long in the collection
     * @exception NoSuchElementException if the iterator is already exhausted
     */
    public long next();
}
/**
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package rx;

import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import rx.Single.OnSubscribe;
import rx.exceptions.*;
import rx.functions.*;
import rx.observers.*;
import rx.plugins.RxJavaHooks;
import rx.schedulers.*;
import rx.singles.BlockingSingle;
import rx.subjects.PublishSubject;
import rx.subscriptions.Subscriptions;

public class SingleTest {

    @SuppressWarnings("rawtypes")
    private Func1<Single.OnSubscribe, Single.OnSubscribe> onCreate;
    
    @SuppressWarnings("rawtypes")
    private Func2<Single, Observable.OnSubscribe, Observable.OnSubscribe> onStart;

    private Func1<Subscription, Subscription> onReturn;

    @SuppressWarnings("rawtypes")
    @Before
    public void setUp() throws Exception {
        onCreate = spy(new Func1<Single.OnSubscribe, Single.OnSubscribe>() {
            @Override
            public Single.OnSubscribe call(Single.OnSubscribe t) {
                return t;
            }
        });
        
        RxJavaHooks.setOnSingleCreate(onCreate);
        
        onStart = spy(new Func2<Single, Observable.OnSubscribe, Observable.OnSubscribe>() {
            @Override
            public Observable.OnSubscribe call(Single t1, Observable.OnSubscribe t2) {
                return t2;
            }
        });
        
        RxJavaHooks.setOnSingleStart(onStart);
        
        onReturn = spy(new Func1<Subscription, Subscription>() {
            @Override
            public Subscription call(Subscription t) {
                return t;
            }
        });
        
        RxJavaHooks.setOnSingleReturn(onReturn);
    }
    
    @After
    public void after() {
        RxJavaHooks.reset();
    }

    @Test
    public void testHelloWorld() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.just("Hello World!").subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("Hello World!"));
    }

    @Test
    public void testHelloWorld2() {
        final AtomicReference<String> v = new AtomicReference<String>();
        Single.just("Hello World!").subscribe(new SingleSubscriber<String>() {

            @Override
            public void onSuccess(String value) {
                v.set(value);
            }

            @Override
            public void onError(Throwable error) {

            }

        });
        assertEquals("Hello World!", v.get());
    }

    @Test
    public void testMap() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.just("A")
                .map(new Func1<String, String>() {

                    @Override
                    public String call(String s) {
                        return s + "B";
                    }

                })
                .subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("AB"));
    }

    @Test
    public void zip2Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);

        Single.zip(a, b, new Func2<Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b) {
                return "" + a + b;
            }

        })
                .subscribe(ts);

        ts.assertValue("12");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip3Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);

        Single.zip(a, b, c, new Func3<Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c) {
                return "" + a + b + c;
            }

        })
                .subscribe(ts);

        ts.assertValue("123");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip4Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);

        Single.zip(a, b, c, d, new Func4<Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d) {
                return "" + a + b + c + d;
            }

        })
                .subscribe(ts);

        ts.assertValue("1234");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip5Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);
        Single<Integer> e = Single.just(5);

        Single.zip(a, b, c, d, e, new Func5<Integer, Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d, Integer e) {
                return "" + a + b + c + d + e;
            }

        })
                .subscribe(ts);

        ts.assertValue("12345");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip6Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);
        Single<Integer> e = Single.just(5);
        Single<Integer> f = Single.just(6);

        Single.zip(a, b, c, d, e, f, new Func6<Integer, Integer, Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f) {
                return "" + a + b + c + d + e + f;
            }

        })
                .subscribe(ts);

        ts.assertValue("123456");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip7Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);
        Single<Integer> e = Single.just(5);
        Single<Integer> f = Single.just(6);
        Single<Integer> g = Single.just(7);

        Single.zip(a, b, c, d, e, f, g, new Func7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g) {
                return "" + a + b + c + d + e + f + g;
            }

        })
                .subscribe(ts);

        ts.assertValue("1234567");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip8Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);
        Single<Integer> e = Single.just(5);
        Single<Integer> f = Single.just(6);
        Single<Integer> g = Single.just(7);
        Single<Integer> h = Single.just(8);

        Single.zip(a, b, c, d, e, f, g, h, new Func8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g, Integer h) {
                return "" + a + b + c + d + e + f + g + h;
            }

        })
                .subscribe(ts);

        ts.assertValue("12345678");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zip9Singles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<Integer> a = Single.just(1);
        Single<Integer> b = Single.just(2);
        Single<Integer> c = Single.just(3);
        Single<Integer> d = Single.just(4);
        Single<Integer> e = Single.just(5);
        Single<Integer> f = Single.just(6);
        Single<Integer> g = Single.just(7);
        Single<Integer> h = Single.just(8);
        Single<Integer> i = Single.just(9);

        Single.zip(a, b, c, d, e, f, g, h, i, new Func9<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, String>() {

            @Override
            public String call(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g, Integer h, Integer i) {
                return "" + a + b + c + d + e + f + g + h + i;
            }

        })
                .subscribe(ts);

        ts.assertValue("123456789");
        ts.assertCompleted();
        ts.assertNoErrors();
    }

    @Test
    public void zipIterableShouldZipListOfSingles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        @SuppressWarnings("unchecked")
        Iterable<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(2), Single.just(3));

        Single
                .zip(singles, new FuncN<String>() {
                    @Override
                    public String call(Object... args) {
                        StringBuilder stringBuilder = new StringBuilder();
                        for (Object arg : args) {
                            stringBuilder.append(arg);
                        }
                        return stringBuilder.toString();
                    }
                }).subscribe(ts);

        ts.assertValue("123");
        ts.assertNoErrors();
        ts.assertCompleted();
    }

    @Test
    public void zipIterableShouldZipSetOfSingles() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Set<Single<String>> singlesSet = Collections.newSetFromMap(new LinkedHashMap<Single<String>, Boolean>(2));
        Single<String> s1 = Single.just("1");
        Single<String> s2 = Single.just("2");
        Single<String> s3 = Single.just("3");

        singlesSet.add(s1);
        singlesSet.add(s2);
        singlesSet.add(s3);

        Single
                .zip(singlesSet, new FuncN<String>() {
                    @Override
                    public String call(Object... args) {
                        StringBuilder stringBuilder = new StringBuilder();
                        for (Object arg : args) {
                            stringBuilder.append(arg);
                        }
                        return stringBuilder.toString();
                    }
                }).subscribe(ts);

        ts.assertValue("123");
        ts.assertNoErrors();
        ts.assertCompleted();
    }

    @Test
    public void zipEmptyIterableShouldThrow() {
        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
        Iterable<Single<Object>> singles = Collections.emptyList();

        Single
                .zip(singles, new FuncN<Object>() {
                    @Override
                    public Object call(Object... args) {
                        throw new IllegalStateException("Should not be called");
                    }
                })
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertNotCompleted();
        testSubscriber.assertError(NoSuchElementException.class);
        assertEquals("Can't zip 0 Singles.", testSubscriber.getOnErrorEvents().get(0).getMessage());
    }

    @Test
    public void testZipWith() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single.just("A").zipWith(Single.just("B"), new Func2<String, String, String>() {

            @Override
            public String call(String a, String b) {
                return a + b;
            }

        })
                .subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("AB"));
    }

    @Test
    public void testMerge() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<String> a = Single.just("A");
        Single<String> b = Single.just("B");

        Single.merge(a, b).subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("A", "B"));
    }

    @Test
    public void testMergeWith() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single.just("A").mergeWith(Single.just("B")).subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("A", "B"));
    }

    @Test
    public void testHookCreate() {
        @SuppressWarnings("unchecked")
        OnSubscribe<Object> subscriber = mock(OnSubscribe.class);
        Single.create(subscriber);

        verify(onCreate, times(1)).call(subscriber);
    }

    @Test
    public void testHookSubscribeStart() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single<String> single = Single.create(new OnSubscribe<String>() {
            @Override public void call(SingleSubscriber<? super String> s) {
                s.onSuccess("Hello");
            }
        });
        single.subscribe(ts);

        verify(onStart, times(1)).call(eq(single), any(Observable.OnSubscribe.class));
    }

    @Test
    public void testHookUnsafeSubscribeStart() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<String> single = Single.create(new OnSubscribe<String>() {
            @Override public void call(SingleSubscriber<? super String> s) {
                s.onSuccess("Hello");
            }
        });
        single.unsafeSubscribe(ts);

        verify(onStart, times(1)).call(eq(single), any(Observable.OnSubscribe.class));
    }

    @Test
    public void testHookSubscribeReturn() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single<String> single = Single.create(new OnSubscribe<String>() {
            @Override public void call(SingleSubscriber<? super String> s) {
                s.onSuccess("Hello");
            }
        });
        single.subscribe(ts);

        verify(onReturn, times(1)).call(any(SafeSubscriber.class));
    }

    @Test
    public void testHookUnsafeSubscribeReturn() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single<String> single = Single.create(new OnSubscribe<String>() {
            @Override public void call(SingleSubscriber<? super String> s) {
                s.onSuccess("Hello");
            }
        });
        single.unsafeSubscribe(ts);

        verify(onReturn, times(1)).call(ts);
    }

    @Test
    public void testReturnUnsubscribedWhenHookThrowsError() {
        TestSubscriber<String> ts = new TestSubscriber<String>();

        Single<String> single = Single.create(new OnSubscribe<String>() {
            @Override public void call(SingleSubscriber<? super String> s) {
                throw new RuntimeException("Exception");
            }
        });
        Subscription subscription = single.unsafeSubscribe(ts);

        assertTrue(subscription.isUnsubscribed());
    }

    @Test
    public void testCreateSuccess() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.create(new OnSubscribe<String>() {

            @Override
            public void call(SingleSubscriber<? super String> s) {
                s.onSuccess("Hello");
            }

        }).subscribe(ts);
        ts.assertReceivedOnNext(Arrays.asList("Hello"));
    }

    @Test
    public void testCreateError() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.create(new OnSubscribe<String>() {

            @Override
            public void call(SingleSubscriber<? super String> s) {
                s.onError(new RuntimeException("fail"));
            }

        }).subscribe(ts);
        assertEquals(1, ts.getOnErrorEvents().size());
    }

    @Test
    public void testAsync() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.just("Hello")
                .subscribeOn(Schedulers.io())
                .map(new Func1<String, String>() {

                    @Override
                    public String call(String v) {
                        System.out.println("SubscribeOn Thread: " + Thread.currentThread());
                        return v;
                    }

                })
                .observeOn(Schedulers.computation())
                .map(new Func1<String, String>() {

                    @Override
                    public String call(String v) {
                        System.out.println("ObserveOn Thread: " + Thread.currentThread());
                        return v;
                    }

                })
                .subscribe(ts);
        ts.awaitTerminalEvent();
        ts.assertReceivedOnNext(Arrays.asList("Hello"));
    }

    @Test
    public void testFlatMap() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single.just("Hello").flatMap(new Func1<String, Single<String>>() {

            @Override
            public Single<String> call(String s) {
                return Single.just(s + " World!").subscribeOn(Schedulers.computation());
            }

        }).subscribe(ts);
        ts.awaitTerminalEvent();
        ts.assertReceivedOnNext(Arrays.asList("Hello World!"));
    }

    @Test
    public void testTimeout() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(SingleSubscriber<? super String> s) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    // ignore as we expect this for the test
                }
                s.onSuccess("success");
            }

        }).subscribeOn(Schedulers.io());

        s.timeout(100, TimeUnit.MILLISECONDS).subscribe(ts);

        ts.awaitTerminalEvent();
        ts.assertError(TimeoutException.class);
    }

    @Test
    public void testTimeoutWithFallback() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(SingleSubscriber<? super String> s) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    // ignore as we expect this for the test
                }
                s.onSuccess("success");
            }

        }).subscribeOn(Schedulers.io());

        s.timeout(100, TimeUnit.MILLISECONDS, Single.just("hello")).subscribe(ts);

        ts.awaitTerminalEvent();
        ts.assertNoErrors();
        ts.assertValue("hello");
    }

    @Test
    public void testToBlocking() {
        Single<String> s = Single.just("one");
        BlockingSingle<String> blocking = s.toBlocking();
        assertNotNull(blocking);
        assertEquals("one", blocking.value());
    }

    @Test
    public void testUnsubscribe() throws InterruptedException {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final AtomicBoolean interrupted = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(2);

        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(final SingleSubscriber<? super String> s) {
                final Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            Thread.sleep(5000);
                            s.onSuccess("success");
                        } catch (InterruptedException e) {
                            interrupted.set(true);
                            latch.countDown();
                        }
                    }

                });
                s.add(Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        unsubscribed.set(true);
                        t.interrupt();
                        latch.countDown();
                    }

                }));
                t.start();
            }

        });

        s.subscribe(ts);

        Thread.sleep(100);

        ts.unsubscribe();

        if (latch.await(1000, TimeUnit.MILLISECONDS)) {
            assertTrue(unsubscribed.get());
            assertTrue(interrupted.get());
        } else {
            fail("timed out waiting for latch");
        }
    }

    /**
     * Assert that unsubscribe propagates when passing in a SingleSubscriber and not a Subscriber
     * @throws InterruptedException on interrupt
     */
    @Test
    public void testUnsubscribe2() throws InterruptedException {
        SingleSubscriber<String> ts = new SingleSubscriber<String>() {

            @Override
            public void onSuccess(String value) {
                // not interested in value
            }

            @Override
            public void onError(Throwable error) {
                // not interested in value
            }

        };
        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final AtomicBoolean interrupted = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(2);

        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(final SingleSubscriber<? super String> s) {
                final Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            Thread.sleep(5000);
                            s.onSuccess("success");
                        } catch (InterruptedException e) {
                            interrupted.set(true);
                            latch.countDown();
                        }
                    }

                });
                s.add(Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        unsubscribed.set(true);
                        t.interrupt();
                        latch.countDown();
                    }

                }));
                t.start();
            }

        });

        s.subscribe(ts);

        Thread.sleep(100);

        ts.unsubscribe();

        if (latch.await(1000, TimeUnit.MILLISECONDS)) {
            assertTrue(unsubscribed.get());
            assertTrue(interrupted.get());
        } else {
            fail("timed out waiting for latch");
        }
    }

    /**
     * Assert that unsubscribe propagates when passing in a SingleSubscriber and not a Subscriber
     * @throws InterruptedException on interrupt
     */
    @Test
    public void testUnsubscribeViaReturnedSubscription() throws InterruptedException {
        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final AtomicBoolean interrupted = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(2);

        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(final SingleSubscriber<? super String> s) {
                final Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            Thread.sleep(5000);
                            s.onSuccess("success");
                        } catch (InterruptedException e) {
                            interrupted.set(true);
                            latch.countDown();
                        }
                    }

                });
                s.add(Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        unsubscribed.set(true);
                        t.interrupt();
                        latch.countDown();
                    }

                }));
                t.start();
            }

        });

        Subscription subscription = s.subscribe();

        Thread.sleep(100);

        subscription.unsubscribe();

        if (latch.await(1000, TimeUnit.MILLISECONDS)) {
            assertTrue(unsubscribed.get());
            assertTrue(interrupted.get());
        } else {
            fail("timed out waiting for latch");
        }
    }

    @Test
    public void testBackpressureAsObservable() {
        Single<String> s = Single.create(new OnSubscribe<String>() {

            @Override
            public void call(SingleSubscriber<? super String> t) {
                t.onSuccess("hello");
            }
        });

        TestSubscriber<String> ts = new TestSubscriber<String>() {
            @Override
            public void onStart() {
                request(0);
            }
        };

        s.subscribe(ts);

        ts.assertNoValues();

        ts.requestMore(1);

        ts.assertValue("hello");
    }

    @Test
    public void testToObservable() {
        Observable<String> a = Single.just("a").toObservable();
        TestSubscriber<String> ts = TestSubscriber.create();
        a.subscribe(ts);
        ts.assertValue("a");
        ts.assertCompleted();
    }

    @Test
    public void toCompletableSuccess() {
        Completable completable = Single.just("value").toCompletable();
        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
        completable.unsafeSubscribe(testSubscriber);

        testSubscriber.assertCompleted();
        testSubscriber.assertNoValues();
        testSubscriber.assertNoErrors();
    }

    @Test
    public void toCompletableError() {
        TestException exception = new TestException();
        Completable completable = Single.error(exception).toCompletable();
        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
        completable.unsafeSubscribe(testSubscriber);

        testSubscriber.assertError(exception);
        testSubscriber.assertNoValues();
        testSubscriber.assertNotCompleted();
    }

    @Test
    public void doOnErrorShouldNotCallActionIfNoErrorHasOccurred() {
        @SuppressWarnings("unchecked")
        Action1<Throwable> action = mock(Action1.class);

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("value")
                .doOnError(action)
                .subscribe(testSubscriber);

        testSubscriber.assertValue("value");
        testSubscriber.assertNoErrors();

        verifyZeroInteractions(action);
    }

    @Test
    public void doOnErrorShouldCallActionIfErrorHasOccurred() {
        @SuppressWarnings("unchecked")
        Action1<Throwable> action = mock(Action1.class);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Throwable error = new IllegalStateException();

        Single
                .error(error)
                .doOnError(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verify(action).call(error);
    }

    @Test
    public void doOnErrorShouldThrowCompositeExceptionIfOnErrorActionThrows() {
        @SuppressWarnings("unchecked")
        Action1<Throwable> action = mock(Action1.class);


        Throwable error = new RuntimeException();
        Throwable exceptionFromOnErrorAction = new IllegalStateException();
        doThrow(exceptionFromOnErrorAction).when(action).call(error);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .error(error)
                .doOnError(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        CompositeException compositeException = (CompositeException) testSubscriber.getOnErrorEvents().get(0);

        assertEquals(2, compositeException.getExceptions().size());
        assertSame(error, compositeException.getExceptions().get(0));
        assertSame(exceptionFromOnErrorAction, compositeException.getExceptions().get(1));

        verify(action).call(error);
    }

    @Test
    public void shouldEmitValueFromCallable() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<String> callable = mock(Callable.class);

        when(callable.call()).thenReturn("value");

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .fromCallable(callable)
                .subscribe(testSubscriber);

        testSubscriber.assertValue("value");
        testSubscriber.assertNoErrors();

        verify(callable).call();
    }

    @Test
    public void shouldPassErrorFromCallable() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<String> callable = mock(Callable.class);

        Throwable error = new IllegalStateException();

        when(callable.call()).thenThrow(error);

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .fromCallable(callable)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verify(callable).call();
    }

    @Test
    public void doOnSuccessShouldInvokeAction() {
        @SuppressWarnings("unchecked")
        Action1<String> action = mock(Action1.class);

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("value")
                .doOnSuccess(action)
                .subscribe(testSubscriber);

        testSubscriber.assertValue("value");
        testSubscriber.assertNoErrors();

        verify(action).call(eq("value"));
    }

    @Test
    public void doOnSuccessShouldPassErrorFromActionToSubscriber() {
        @SuppressWarnings("unchecked")
        Action1<String> action = mock(Action1.class);

        Throwable error = new IllegalStateException();
        doThrow(error).when(action).call(eq("value"));

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("value")
                .doOnSuccess(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verify(action).call(eq("value"));
    }

    @Test
    public void doOnSuccessShouldNotCallActionIfSingleThrowsError() {
        @SuppressWarnings("unchecked")
        Action1<Object> action = mock(Action1.class);

        Throwable error = new IllegalStateException();

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .error(error)
                .doOnSuccess(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verifyZeroInteractions(action);
    }

    @Test
    public void doOnSuccessShouldNotSwallowExceptionThrownByAction() {
        @SuppressWarnings("unchecked")
        Action1<String> action = mock(Action1.class);

        Throwable exceptionFromAction = new IllegalStateException();

        doThrow(exceptionFromAction).when(action).call(eq("value"));

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("value")
                .doOnSuccess(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(exceptionFromAction);

        verify(action).call(eq("value"));
    }

    @Test
    public void doOnSubscribeShouldInvokeAction() {
        Action0 action = mock(Action0.class);
        Single<Integer> single = Single.just(1).doOnSubscribe(action);

        verifyZeroInteractions(action);

        single.subscribe();
        single.subscribe();

        verify(action, times(2)).call();
    }

    @Test
    public void doOnSubscribeShouldInvokeActionBeforeSubscriberSubscribes() {
        final List<String> callSequence = new ArrayList<String>(2);

        Single<Integer> single = Single.create(new OnSubscribe<Integer>() {
            @Override
            public void call(SingleSubscriber<? super Integer> singleSubscriber) {
                callSequence.add("onSubscribe");
                singleSubscriber.onSuccess(1);
            }
        }).doOnSubscribe(new Action0() {
            @Override
            public void call() {
                callSequence.add("doOnSubscribe");
            }
        });

        single.subscribe();

        assertEquals(2, callSequence.size());
        assertEquals("doOnSubscribe", callSequence.get(0));
        assertEquals("onSubscribe", callSequence.get(1));
    }

    @Test
    public void delayWithSchedulerShouldDelayCompletion() {
        TestScheduler scheduler = new TestScheduler();
        Single<Integer> single = Single.just(1).delay(100, TimeUnit.DAYS, scheduler);

        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();
        single.subscribe(subscriber);

        subscriber.assertNotCompleted();
        scheduler.advanceTimeBy(99, TimeUnit.DAYS);
        subscriber.assertNotCompleted();
        scheduler.advanceTimeBy(91, TimeUnit.DAYS);
        subscriber.assertCompleted();
        subscriber.assertValue(1);
    }

    @Test
    public void delayWithSchedulerShouldShortCutWithFailure() {
        TestScheduler scheduler = new TestScheduler();
        final RuntimeException expected = new RuntimeException();
        Single<Integer> single = Single.create(new OnSubscribe<Integer>() {
            @Override
            public void call(SingleSubscriber<? super Integer> singleSubscriber) {
                singleSubscriber.onSuccess(1);
                singleSubscriber.onError(expected);
            }
        }).delay(100, TimeUnit.DAYS, scheduler);

        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();
        single.subscribe(subscriber);

        subscriber.assertNotCompleted();
        scheduler.advanceTimeBy(99, TimeUnit.DAYS);
        subscriber.assertNotCompleted();
        scheduler.advanceTimeBy(91, TimeUnit.DAYS);
        subscriber.assertNoValues();
        subscriber.assertError(expected);
    }

    @Test
    public void deferShouldNotCallFactoryFuncUntilSubscriberSubscribes() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<Object>> singleFactory = mock(Callable.class);
        Single.defer(singleFactory);
        verifyZeroInteractions(singleFactory);
    }

    @Test
    public void deferShouldSubscribeSubscriberToSingleFromFactoryFuncAndEmitValue() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<Object>> singleFactory = mock(Callable.class);
        Object value = new Object();
        Single<Object> single = Single.just(value);

        when(singleFactory.call()).thenReturn(single);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .defer(singleFactory)
                .subscribe(testSubscriber);

        testSubscriber.assertValue(value);
        testSubscriber.assertNoErrors();

        verify(singleFactory).call();
    }

    @Test
    public void deferShouldSubscribeSubscriberToSingleFromFactoryFuncAndEmitError() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<Object>> singleFactory = mock(Callable.class);
        Throwable error = new IllegalStateException();
        Single<Object> single = Single.error(error);

        when(singleFactory.call()).thenReturn(single);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .defer(singleFactory)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verify(singleFactory).call();
    }

    @Test
    public void deferShouldPassErrorFromSingleFactoryToTheSubscriber() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<Object>> singleFactory = mock(Callable.class);
        Throwable errorFromSingleFactory = new IllegalStateException();
        when(singleFactory.call()).thenThrow(errorFromSingleFactory);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .defer(singleFactory)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(errorFromSingleFactory);

        verify(singleFactory).call();
    }

    @Test
    public void deferShouldCallSingleFactoryForEachSubscriber() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<String>> singleFactory = mock(Callable.class);

        String[] values = {"1", "2", "3"};
        @SuppressWarnings("unchecked")
        final Single<String>[] singles = new Single[] {Single.just(values[0]), Single.just(values[1]), Single.just(values[2])};

        final AtomicInteger singleFactoryCallsCounter = new AtomicInteger();

        when(singleFactory.call()).thenAnswer(new Answer<Single<String>>() {
            @Override
            public Single<String> answer(InvocationOnMock invocation) throws Throwable {
                return singles[singleFactoryCallsCounter.getAndIncrement()];
            }
        });

        Single<String> deferredSingle = Single.defer(singleFactory);

        for (int i = 0; i < singles.length; i++) {
            TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

            deferredSingle.subscribe(testSubscriber);

            testSubscriber.assertValue(values[i]);
            testSubscriber.assertNoErrors();
        }

        verify(singleFactory, times(3)).call();
    }

    @Test
    public void deferShouldPassNullPointerExceptionToTheSubscriberIfSingleFactoryIsNull() {
        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .defer(null)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(NullPointerException.class);
    }


    @Test
    public void deferShouldPassNullPointerExceptionToTheSubscriberIfSingleFactoryReturnsNull() throws Exception {
        @SuppressWarnings("unchecked")
        Callable<Single<Object>> singleFactory = mock(Callable.class);
        when(singleFactory.call()).thenReturn(null);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Single
                .defer(singleFactory)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(NullPointerException.class);

        verify(singleFactory).call();
    }

    @Test
    public void doOnUnsubscribeShouldInvokeActionAfterSuccess() {
        Action0 action = mock(Action0.class);

        Single<String> single = Single
                .just("test")
                .doOnUnsubscribe(action);

        verifyZeroInteractions(action);

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
        single.subscribe(testSubscriber);

        testSubscriber.assertValue("test");
        testSubscriber.assertCompleted();

        verify(action).call();
    }

    @Test
    public void doOnUnsubscribeShouldInvokeActionAfterError() {
        Action0 action = mock(Action0.class);

        Single<Object> single = Single
                .error(new RuntimeException("test"))
                .doOnUnsubscribe(action);

        verifyZeroInteractions(action);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
        single.subscribe(testSubscriber);

        testSubscriber.assertError(RuntimeException.class);
        assertEquals("test", testSubscriber.getOnErrorEvents().get(0).getMessage());

        verify(action).call();
    }

    @Test
    public void doOnUnsubscribeShouldInvokeActionAfterExplicitUnsubscription() {
        Action0 action = mock(Action0.class);

        Single<Object> single = Single
                .create(new OnSubscribe<Object>() {
                    @Override
                    public void call(SingleSubscriber<? super Object> singleSubscriber) {
                        // Broken Single that never ends itself (simulates long computation in one thread).
                    }
                })
                .doOnUnsubscribe(action);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
        Subscription subscription = single.subscribe(testSubscriber);

        verifyZeroInteractions(action);

        subscription.unsubscribe();
        verify(action).call();
        testSubscriber.assertNoValues();
        testSubscriber.assertNoTerminalEvent();
    }

    @Test
    public void doAfterTerminateActionShouldBeInvokedAfterOnSuccess() {
        Action0 action = mock(Action0.class);

        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("value")
                .doAfterTerminate(action)
                .subscribe(testSubscriber);

        testSubscriber.assertValue("value");
        testSubscriber.assertNoErrors();

        verify(action).call();
    }

    @Test
    public void doAfterTerminateActionShouldBeInvokedAfterOnError() {
        Action0 action = mock(Action0.class);

        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();

        Throwable error = new IllegalStateException();

        Single
                .error(error)
                .doAfterTerminate(action)
                .subscribe(testSubscriber);

        testSubscriber.assertNoValues();
        testSubscriber.assertError(error);

        verify(action).call();
    }

    @Test
    public void doAfterTerminateActionShouldNotBeInvokedUntilSubscriberSubscribes() {
        Action0 action = mock(Action0.class);

        Single
                .just("value")
                .doAfterTerminate(action);

        Single
                .error(new IllegalStateException())
                .doAfterTerminate(action);

        verifyZeroInteractions(action);
    }

    @Test
    public void onErrorResumeNextViaSingleShouldNotInterruptSuccessfulSingle() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("success")
                .onErrorResumeNext(Single.just("fail"))
                .subscribe(testSubscriber);

        testSubscriber.assertValue("success");
    }

    @Test
    public void onErrorResumeNextViaSingleShouldResumeWithPassedSingleInCaseOfError() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .<String> error(new RuntimeException("test exception"))
                .onErrorResumeNext(Single.just("fallback"))
                .subscribe(testSubscriber);

        testSubscriber.assertValue("fallback");
    }

    @Test
    public void onErrorResumeNextViaSingleShouldPreventNullSingle() {
        try {
            Single
                    .just("value")
                    .onErrorResumeNext((Single<String>) null);
            fail();
        } catch (NullPointerException expected) {
            assertEquals("resumeSingleInCaseOfError must not be null", expected.getMessage());
        }
    }

    @Test
    public void onErrorResumeNextViaFunctionShouldNotInterruptSuccessfulSingle() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .just("success")
                .onErrorResumeNext(new Func1<Throwable, Single<? extends String>>() {
                    @Override
                    public Single<? extends String> call(Throwable throwable) {
                        return Single.just("fail");
                    }
                })
                .subscribe(testSubscriber);

        testSubscriber.assertValue("success");
    }

    @Test
    public void onErrorResumeNextViaFunctionShouldResumeWithPassedSingleInCaseOfError() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();

        Single
                .<String> error(new RuntimeException("test exception"))
                .onErrorResumeNext(new Func1<Throwable, Single<? extends String>>() {
                    @Override
                    public Single<? extends String> call(Throwable throwable) {
                        return Single.just("fallback");
                    }
                })
                .subscribe(testSubscriber);

        testSubscriber.assertValue("fallback");
    }

    @Test
    public void onErrorResumeNextViaFunctionShouldPreventNullFunction() {
        try {
            Single
                    .just("value")
                    .onErrorResumeNext((Func1<Throwable, ? extends Single<? extends String>>) null);
            fail();
        } catch (NullPointerException expected) {
            assertEquals("resumeFunctionInCaseOfError must not be null", expected.getMessage());
        }
    }

    @Test
    public void onErrorResumeNextViaFunctionShouldFailIfFunctionReturnsNull() {
        try {
            Single
                    .error(new TestException())
                    .onErrorResumeNext(new Func1<Throwable, Single<? extends String>>() {
                        @Override
                        public Single<? extends String> call(Throwable throwable) {
                            return null;
                        }
                    })
                    .subscribe();

            fail();
        } catch (OnErrorNotImplementedException expected) {
            assertTrue(expected.getCause() instanceof NullPointerException);
        }
    }

    @Test(expected = NullPointerException.class)
    public void iterableToArrayShouldThrowNullPointerExceptionIfIterableNull() {
        Single.iterableToArray(null);
    }

    @Test
    public void iterableToArrayShouldConvertList() {
        @SuppressWarnings("unchecked")
        List<Single<String>> singlesList = Arrays.asList(Single.just("1"), Single.just("2"));

        Single<? extends String>[] singlesArray = Single.iterableToArray(singlesList);
        assertEquals(2, singlesArray.length);
        assertSame(singlesList.get(0), singlesArray[0]);
        assertSame(singlesList.get(1), singlesArray[1]);
    }

    @Test
    public void iterableToArrayShouldConvertSet() {
        // Just to trigger different path of the code that handles non-list iterables.
        Set<Single<String>> singlesSet = Collections.newSetFromMap(new LinkedHashMap<Single<String>, Boolean>(2));
        Single<String> s1 = Single.just("1");
        Single<String> s2 = Single.just("2");

        singlesSet.add(s1);
        singlesSet.add(s2);

        Single<? extends String>[] singlesArray = Single.iterableToArray(singlesSet);
        assertEquals(2, singlesArray.length);
        assertSame(s1, singlesArray[0]);
        assertSame(s2, singlesArray[1]);
    }

    @Test(timeout = 2000)
    public void testRetry() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
        final TestSubscriber<Integer> retryCounter = new TestSubscriber<Integer>();

        final int retryCount = 100;
        Callable<String> callable = new Callable<String>() {

            @Override
            public String call() throws Exception {
                int errors = retryCounter.getOnErrorEvents().size();
                if (errors < retryCount) {
                    Exception exception = new Exception();
                    retryCounter.onError(exception);
                    throw exception;
                }
                return null;
            }

        };

        Single.fromCallable(callable)
                .retry()
                .subscribe(testSubscriber);

        testSubscriber.assertCompleted();
        int numberOfErrors = retryCounter.getOnErrorEvents().size();
        assertEquals(retryCount, numberOfErrors);
    }

    @Test(timeout = 2000)
    public void testRetryWithCount() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
        final TestSubscriber<Integer> retryCounter = new TestSubscriber<Integer>();

        final int retryCount = 100;
        Callable<String> callable = new Callable<String>() {

            @Override
            public String call() throws Exception {
                int errors = retryCounter.getOnErrorEvents().size();
                if (errors < retryCount) {
                    Exception exception = new Exception();
                    retryCounter.onError(exception);
                    throw exception;
                }

                return null;
            }
        };

        Single.fromCallable(callable)
                .retry(retryCount)
                .subscribe(testSubscriber);

        testSubscriber.assertCompleted();
        int numberOfErrors = retryCounter.getOnErrorEvents().size();
        assertEquals(retryCount, numberOfErrors);
    }

    @Test
    public void testRetryWithPredicate() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
        final TestSubscriber<Integer> retryCounter = new TestSubscriber<Integer>();

        final int retryCount = 100;
        Callable<String> callable = new Callable<String>() {

            @Override
            public String call() throws Exception {
                int errors = retryCounter.getOnErrorEvents().size();
                if (errors < retryCount) {
                    IOException exception = new IOException();
                    retryCounter.onError(exception);
                    throw exception;
                }
                return null;
            }
        };

        Single.fromCallable(callable)
                .retry(new Func2<Integer, Throwable, Boolean>() {
                    @Override
                    public Boolean call(Integer integer, Throwable throwable) {
                        return throwable instanceof IOException;
                    }
                })
                .subscribe(testSubscriber);

        testSubscriber.assertCompleted();
        int numberOfErrors = retryCounter.getOnErrorEvents().size();
        assertEquals(retryCount, numberOfErrors);
    }

    @Test
    public void testRetryWhen() {
        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
        final TestSubscriber<Integer> retryCounter = new TestSubscriber<Integer>();

        final int retryCount = 100;

        Callable<String> callable = new Callable<String>() {

            @Override
            public String call() throws Exception {
                int errors = retryCounter.getOnErrorEvents().size();
                if (errors < retryCount) {
                    IOException exception = new IOException();
                    retryCounter.onError(exception);
                    throw exception;
                }
                return null;
            }
        };

        Single.fromCallable(callable)
                .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {
                    @Override
                    public Observable<?> call(Observable<? extends Throwable> observable) {

                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {
                            @Override
                            public Observable<?> call(Throwable throwable) {
                                return throwable instanceof IOException ? Observable.just(null) : Observable.error(throwable);
                            }
                        });
                    }
                })
                .subscribe(testSubscriber);

        int numberOfErrors = retryCounter.getOnErrorEvents().size();
        assertEquals(retryCount, numberOfErrors);
    }

    @Test
    public void takeUntilCompletableFires() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.toCompletable()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        until.onCompleted();

        ts.assertError(CancellationException.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilObservableFires() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1)).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        until.onNext(1);

        ts.assertError(CancellationException.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSingleFires() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1).toSingle()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        until.onNext(1);

        ts.assertError(CancellationException.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilObservableCompletes() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1)).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        until.onCompleted();

        ts.assertError(CancellationException.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceUnsubscribes_withCompletable() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.toCompletable()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        source.onNext(1);

        ts.assertValue(1);
        ts.assertNoErrors();
        ts.assertTerminalEvent();

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceUnsubscribes_withObservable() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        source.onNext(1);

        ts.assertValue(1);
        ts.assertNoErrors();
        ts.assertTerminalEvent();

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceUnsubscribes_withSingle() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1).toSingle()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        source.onNext(1);

        ts.assertValue(1);
        ts.assertNoErrors();
        ts.assertTerminalEvent();

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceErrorUnsubscribes_withCompletable() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.toCompletable()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        Exception e = new Exception();
        source.onError(e);

        ts.assertNoValues();
        ts.assertError(e);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceErrorUnsubscribes_withObservable() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        source.onError(new Throwable());

        ts.assertNoValues();
        ts.assertError(Throwable.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilSourceErrorUnsubscribes_withSingle() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1).toSingle()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        source.onError(new Throwable());

        ts.assertNoValues();
        ts.assertError(Throwable.class);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilError_withCompletable_shouldMatch() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.toCompletable()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        Exception e = new Exception();
        until.onError(e);

        ts.assertNoValues();
        ts.assertError(e);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilError_withObservable_shouldMatch() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.asObservable()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        Exception e = new Exception();
        until.onError(e);

        ts.assertNoValues();
        ts.assertError(e);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void takeUntilError_withSingle_shouldMatch() {
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> until = PublishSubject.create();

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

        source.take(1).toSingle().takeUntil(until.take(1).toSingle()).unsafeSubscribe(ts);

        assertTrue(source.hasObservers());
        assertTrue(until.hasObservers());

        Exception e = new Exception();
        until.onError(e);

        ts.assertNoValues();
        ts.assertError(e);

        assertFalse(source.hasObservers());
        assertFalse(until.hasObservers());
        assertFalse(ts.isUnsubscribed());
    }

    @Test
    public void subscribeWithObserver() {
        @SuppressWarnings("unchecked")
        Observer<Integer> o = mock(Observer.class);

        Single.just(1).subscribe(o);

        verify(o).onNext(1);
        verify(o).onCompleted();
        verify(o, never()).onError(any(Throwable.class));
    }

    @Test
    public void subscribeWithObserverAndGetError() {
        @SuppressWarnings("unchecked")
        Observer<Integer> o = mock(Observer.class);

        Single.<Integer>error(new TestException()).subscribe(o);

        verify(o, never()).onNext(anyInt());
        verify(o, never()).onCompleted();
        verify(o).onError(any(TestException.class));
    }

    @Test
    public void subscribeWithNullObserver() {
        try {
            Single.just(1).subscribe((Observer<Integer>)null);
            fail("Failed to throw NullPointerException");
        } catch (NullPointerException ex) {
            assertEquals("observer is null", ex.getMessage());
        }
    }

    @Test
    public void unsubscribeComposesThrough() {
        PublishSubject<Integer> ps = PublishSubject.create();
        
        Subscription s = ps.toSingle()
        .flatMap(new Func1<Integer, Single<Integer>>() {
            @Override
            public Single<Integer> call(Integer v) {
                return Single.just(1);
            }
        })
        .subscribe();
        
        s.unsubscribe();
        
        assertFalse("Observers present?!", ps.hasObservers());
    }

    @Test(timeout = 1000)
    public void unsubscribeComposesThroughAsync() {
        PublishSubject<Integer> ps = PublishSubject.create();
        
        Subscription s = ps.toSingle()
        .subscribeOn(Schedulers.io())
        .flatMap(new Func1<Integer, Single<Integer>>() {
            @Override
            public Single<Integer> call(Integer v) {
                return Single.just(1);
            }
        })
        .subscribe();
        
        while (!ps.hasObservers() && !Thread.currentThread().isInterrupted()) ;
        
        s.unsubscribe();
        
        assertFalse("Observers present?!", ps.hasObservers());
    }

}
require 'spec_helper'
require 'recap/tasks/ruby'

describe Recap::Tasks::Ruby do
  let :config do
    Capistrano::Configuration.new
  end

  let :namespace do
    config.ruby
  end

  let :deploy_to do
    'path/to/deploy/to'
  end

  before do
    config.set :deploy_to, deploy_to
    Recap::Tasks::Ruby.load_into(config)
  end

  describe 'Tasks' do
    describe 'ruby:preflight' do
      before do
        namespace.stubs(:exit_code).with('grep rails path/to/deploy/to/Gemfile').returns("0")
      end

      it 'warns user if rails tasks not loaded for rails project' do
        namespace.logger.expects(:important)
        Recap::Tasks.stubs(:const_defined?).with(:Rails).returns(false)
        config.find_and_execute_task('ruby:preflight')
      end

      it 'skips warning if rails tasks have been loaded' do
        namespace.logger.expects(:important).never
        Recap::Tasks.stubs(:const_defined?).with(:Rails).returns(true)
        config.find_and_execute_task('ruby:preflight')
      end

      it 'skips warning if skip_rails_recipe_not_used_warning set' do
        namespace.logger.expects(:important).never
        Recap::Tasks.stubs(:const_defined?).with(:Rails).returns(false)
        config.set :skip_rails_recipe_not_used_warning, true
        config.find_and_execute_task('ruby:preflight')
      end

      it 'skips warning if rails project not detected' do
        namespace.logger.expects(:important).never
        namespace.stubs(:exit_code).with('grep rails path/to/deploy/to/Gemfile').returns("1")
        Recap::Tasks.stubs(:const_defined?).with(:Rails).returns(false)
        config.set :skip_rails_recipe_not_used_warning, true
        config.find_and_execute_task('ruby:preflight')
      end
    end
  end

  describe 'Callbacks' do
    before do
      Recap::Tasks::Preflight.load_into(config)
    end

    it 'runs `ruby:preflight` after `preflight:check`' do
      config.expects(:find_and_execute_task).with('ruby:preflight')
      config.trigger :after, config.find_task('preflight:check')
    end
  end
end/*   Copyright 2004 The Apache Software Foundation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.apache.xmlbeans.impl.tool;

import org.apache.xmlbeans.XmlOptions;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlError;
import org.apache.xmlbeans.XmlCalendar;
import org.apache.xml.xmlbeans.x2004.x02.xmlbean.ltgfmt.TestsDocument;
import org.apache.xml.xmlbeans.x2004.x02.xmlbean.ltgfmt.FileDesc;

import java.io.File;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.Date;
import java.util.regex.Pattern;
import java.net.URI;

public class XSTCTester
{
    public static void main(String[] args) throws IOException
    {
        long start = System.currentTimeMillis();
        
        CommandLine cl = new CommandLine(args, Collections.EMPTY_SET);
        boolean showpass = (cl.getOpt("showpass") != null);
        File[] allFiles = cl.getFiles();
        Collection ltgFiles = new ArrayList();
        Harness harness = new XMLBeanXSTCHarness();
        
        for (int i = 0; i < allFiles.length; i++)
        {
            if (allFiles[i].getName().indexOf("LTG") >= 0)
                ltgFiles.add(allFiles[i]);
        }
        
        File resultsFile = new File("out.html");
        PrintWriter writer = new PrintWriter(new FileWriter(resultsFile));
        writer.println("<html>");
        writer.println("<style>td {border-bottom: 1px solid black} xmp {white-space: normal; word-wrap: break-word; word-break: break-all} </style>");
        writer.println("<body>");

        writer.println("<script language='JavaScript' type='text/javascript'>");
        writer.println("var w;");
        writer.println("function openWindow(schema, instance) {");
	    writer.println("  if (w == null) {");
        writer.println("    w = window.open('about:blank', 'xstc');");
	    writer.println("  }");
	    writer.println("  if (w.closed) {");
		writer.println("    w = window.open('about:blank', 'xstc');");
	    writer.println("  }");
	    writer.println("  w.document.open();");
	    writer.println("  w.document.write(\"<frameset rows=*,*><frame src='\" + schema + \"'><frame src='\" + instance + \"'></frameset>\");");
	    writer.println("  w.document.close();");
	    writer.println("  w.focus();");
        writer.println("}");
        writer.println("</script>");

        writer.println("<h1>XML Schema Test Collection Results</h1>");
        writer.println("<p>Run on " + (new XmlCalendar(new Date())) + "</p>");
        writer.println("<table style='border: 1px solid black' cellpadding=0 cellspacing=0>");
        writer.println("<tr><td width=75%>Description</td><td width=12.5%>sch v</td><td width=12.5%>ins v</td></tr>");
        int failures = 0;
        int cases = 0;
        for (Iterator i = ltgFiles.iterator(); i.hasNext(); )
        {
            File ltgFile = (File)i.next();
            System.out.println("Processing test cases in " + ltgFile);
            Collection ltgErrors = new ArrayList();
            TestCase[] testCases = parseLTGFile(ltgFile, ltgErrors);
            Collection results = new ArrayList();
            if (testCases != null) for (int j = 0; j < testCases.length; j++)
            {
                TestCaseResult result = new TestCaseResult();
                result.testCase = testCases[j];
                harness.runTestCase(result);
                cases += 1;
                if (!result.succeeded())
                    failures += 1;
                else if (!showpass)
                    continue;
                results.add(result);
            }
            writer.println("<tr><td colspan=3 bgcolor=skyblue>" + ltgFile + "</td></tr>");
            if (!ltgErrors.isEmpty())
            {
                writer.println("<tr><td>Errors within the LTG file:");
                writer.println("<xmp>");
                for (Iterator j = ltgErrors.iterator(); j.hasNext(); )
                    writer.println(j.next());
                writer.println("</xmp>");
                writer.println("</td></tr>");
            }
            else
            {
                if (results.size() == 0)
                    writer.println("<tr><td colspan=3 bgcolor=green>Nothing to report</td></tr>");
            }
            if (results == null)
                continue;
            for (Iterator j = results.iterator(); j.hasNext() ;)
            {
                summarizeResultAsHTMLTableRows((TestCaseResult)j.next(), writer);
            }
        }
        writer.println("<tr><td colspan=3>Summary: " + failures + " failures out of " + cases + " cases run.</td></tr>");
        writer.println("</table>");
        writer.close();
        
        long finish = System.currentTimeMillis();
        System.out.println("Time run tests: " + ((double)(finish - start) / 1000.0) + " seconds" );
        
        // Launch results
        if (System.getProperty("os.name").toLowerCase().indexOf("windows") >= 0)
            Runtime.getRuntime().exec("cmd /c start iexplore \"" + resultsFile.getAbsolutePath() + "\"");
        else
            System.out.println("Results output to " + resultsFile);
    }
    
    public static class TestCase
    {
        private File ltgFile;
        private String id;
        private String origin;
        private String description;
        private File schemaFile;
        private File instanceFile;
        private File resourceFile;
        private boolean svExpected;
        private boolean ivExpected;
        private boolean rvExpected;

        public File getLtgFile()
        {
            return ltgFile;
        }

        public String getId()
        {
            return id;
        }

        public String getOrigin()
        {
            return origin;
        }

        public String getDescription()
        {
            return description;
        }

        public File getSchemaFile()
        {
            return schemaFile;
        }

        public File getInstanceFile()
        {
            return instanceFile;
        }

        public File getResourceFile()
        {
            return resourceFile;
        }

        public boolean isSvExpected()
        {
            return svExpected;
        }

        public boolean isIvExpected()
        {
            return ivExpected;
        }

        public boolean isRvExpected()
        {
            return rvExpected;
        }
    }
    
    public static class TestCaseResult
    {
        private TestCase testCase;
        private boolean svActual;
        private Collection svMessages = new ArrayList();
        private boolean ivActual;
        private Collection ivMessages = new ArrayList();
        private boolean crash;

        public TestCase getTestCase()
        {
            return testCase;
        }

        public boolean isSvActual()
        {
            return svActual;
        }

        public void setSvActual(boolean svActual)
        {
            this.svActual = svActual;
        }

        public boolean isIvActual()
        {
            return ivActual;
        }

        public void setIvActual(boolean ivActual)
        {
            this.ivActual = ivActual;
        }

        public Collection getSvMessages()
        {
            return Collections.unmodifiableCollection(svMessages);
        }

        public void addSvMessages(Collection svMessages)
        {
            this.svMessages.addAll(svMessages);
        }

        public Collection getIvMessages()
        {
            return Collections.unmodifiableCollection(ivMessages);
        }

        public void addIvMessages(Collection ivMessages)
        {
            this.ivMessages.addAll(ivMessages);
        }
        
        public void setCrash(boolean crash)
        {
            this.crash = crash;
        }
        
        public boolean isCrash()
        {
            return crash;
        }
        
        public boolean succeeded()
        {
            return !crash && (isIvActual() == testCase.isIvExpected()) && (isSvActual() == testCase.isSvExpected());
        }
    }
    
    public static interface Harness
    {
        public void runTestCase(TestCaseResult result);
    }
    
    public static String makeHTMLLink(File file, boolean value)
    {
        if (file == null)
            return "&nbsp;";
        URI uri = file.getAbsoluteFile().toURI();
        return "<a href=\"" + uri + "\" target=_blank>" + Boolean.toString(value) + "</a>";
    }
    
    private static final Pattern leadingSpace = Pattern.compile("^\\s+", Pattern.MULTILINE);
    
    public static String makeHTMLDescription(TestCase testCase)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("<a class=noline href='javascript:openWindow(\"");
        if (testCase.getSchemaFile() == null)
            sb.append("about:No schema");
        else
            sb.append(testCase.getSchemaFile().getAbsolutePath().replaceAll("\\\\", "\\\\\\\\"));

        sb.append("\", \"");
        if (testCase.getInstanceFile() == null)
            sb.append("about:No instance");
        else
            sb.append(testCase.getInstanceFile().getAbsolutePath().replaceAll("\\\\", "\\\\\\\\"));
        sb.append("\")'><xmp>");
        sb.append(leadingSpace.matcher(testCase.getDescription()).replaceAll("") + "(" + testCase.getId() + ")");
        sb.append("</xmp></a>");
        return sb.toString();
    }
    
    public static void summarizeResultAsHTMLTableRows(TestCaseResult result, PrintWriter out)
    {
        TestCase testCase = result.getTestCase();
        boolean sRight = testCase.getSchemaFile() == null || testCase.isSvExpected() == result.isSvActual();
        boolean iRight = testCase.getInstanceFile() == null || testCase.isIvExpected() == result.isIvActual();
        
        out.println(result.isCrash() ? "<tr bgcolor=black color=white>" : "<tr>");
        out.println("<td valign=top>" + makeHTMLDescription(testCase) + "</td>");
        String sLinks;
        if (testCase.getResourceFile() == null)
            sLinks = makeHTMLLink(testCase.getSchemaFile(), result.isSvActual());
        else
            sLinks = makeHTMLLink(testCase.getSchemaFile(), result.isSvActual()) + "<br>" + makeHTMLLink(testCase.getResourceFile(), result.isSvActual());
        
        out.println((sRight ? "<td valign=top>" : result.isSvActual() ? "<td bgcolor=orange valign=top>" : "<td bgcolor=red valign=top>") + sLinks + "</td>");
        out.println((iRight ? "<td valign=top>" : result.isIvActual() ? "<td bgcolor=orange valign=top>" : "<td bgcolor=red valign=top>") + makeHTMLLink(testCase.getInstanceFile(), result.isIvActual()) + "</td>");
        out.println("</tr>");
        if (!result.getIvMessages().isEmpty() || !result.getSvMessages().isEmpty())
        {
            if (!result.succeeded())
                out.println("<tr><td colspan=3 bgcolor=yellow><xmp>");
            else
                out.println("<tr><td colspan=3><xmp>");
            for (Iterator j = result.getSvMessages().iterator(); j.hasNext(); )
                out.println(j.next());
            for (Iterator j = result.getIvMessages().iterator(); j.hasNext(); )
                out.println(j.next());
            out.println("</xmp></tr></td>");
        }
    }
    
    public static TestCase[] parseLTGFile(File ltgFile, Collection outerErrors)
    {
        Collection errors = new ArrayList();
        try
        {
            XmlOptions ltgOptions = new XmlOptions();
            ltgOptions.setLoadSubstituteNamespaces(Collections.singletonMap("", "http://xml.apache.org/xmlbeans/2004/02/xmlbean/ltgfmt"));
            ltgOptions.setErrorListener(errors);
            ltgOptions.setLoadLineNumbers();
            TestsDocument doc = TestsDocument.Factory.parse(ltgFile, ltgOptions);
            if (!doc.validate(ltgOptions))
                throw new Exception("Document " + ltgFile + " not valid.");
            
            org.apache.xml.xmlbeans.x2004.x02.xmlbean.ltgfmt.TestCase[] testCases = doc.getTests().getTestArray();
            
            Collection result = new ArrayList();
            for (int i = 0; i < testCases.length; i++)
            {
                TestCase newCase = new TestCase();
                newCase.ltgFile = ltgFile;
                newCase.id = testCases[i].getId();
                newCase.origin = testCases[i].getOrigin();
                newCase.description = testCases[i].getDescription();
                FileDesc[] filedescs = testCases[i].getFiles().getFileArray();
                testCases[i].getOrigin();
                for (int j = 0; j < filedescs.length; j++)
                {
                    String dir = filedescs[j].getFolder();
                    String filename = filedescs[j].getFileName();
                    File theFile = new File(ltgFile.getParentFile(), dir + "/" + filename);
                    if (!theFile.exists() || !theFile.isFile() || !theFile.canRead())
                    {
                        outerErrors.add(XmlError.forObject("Can't read file " + theFile, filedescs[j]).toString());
                        continue;
                    }
                    
                    switch (filedescs[j].getRole().intValue())
                    {
                        case FileDesc.Role.INT_INSTANCE:
                            if (newCase.instanceFile != null)
                                outerErrors.add(XmlError.forObject("More than one instance file speicifed - ignoring all but last", filedescs[j]).toString());
                            newCase.instanceFile = theFile;
                            newCase.ivExpected = filedescs[j].getValidity();
                            break;
                            
                        case FileDesc.Role.INT_SCHEMA:
                            if (newCase.schemaFile != null)
                                outerErrors.add(XmlError.forObject("More than one schema file speicifed - ignoring all but last", filedescs[j]).toString());
                            newCase.schemaFile = theFile;
                            newCase.svExpected = filedescs[j].getValidity();
                            break;
                            
                        case FileDesc.Role.INT_RESOURCE:
                            if (newCase.resourceFile != null)
                                outerErrors.add(XmlError.forObject("More than one resource file speicifed - ignoring all but last", filedescs[j]).toString());
                            newCase.resourceFile = theFile;
                            newCase.rvExpected = filedescs[j].getValidity();
                            break;
                        
                        default:
                            throw new XmlException(XmlError.forObject("Unexpected file role", filedescs[j]));
                    }
                }
                result.add(newCase);
            }
            return (TestCase[])result.toArray(new TestCase[result.size()]);
        }
        catch (Exception e)
        {
            if (errors.isEmpty())
                outerErrors.add(e.getMessage());
            else for (Iterator i = errors.iterator(); i.hasNext(); )
                outerErrors.add(i.next().toString());
            return null;
        }
    }
    
}
/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.Test;
import org.mockito.InOrder;

import rx.Observable;
import rx.Observer;
import rx.Subscriber;
import rx.functions.Action1;
import rx.functions.Func1;
import rx.functions.Func2;
import rx.observers.TestSubscriber;

public class OperatorSingleTest {

    @Test
    public void testSingle() {
        Observable<Integer> observable = Observable.just(1).single();

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(1);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleWithTooManyElements() {
        Observable<Integer> observable = Observable.just(1, 2).single();

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(IllegalArgumentException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleWithEmpty() {
        Observable<Integer> observable = Observable.<Integer> empty().single();

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(NoSuchElementException.class));
        inOrder.verifyNoMoreInteractions();
    }
    
    @Test
    public void testSingleDoesNotRequestMoreThanItNeedsToEmitItem() {
        final AtomicLong request = new AtomicLong();
        Observable.just(1).doOnRequest(new Action1<Long>() {
            @Override
            public void call(Long n) {
                request.addAndGet(n);
            }
        }).toBlocking().single();
        assertEquals(2, request.get());
    }

    @Test
    public void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromEmpty() {
        final AtomicLong request = new AtomicLong();
        try {
            Observable.empty().doOnRequest(new Action1<Long>() {
                @Override
                public void call(Long n) {
                    request.addAndGet(n);
                }
            }).toBlocking().single();
        } catch (NoSuchElementException e) {
            assertEquals(2, request.get());
        }
    }

    @Test
    public void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromMoreThanOne() {
        final AtomicLong request = new AtomicLong();
        try {
            Observable.just(1, 2).doOnRequest(new Action1<Long>() {
                @Override
                public void call(Long n) {
                    request.addAndGet(n);
                }
            }).toBlocking().single();
        } catch (IllegalArgumentException e) {
            assertEquals(2, request.get());
        }
    }
    
    @Test
    public void testSingleDoesNotRequestMoreThanItNeedsIf1Then2Requested() {
        final List<Long> requests = new ArrayList<Long>();
        Observable.just(1)
        //
                .doOnRequest(new Action1<Long>() {
                    @Override
                    public void call(Long n) {
                        requests.add(n);
                    }
                })
                //
                .single()
                //
                .subscribe(new Subscriber<Integer>() {

                    @Override
                    public void onStart() {
                        request(1);
                    }

                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Integer t) {
                        request(2);
                    }
                });
        assertEquals(Arrays.asList(2L), requests);
    }
    
    @Test
    public void testSingleDoesNotRequestMoreThanItNeedsIf3Requested() {
        final List<Long> requests = new ArrayList<Long>();
        Observable.just(1)
        //
                .doOnRequest(new Action1<Long>() {
                    @Override
                    public void call(Long n) {
                        requests.add(n);
                    }
                })
                //
                .single()
                //
                .subscribe(new Subscriber<Integer>() {

                    @Override
                    public void onStart() {
                        request(3);
                    }

                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Integer t) {
                    }
                });
        assertEquals(Arrays.asList(2L), requests);
    }
    
    @Test
    public void testSingleRequestsExactlyWhatItNeedsIf1Requested() {
        final List<Long> requests = new ArrayList<Long>();
        Observable.just(1)
        //
                .doOnRequest(new Action1<Long>() {
                    @Override
                    public void call(Long n) {
                        requests.add(n);
                    }
                })
                //
                .single()
                //
                .subscribe(new Subscriber<Integer>() {

                    @Override
                    public void onStart() {
                        request(1);
                    }

                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Integer t) {
                    }
                });
        assertEquals(Arrays.asList(2L), requests);
    }


    @Test
    public void testSingleWithPredicate() {
        Observable<Integer> observable = Observable.just(1, 2).single(
                new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(2);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleWithPredicateAndTooManyElements() {
        Observable<Integer> observable = Observable.just(1, 2, 3, 4).single(
                new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(IllegalArgumentException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleWithPredicateAndEmpty() {
        Observable<Integer> observable = Observable.just(1).single(
                new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });
        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(NoSuchElementException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefault() {
        Observable<Integer> observable = Observable.just(1).singleOrDefault(2);

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(1);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefaultWithTooManyElements() {
        Observable<Integer> observable = Observable.just(1, 2).singleOrDefault(
                3);

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(IllegalArgumentException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefaultWithEmpty() {
        Observable<Integer> observable = Observable.<Integer> empty()
                .singleOrDefault(1);

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(1);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefaultWithPredicate() {
        Observable<Integer> observable = Observable.just(1, 2).singleOrDefault(
                4, new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(2);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefaultWithPredicateAndTooManyElements() {
        Observable<Integer> observable = Observable.just(1, 2, 3, 4)
                .singleOrDefault(6, new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onError(
                isA(IllegalArgumentException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleOrDefaultWithPredicateAndEmpty() {
        Observable<Integer> observable = Observable.just(1).singleOrDefault(2,
                new Func1<Integer, Boolean>() {

                    @Override
                    public Boolean call(Integer t1) {
                        return t1 % 2 == 0;
                    }
                });

        @SuppressWarnings("unchecked")
        Observer<Integer> observer = mock(Observer.class);
        observable.subscribe(observer);

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer, times(1)).onNext(2);
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    public void testSingleWithBackpressure() {
        Observable<Integer> observable = Observable.just(1, 2).single();

        Subscriber<Integer> subscriber = spy(new Subscriber<Integer>() {

            @Override
            public void onStart() {
                request(1);
            }

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer integer) {
                request(1);
            }
        });
        observable.subscribe(subscriber);

        InOrder inOrder = inOrder(subscriber);
        inOrder.verify(subscriber, times(1)).onError(isA(IllegalArgumentException.class));
        inOrder.verifyNoMoreInteractions();
    }

    @Test(timeout = 30000)
    public void testIssue1527() throws InterruptedException {
        //https://github.com/ReactiveX/RxJava/pull/1527
        Observable<Integer> source = Observable.just(1, 2, 3, 4, 5, 6);
        Observable<Integer> reduced = source.reduce(new Func2<Integer, Integer, Integer>() {
            @Override
            public Integer call(Integer i1, Integer i2) {
                return i1 + i2;
            }
        });

        Integer r = reduced.toBlocking().first();
        assertEquals(21, r.intValue());
    }
    
    @Test
    public void defaultBackpressure() {
        TestSubscriber<Integer> ts = TestSubscriber.create(0);
        
        Observable.<Integer>empty().singleOrDefault(1).subscribe(ts);
        
        ts.assertNoValues();
        
        ts.requestMore(1);
        
        ts.assertValue(1);
        ts.assertCompleted();
        ts.assertNoErrors();
    }
}
/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx;

/**
 * An object representing a notification sent to an {@link Observable}.
 */
public final class Notification<T> {

    private final Kind kind;
    private final Throwable throwable;
    private final T value;

    private static final Notification<Void> ON_COMPLETED = new Notification<Void>(Kind.OnCompleted, null, null);

    /**
     * Creates and returns a {@code Notification} of variety {@code Kind.OnNext}, and assigns it a value.
     *
     * @param t
     *          the item to assign to the notification as its value
     * @return an {@code OnNext} variety of {@code Notification}
     */
    public static <T> Notification<T> createOnNext(T t) {
        return new Notification<T>(Kind.OnNext, t, null);
    }

    /**
     * Creates and returns a {@code Notification} of variety {@code Kind.OnError}, and assigns it an exception.
     *
     * @param e
     *          the exception to assign to the notification
     * @return an {@code OnError} variety of {@code Notification}
     */
    public static <T> Notification<T> createOnError(Throwable e) {
        return new Notification<T>(Kind.OnError, null, e);
    }

    /**
     * Creates and returns a {@code Notification} of variety {@code Kind.OnCompleted}.
     *
     * @return an {@code OnCompleted} variety of {@code Notification}
     */
    @SuppressWarnings("unchecked")
    public static <T> Notification<T> createOnCompleted() {
        return (Notification<T>) ON_COMPLETED;
    }

    /**
     * Creates and returns a {@code Notification} of variety {@code Kind.OnCompleted}.
     *
     * @warn param "type" undescribed
     * @param type
     * @return an {@code OnCompleted} variety of {@code Notification}
     */
    @SuppressWarnings("unchecked")
    public static <T> Notification<T> createOnCompleted(Class<T> type) {
        return (Notification<T>) ON_COMPLETED;
    }

    private Notification(Kind kind, T value, Throwable e) {
        this.value = value;
        this.throwable = e;
        this.kind = kind;
    }

    /**
     * Retrieves the exception associated with this (onError) notification.
     * 
     * @return the Throwable associated with this (onError) notification
     */
    public Throwable getThrowable() {
        return throwable;
    }

    /**
     * Retrieves the item associated with this (onNext) notification.
     * 
     * @return the item associated with this (onNext) notification
     */
    public T getValue() {
        return value;
    }

    /**
     * Indicates whether this notification has an item associated with it.
     * 
     * @return a boolean indicating whether or not this notification has an item associated with it
     */
    public boolean hasValue() {
        return isOnNext() && value != null;
// isn't "null" a valid item?
    }

    /**
     * Indicates whether this notification has an exception associated with it.
     * 
     * @return a boolean indicating whether this notification has an exception associated with it
     */
    public boolean hasThrowable() {
        return isOnError() && throwable != null;
    }

    /**
     * Retrieves the kind of this notification: {@code OnNext}, {@code OnError}, or {@code OnCompleted}
     * 
     * @return the kind of the notification: {@code OnNext}, {@code OnError}, or {@code OnCompleted}
     */
    public Kind getKind() {
        return kind;
    }

    /**
     * Indicates whether this notification represents an {@code onError} event.
     * 
     * @return a boolean indicating whether this notification represents an {@code onError} event
     */
    public boolean isOnError() {
        return getKind() == Kind.OnError;
    }

    /**
     * Indicates whether this notification represents an {@code onCompleted} event.
     * 
     * @return a boolean indicating whether this notification represents an {@code onCompleted} event
     */
    public boolean isOnCompleted() {
        return getKind() == Kind.OnCompleted;
    }

    /**
     * Indicates whether this notification represents an {@code onNext} event.
     * 
     * @return a boolean indicating whether this notification represents an {@code onNext} event
     */
    public boolean isOnNext() {
        return getKind() == Kind.OnNext;
    }

    /**
     * Forwards this notification on to a specified {@link Observer}.
     */
    public void accept(Observer<? super T> observer) {
        if (isOnNext()) {
            observer.onNext(getValue());
        } else if (isOnCompleted()) {
            observer.onCompleted();
        } else if (isOnError()) {
            observer.onError(getThrowable());
        }
    }

    public static enum Kind {
        OnNext, OnError, OnCompleted
    }

    @Override
    public String toString() {
        StringBuilder str = new StringBuilder("[").append(super.toString()).append(" ").append(getKind());
        if (hasValue())
            str.append(" ").append(getValue());
        if (hasThrowable())
            str.append(" ").append(getThrowable().getMessage());
        str.append("]");
        return str.toString();
    }

    @Override
    public int hashCode() {
        int hash = getKind().hashCode();
        if (hasValue())
            hash = hash * 31 + getValue().hashCode();
        if (hasThrowable())
            hash = hash * 31 + getThrowable().hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (obj.getClass() != getClass())
            return false;
        Notification<?> notification = (Notification<?>) obj;
        if (notification.getKind() != getKind())
            return false;
        if (hasValue() && !getValue().equals(notification.getValue()))
            return false;
        if (hasThrowable() && !getThrowable().equals(notification.getThrowable()))
            return false;
        return true;
    }
}
msgid ""
msgstr ""
"Project-Id-Version: ZfcUser\n"
"Report-Msgid-Bugs-To: zf-devteam@zend.com\n"
"POT-Creation-Date: 2013-11-08 00:38+0100\n"
"PO-Revision-Date: 2014-03-24 13:27+0100\n"
"Last-Translator: Bart McLeod <mcleod@spaceweb.nl>\n"
"Language-Team: ZF Contibutors <zf-devteam@zend.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.6.4\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Language: nl_NL\n"

#: src/ZfcUser/language/msgIds.php:6
msgid "Username"
msgstr "Gebruikersnaam"

#: src/ZfcUser/language/msgIds.php:7
msgid "Email"
msgstr "E-mail adres"

#: src/ZfcUser/language/msgIds.php:8
msgid "New Email"
msgstr "Nieuw e-mail adres"

#: src/ZfcUser/language/msgIds.php:9
msgid "Verify New Email"
msgstr "Nieuw e-mail adres verificatie"

#: src/ZfcUser/language/msgIds.php:10
msgid "Display Name"
msgstr "Bijnaam"

#: src/ZfcUser/language/msgIds.php:11
msgid "Password"
msgstr "Wachtwoord"

#: src/ZfcUser/language/msgIds.php:12
msgid "Password Verify"
msgstr "Wachtwoord verificatie"

#: src/ZfcUser/language/msgIds.php:13
msgid "Current Password"
msgstr "Huidig wachtwoord"

#: src/ZfcUser/language/msgIds.php:14
msgid "Verify New Password"
msgstr "Nieuw wachtwoord verificatie"

#: src/ZfcUser/language/msgIds.php:15
msgid "New Password"
msgstr "Nieuw wachtwoord"

#: src/ZfcUser/language/msgIds.php:16
msgid "Please type the following text"
msgstr "Type de volgende tekst"

#: src/ZfcUser/language/msgIds.php:17
msgid "Submit"
msgstr "Verzend"

#: src/ZfcUser/language/msgIds.php:18 view/zfc-user/user/login.phtml:1
msgid "Sign In"
msgstr "Aanmelden"

#: src/ZfcUser/language/msgIds.php:19 view/zfc-user/user/register.phtml:1
msgid "Register"
msgstr "Registreer"

#: src/ZfcUser/language/msgIds.php:20
msgid "No record matching the input was found"
msgstr "Er zijn geen gegevens gevonden die met de invoer overeenkomen"

#: src/ZfcUser/language/msgIds.php:21
msgid "A record matching the input was found"
msgstr "Er zijn al gegevens die met de invoer overeenkomen"

#: src/ZfcUser/language/msgIds.php:22
msgid "Authentication failed. Please try again."
msgstr "Inloggen mislukt. Probeer het opnieuw."

#: view/zfc-user/user/login.phtml:31
msgid "Not registered?"
msgstr "Niet geregistreerd?"

#: view/zfc-user/user/login.phtml:31
msgid "Sign up!"
msgstr "Registreren!"

#: view/zfc-user/user/changeemail.phtml:1
#, php-format
msgid "Change Email for %s"
msgstr "Wijzig het e-mail adres van %s"

#: view/zfc-user/user/changeemail.phtml:3
msgid "Email address changed successfully."
msgstr "Het e-mail adres is gewijzigd."

#: view/zfc-user/user/changeemail.phtml:5
msgid "Unable to update your email address. Please try again."
msgstr "Het is niet gelukt het e-mail adres te wijzigen. Probeer het nog eens."

#: view/zfc-user/user/changepassword.phtml:1
#, php-format
msgid "Change Password for %s"
msgstr "Wijzig het wachtwoord van %s"

#: view/zfc-user/user/changepassword.phtml:3
msgid "Password changed successfully."
msgstr "Het wachtwoord is gewijzigd."

#: view/zfc-user/user/changepassword.phtml:5
msgid "Unable to update your password. Please try again."
msgstr "Wachtwoord wijzigen mislukt. Probeer het nog eens."

#: view/zfc-user/user/index.phtml:2
msgid "Hello"
msgstr "Hallo"

#: view/zfc-user/user/index.phtml:3
msgid "Sign Out"
msgstr "Afmelden"
/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.observers;

import rx.Observer;
import rx.Subscriber;

/**
 * Enforces single-threaded, serialized, ordered execution of {@link #onNext}, {@link #onCompleted}, and
 * {@link #onError}.
 * <p>
 * When multiple threads are emitting and/or notifying they will be serialized by:
 * </p><ul>
 * <li>Allowing only one thread at a time to emit</li>
 * <li>Adding notifications to a queue if another thread is already emitting</li>
 * <li>Not holding any locks or blocking any threads while emitting</li>
 * </ul>
 * 
 * @param <T>
 *          the type of items expected to be emitted to the {@code Subscriber}
 */
public class SerializedSubscriber<T> extends Subscriber<T> {

    private final Observer<T> s;

    public SerializedSubscriber(Subscriber<? super T> s) {
        this(s, true);
    }

    /**
     * Constructor for wrapping and serializing a subscriber optionally sharing the same underlying subscription
     * list.
     *
     * @param s
     *          the subscriber to wrap and serialize
     * @param shareSubscriptions
     *          if {@code true}, the same subscription list is shared between this subscriber and {@code s}.
     * @since 1.0.7
     */
    public SerializedSubscriber(Subscriber<? super T> s, boolean shareSubscriptions) {
        super(s, shareSubscriptions);
        this.s = new SerializedObserver<T>(s);
    }

    /**
     * Notifies the Subscriber that the {@code Observable} has finished sending push-based notifications.
     * <p>
     * The {@code Observable} will not call this method if it calls {@link #onError}.
     */
    @Override
    public void onCompleted() {
        s.onCompleted();
    }

    /**
     * Notifies the Subscriber that the {@code Observable} has experienced an error condition.
     * <p>
     * If the {@code Observable} calls this method, it will not thereafter call {@link #onNext} or
     * {@link #onCompleted}.
     * 
     * @param e
     *          the exception encountered by the Observable
     */
    @Override
    public void onError(Throwable e) {
        s.onError(e);
    }

    /**
     * Provides the Subscriber with a new item to observe.
     * <p>
     * The {@code Observable} may call this method 0 or more times.
     * <p>
     * The {@code Observable} will not call this method again after it calls either {@link #onCompleted} or
     * {@link #onError}.
     * 
     * @param t
     *          the item emitted by the Observable
     */
    @Override
    public void onNext(T t) {
        s.onNext(t);
    }
}
<?php

/**
 * Part of the Sentinel package.
 *
 * NOTICE OF LICENSE
 *
 * Licensed under the 3-clause BSD License.
 *
 * This source file is subject to the 3-clause BSD License that is
 * bundled with this package in the LICENSE file.
 *
 * @package    Sentinel
 * @version    2.0.12
 * @author     Cartalyst LLC
 * @license    BSD License (3-clause)
 * @copyright  (c) 2011-2015, Cartalyst LLC
 * @link       http://cartalyst.com
 */

namespace Cartalyst\Sentinel\Permissions;

class StandardPermissions implements PermissionsInterface
{
    use PermissionsTrait;

    /**
     * {@inheritDoc}
     */
    protected function createPreparedPermissions()
    {
        $prepared = [];

        if (! empty($this->secondaryPermissions)) {
            foreach ($this->secondaryPermissions as $permissions) {
                $this->preparePermissions($prepared, $permissions);
            }
        }

        if (! empty($this->permissions)) {
            $permissions = [];

            $this->preparePermissions($permissions, $this->permissions);

            $prepared = array_merge($prepared, $permissions);
        }

        return $prepared;
    }
}
// Copyright: 2010 - 2016 https://github.com/ensime/ensime-server/graphs
// License: http://www.gnu.org/licenses/gpl-3.0.en.html
package org.ensime.intg

import org.ensime.api._
import org.ensime.fixture._
import org.ensime.util.EnsimeSpec
import org.ensime.util.file._

// a pure java project, checking that how things behave without scala
class JavaWorkflow extends EnsimeSpec
    with IsolatedEnsimeConfigFixture
    with IsolatedTestKitFixture
    with IsolatedProjectFixture {

  val original = EnsimeConfigFixture.JavaTestProject

  "ensime-server" should "open the pure Java test project" in {
    withEnsimeConfig { implicit config =>
      withTestKit { implicit testkit =>
        withProject { (project, asyncHelper) =>
          import testkit._

          val sourceRoot = javaMain(config)
          val fooFile = sourceRoot / "pure/NoScalaHere.java"
          val fooFilePath = fooFile.getAbsolutePath

          project ! TypecheckFilesReq(List(Left(fooFile)))
          expectMsg(VoidResponse)

          project ! TypeAtPointReq(Left(fooFile), OffsetRange(30))
          expectMsg(BasicTypeInfo("pure.NoScalaHere", DeclaredAs.Class, "pure.NoScalaHere", Nil, Nil, None))
        }
      }
    }
  }
}
<?php
/**
 * Licensed under The GPL-3.0 License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @since    2.0.0
 * @author   Christopher Castro <chris@quickapps.es>
 * @link     http://www.quickappscms.org
 * @license  http://opensource.org/licenses/gpl-3.0.html GPL-3.0 License
 */
?>

<?php if (empty($errors)): ?>
    <div class="alert alert-success clearfix">
        <p><?= __d('installer', '<strong>Congratulations!</strong> Your server meets the basic software requirements.'); ?></p>
        <p><?= $this->Html->link(__d('installer', 'Continue'), ['plugin' => 'Installer', 'controller' => 'startup', 'action' => 'license'], ['class' => 'btn btn-primary pull-right']); ?></p>
    </div>
<?php else: ?>
    <div class="alert alert-danger">
        <p><?= __d('installer', "<strong>Uh oh.</strong> There's a server compatibility issue. See below."); ?></p>
        <p>
            <ol>
                <?php foreach ($errors as $name => $message): ?>
                    <li><?= $message; ?></li>
                <?php endforeach; ?>
            </ol>
        </p>
    </div>
<?php endif; ?><?php
/**
 * Licensed under The GPL-3.0 License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @since    2.0.0
 * @author   Christopher Castro <chris@quickapps.es>
 * @link     http://www.quickappscms.org
 * @license  http://opensource.org/licenses/gpl-3.0.html GPL-3.0 License
 */
namespace System\Controller\Admin;

use Cake\Network\Exception\NotFoundException;
use CMS\Console\WebShellDispatcher;
use CMS\Core\Plugin;
use Installer\Utility\PackageUploader;
use System\Controller\AppController;

/**
 * Controller for handling themes tasks.
 *
 * Here is where can install new themes, remove existing ones or change site's in
 * use theme.
 *
 * @property \System\Model\Table\PluginsTable $Plugins
 */
class ThemesController extends AppController
{

    /**
     * Main action.
     *
     * @return void
     */
    public function index()
    {
        $themes = plugin()
            ->filter(function ($plugin) {
                return $plugin->isTheme;
            });

        $frontThemes = $themes
            ->filter(function ($theme) {
                return !isset($theme->composer['extra']['admin']) || !$theme->composer['extra']['admin'];
            })
            ->sortBy(function ($theme) {
                if ($theme->name() === option('front_theme')) {
                    return 0;
                }
                return 1;
            }, SORT_ASC);

        $backThemes = $themes
            ->filter(function ($theme) {
                return isset($theme->composer['extra']['admin']) && $theme->composer['extra']['admin'];
            })
            ->sortBy(function ($theme) {
                if ($theme->name() === option('back_theme')) {
                    return 0;
                }
                return 1;
            }, SORT_ASC);

        $frontCount = count($frontThemes->toArray());
        $backCount = count($backThemes->toArray());

        $this->title(__d('system', 'Themes'));
        $this->_awaitingPlugins('theme');
        $this->set(compact('frontCount', 'backCount', 'frontThemes', 'backThemes'));
        $this->Breadcrumb->push('/admin/system/themes');
    }

    /**
     * Install a new theme.
     *
     * @return void
     */
    public function install()
    {
        if ($this->request->data()) {
            $task = false;
            $uploadError = false;

            if (isset($this->request->data['download'])) {
                $task = (bool)WebShellDispatcher::run("Installer.plugins install -s \"{$this->request->data['url']}\" --theme -a");
            } elseif (isset($this->request->data['file_system'])) {
                $task = (bool)WebShellDispatcher::run("Installer.plugins install -s \"{$this->request->data['path']}\" --theme -a");
            } else {
                $uploader = new PackageUploader($this->request->data['file']);
                if ($uploader->upload()) {
                    $task = (bool)WebShellDispatcher::run('Installer.plugins install -s "' . $uploader->dst() . '" --theme -a');
                } else {
                    $uploadError = true;
                    $this->Flash->set(__d('system', 'Plugins installed but some errors occur'), [
                        'element' => 'System.installer_errors',
                        'params' => ['errors' => $uploader->errors(), 'type' => 'warning'],
                    ]);
                }
            }

            if ($task) {
                $this->Flash->success(__d('system', 'Theme successfully installed!'));
                $this->redirect($this->referer());
            } elseif (!$task && !$uploadError) {
                $this->Flash->set(__d('system', 'Theme could not be installed'), [
                    'element' => 'System.installer_errors',
                    'params' => ['errors' => WebShellDispatcher::output()],
                ]);
            }
        }

        $this->title(__d('system', 'Install Theme'));
        $this->Breadcrumb
            ->push('/admin/system/themes')
            ->push(__d('system', 'Install new theme'), '#');
    }

    /**
     * Removes the given theme.
     *
     * @param string $themeName Theme's name
     * @return void
     */
    public function uninstall($themeName)
    {
        $theme = plugin($themeName); // throws
        if (!in_array($themeName, [option('front_theme'), option('back_theme')])) {
            if (!$theme->requiredBy()->isEmpty()) {
                $this->Flash->danger(__d('system', 'You cannot remove this theme!'));
            } else {
                $task = (bool)WebShellDispatcher::run("Installer.plugins uninstall -p {$theme->name}");
                if ($task) {
                    $this->Flash->success(__d('system', 'Theme successfully removed!'));
                } else {
                    $this->Flash->set(__d('system', 'Theme could not be removed'), [
                        'element' => 'System.installer_errors',
                        'params' => ['errors' => WebShellDispatcher::output()],
                    ]);
                }
            }
        } else {
            $this->Flash->danger(__d('system', 'This theme cannot be removed as it is currently being used.'));
        }

        $this->title(__d('system', 'Uninstall Theme'));
        $this->redirect($this->referer());
    }

    /**
     * Marks as active the provided theme.
     *
     * @param string $themeName Theme's name
     * @return void
     */
    public function activate($themeName)
    {
        $theme = plugin($themeName); // throws
        if (!in_array($themeName, [option('front_theme'), option('back_theme')])) {
            $task = (bool)WebShellDispatcher::run("Installer.themes change -t {$theme->name}");
            if ($task) {
                $this->Flash->success(__d('system', 'Theme successfully activated!'));
            } else {
                $this->Flash->set(__d('system', 'Theme could not be activated'), [
                    'element' => 'System.installer_errors',
                    'params' => ['errors' => WebShellDispatcher::output()],
                ]);
            }
        } else {
            $this->Flash->danger(__d('system', 'This theme is already active.'));
        }

        $this->title(__d('system', 'Activate Theme'));
        $this->redirect($this->referer());
    }

    /**
     * Detailed theme's information.
     *
     * @param string $themeName Theme's name
     * @return void
     */
    public function details($themeName)
    {
        $theme = plugin($themeName); // throws

        $this->title(__d('system', 'Theme Information'));
        $this->set(compact('theme'));
        $this->Breadcrumb
            ->push('/admin/system/themes')
            ->push($theme->humanName, '#')
            ->push(__d('system', 'Details'), '#');
    }

    /**
     * Renders theme's "screenshot.png"
     *
     * @param string $themeName Theme's name
     * @return \Cake\Network\Response
     */
    public function screenshot($themeName)
    {
        $theme = plugin($themeName); // throws
        $this->response->file("{$theme->path}/webroot/screenshot.png");
        return $this->response;
    }

    /**
     * Handles theme's specifics settings.
     *
     * When saving theme's information `PluginsTable` will trigger the
     * following events:
     *
     * - `Plugin.<PluginName>.beforeValidate`
     * - `Plugin.<PluginName>.afterValidate`
     * - `Plugin.<PluginName>.beforeSave`
     * - `Plugin.<PluginName>.afterSave`
     *
     * Check `PluginsTable` documentation for more details.
     *
     * Additionally theme may define default values for each input, to do this they
     * must catch the event:
     *
     * - `Plugin.<PluginName>.settingsDefaults`
     *
     * They must return an associative array of default values for each input in the
     * form.
     *
     * Validation rules can be applied to settings, theme must simply catch the
     * event:
     *
     * - `Plugin.<PluginName>.settingsValidate`
     *
     * @param string $themeName Theme's name
     * @return void
     * @throws \Cake\Network\Exception\NotFoundException When plugin do not exists
     */
    public function settings($themeName)
    {
        $info = plugin($themeName);
        $this->loadModel('System.Plugins');
        $theme = $this->Plugins->get($themeName, ['flatten' => true]);

        if (!$info->hasSettings || !$info->isTheme) {
            throw new NotFoundException(__d('system', 'The requested page was not found.'));
        }

        if ($this->request->data()) {
            $theme = $this->Plugins->patchEntity($theme, $this->request->data(), ['entity' => $theme]);
            if (!$theme->errors()) {
                if ($this->Plugins->save($theme)) {
                    $this->Flash->success(__d('system', 'Theme settings saved!'));
                    $this->redirect($this->referer());
                }
            } else {
                $this->Flash->danger(__d('system', 'Theme settings could not be saved.'));
            }
        }

        $this->title(__d('system', 'Themes Settings'));
        $this->set(compact('info', 'theme'));
        $this->Breadcrumb
            ->push('/admin/system/themes')
            ->push(__d('system', 'Settings for {0} theme', $info->name), '#');
    }
}
/*
 * Copyright (c) 2014 CodeAndMagic
 * Cristian Vrabie, Evelina Vrabie
 *
 * This file is part of android-promise.
 * android-promise is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License,or (at your option)
 * any later version.
 *
 * android-promise is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with android-promise. If not, see <http://www.gnu.org/licenses/>.
 */

package org.codeandmagic.promise.sample.patterns;

import android.graphics.Bitmap;

/**
 * Created by evelina on 18/03/2014.
 */
class Pattern {
    public final String id;
    public final String title;
    public final String imageUrl;
    public final Bitmap bitmap;

    public Pattern(String id, String title, String imageUrl, Bitmap bitmap) {
        this.id = id;
        this.title = title;
        this.imageUrl = imageUrl;
        this.bitmap = bitmap;
    }

    public Pattern withBitmap(Bitmap bitmap) {
        return new Pattern(id, title, imageUrl, bitmap);
    }
}
/*
  Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "filesystem.h"

#include <cassert>
#include <sstream>
#include <stdexcept>

#include <dirent.h>
#include <errno.h>
#include <fnmatch.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L
# error "This file expects POSIX.1-2001 or later"
#endif

using std::ostringstream;

namespace {
  const std::string dirsep("/");
  const std::string extsep(".");
}

void Path::validate_non_empty_path() const {
  if (type_ == FileType::EMPTY_PATH)
    throw std::invalid_argument("Empty path");
}

Path::Path()
    : type_(FileType::EMPTY_PATH)
{
}

Path::Path(const char* path)
    : Path(std::string(path))
{
}

Path::Path(const std::string& path)
    : path_(path)
    , type_(FileType::TYPE_UNKNOWN)
{
  std::string::size_type pos = path_.find_last_not_of(dirsep);
  if (pos != std::string::npos)
    path_.erase(pos + 1);
  else if (path_.size() > 0)
    path_.erase(1);
  else
    throw std::invalid_argument("Empty path");
}


Path::FileType
Path::type(bool refresh) const
{
  validate_non_empty_path();
  if (type_ == FileType::TYPE_UNKNOWN || refresh)
  {
    struct stat stat_buf;
    if (stat(c_str(), &stat_buf) == -1)
    {
      if (errno == ENOENT || errno == ENOTDIR)
        type_ = FileType::FILE_NOT_FOUND;
      else
        type_ = FileType::STATUS_ERROR;
    }
    else
      switch (stat_buf.st_mode & S_IFMT)
      {
      case S_IFDIR:
        type_ = FileType::DIRECTORY_FILE;
        break;
      case S_IFBLK:
        type_ = FileType::BLOCK_FILE;
        break;
      case S_IFCHR:
        type_ = FileType::CHARACTER_FILE;
        break;
      case S_IFIFO:
        type_ = FileType::FIFO_FILE;
        break;
      case S_IFLNK:
        type_ = FileType::SYMLINK_FILE;
        break;
      case S_IFREG:
        type_ = FileType::REGULAR_FILE;
        break;
      case S_IFSOCK:
        type_ = FileType::SOCKET_FILE;
        break;
      default:
        type_ = FileType::TYPE_UNKNOWN;
        break;
      }
  }
  return type_;
}

bool Path::is_directory() const
{
  validate_non_empty_path();
  return type() == FileType::DIRECTORY_FILE;
}

bool Path::is_regular() const
{
  validate_non_empty_path();
  return type() == FileType::REGULAR_FILE;
}

void Path::append(const Path& other)
{
  validate_non_empty_path();
  other.validate_non_empty_path();
  path_.append(dirsep + other.path_);
  type_ = FileType::TYPE_UNKNOWN;
}


Path Path::join(const Path& other) const
{
  validate_non_empty_path();
  other.validate_non_empty_path();
  Path result(*this);
  result.append(other);
  return result;
}


Path Path::basename() const
{
  validate_non_empty_path();
  std::string::size_type pos = path_.find_last_of(dirsep);
  if (pos == std::string::npos)
    return *this;
  else if (pos > 1)
    return std::string(path_, pos + 1);
  else
    return Path("/");
}

Path Path::dirname() const
{
  validate_non_empty_path();
  std::string::size_type pos = path_.find_last_of(dirsep);
  if (pos == std::string::npos)
    return Path(".");
  else if (pos > 1)
    return std::string(path_, 0, pos);
  else
    return Path("/");
}

Directory::DirectoryIterator::DirectoryIterator(const Path& path,
                                                const std::string& pattern,
                                                struct dirent *result)
  : root_(path)
  , dirp_(opendir(path.c_str()))
  , result_(result)
  , pattern_(pattern)
{
  if (dirp_ == nullptr)
  {
    ostringstream  buffer;
    char msg[256];
    if (strerror_r(errno, msg, sizeof(msg)))
      buffer << "strerror_r failed: " << errno;
    else
      buffer << "Failed to open path " << path << " - " << msg;
    throw std::runtime_error(buffer.str());
  }

  fill_result();
}

Directory::DirectoryIterator::DirectoryIterator(const Path& path,
                                                const std::string& pattern)
  : DirectoryIterator(path, pattern, &entry_)
{

}

void
Directory::DirectoryIterator::fill_result()
{
  // This is similar to scandir(2), but we do not use scandir(2) since
  // we want to be thread-safe.

  if (result_ == nullptr)
    return;

  while (true)
  {
    if (int error = readdir_r(dirp_, &entry_, &result_))
    {
      ostringstream buffer;
      char msg[256];
      if (strerror_r(error, msg, sizeof(msg)))
        buffer << "strerror_r failed: " << errno;
      else
        buffer << "Failed to read directory entry - " << msg;
      throw std::runtime_error(buffer.str());
    }

    // If there are no more entries, we're done.
    if (result_ == nullptr)
      break;

    // Skip current directory and parent directory.
    if (strcmp(result_->d_name, ".") == 0 ||
        strcmp(result_->d_name, "..") == 0)
      continue;

    // If no pattern is given, we're done.
    if (pattern_.size() == 0)
      break;

    // Skip any entries that do not match the pattern
    int error = fnmatch(pattern_.c_str(), result_->d_name, FNM_PATHNAME);
    if (error == FNM_NOMATCH)
      continue;
    else if (error == 0)
      break;
    else
    {
      ostringstream buffer;
      char msg[256];
      if (strerror_r(error, msg, sizeof(msg)))
        buffer << "strerror_r failed: " << errno;
      else
        buffer << "Match failed - " << msg;
      throw std::runtime_error(buffer.str());
    }
  }
}

Directory::DirectoryIterator&
Directory::DirectoryIterator::operator++()
{
  fill_result();
  return *this;
}

Path
Directory::DirectoryIterator::operator*() const
{
  assert(result_);
  return root_.join(result_->d_name);
}

bool
Directory::DirectoryIterator::operator!=(const DirectoryIterator& rhs)
{
  return result_ != rhs.result_;
}

Directory::DirectoryIterator
Directory::begin()
{
  return DirectoryIterator(*this);
}

Directory::DirectoryIterator
Directory::glob(const std::string& pattern)
{
  return DirectoryIterator(*this, pattern);
}

Directory::DirectoryIterator
Directory::end()
{
  return DirectoryIterator(*this, "", nullptr);
}


std::ostream&
operator<<(std::ostream& out, Path::FileType type)
{
  static const char* type_names[]{
    "ERROR",
    "not found",
    "regular",
    "directory",
    "symlink",
    "block device",
    "character device",
    "FIFO",
    "socket",
    "UNKNOWN",
  };
  out << type_names[static_cast<int>(type)];
  return out;
}


Path
Path::make_path(const Path& dir,
                const std::string& base,
                const std::string& ext)
{
  return dir.join(base + extsep + ext);
}
# encoding: utf-8
# Copyright 2011 Tree.io Limited
# This file is part of Treeio.
# License www.tree.io/license

"""
Core module widgets
"""

# WIDGETS = {'widget_release': {'title': 'Time To Release', 'size': 300}}
WIDGETS = {'widget_welcome': {'title': 'Quick Start', 'size': "95%"}}


def get_widgets(request):
    "Returns a set of all available widgets"

    return WIDGETS
# English (en) translation strings for Booktype Control Centre.
# Copyright (C) 2014 Booktype contributors
# This file is distributed under the same license as the Booktype package.
# 
# Translators:
# Eva Dangendorf <eva.dangendorf@sourcefabric.org>, 2015
# Hulor Truman, 2016
# Julian <julian.sorge@sourcefabric.org>, 2015-2016
# Katerina Michailidi <katerina.michailidis@sourcefabric.org>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Booktype\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-09-28 15:21+0100\n"
"PO-Revision-Date: 2016-04-13 14:10+0000\n"
"Last-Translator: Julian <julian.sorge@sourcefabric.org>\n"
"Language-Team: German (http://www.transifex.com/sourcefabric/booktype/language/de/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: de\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Poedit-Country: UNITED KINGDOM\n"
"X-Poedit-Language: English\n"

#: forms.py:55
msgid "Site title"
msgstr "Seitentitel"

#: forms.py:57
msgid "Site title is required."
msgstr "Seitentitel erforderlich."

#: forms.py:61
msgid "Tagline"
msgstr "Metadaten (Schlsselworte Suchmaschinen)"

#: forms.py:66
msgid "Favicon"
msgstr "Favicon"

#: forms.py:68
msgid "Upload .ico file"
msgstr ".ico-Datei hochladen"

#: forms.py:105
msgid "CSS"
msgstr "CSS"

#: forms.py:133
msgid "Welcome message"
msgstr "Begrungsnachricht"

#: forms.py:138
msgid "Show activity"
msgstr "Aktivitt anzeigen"

#: forms.py:142
msgid "Use anonymous page"
msgstr "Verwende anonyme Seite"

#: forms.py:144
msgid ""
"Use separate page for anonymous users without books, people, groups and "
"recent activity blocks."
msgstr "Verwende separate Seite fr anonyme (nicht eingeloggte) Nutzer ohne Anzeige von Bchern, Leuten, Gruppen und Aktivitten. "

#: forms.py:148
msgid "Anonymous page message"
msgstr "Nachricht auf Seite fr nicht eingeloggte Nutzer."

#: forms.py:151
msgid "Message for displaying on anonymous page."
msgstr "Nachricht, die auf der Seite fr nicht eingeloggte Nutzer gezeigt wird."

#: forms.py:154
msgid "Anonymous page email"
msgstr "Mail Kontakt auf der Seite fr nicht eingeloggte Nutzer."

#: forms.py:156
msgid "Email for displaying on anonymous page."
msgstr "Angezeigter Mail Kontakt auf Seite fr nicht eingeloggte Nutzer."

#: forms.py:159
msgid "Anonymous page image"
msgstr "Bild fr die Seite fr nicht eingeloggte Nutzer."

#: forms.py:161
msgid "Use image/png files."
msgstr "Bild/png Datei verwenden"

#: forms.py:248
msgid "Abbreviation"
msgstr "Abkrzung"

#: forms.py:250
msgid "Abbreviation is required."
msgstr "Abkrzung erforderlich"

#: forms.py:254
msgid "Name"
msgstr "Name"

#: forms.py:256 forms.py:262
msgid "License name is required."
msgstr "Lizenzname erforderlich"

#: forms.py:260
msgid "License URL"
msgstr "Lizenz URL"

#: forms.py:266
msgid "Successfully created new license."
msgstr "Neue Lizenz erfolgreich erstellt. "

#: forms.py:285
msgid ""
"Default visibility: If this box is checked, all newly created books will be "
"visible to the public initially."
msgstr "Standard-Sichtbarkeit: Ist diese Option markiert, sind alle neu erstellten Bcher anfnglich ffentlich sichtbar."

#: forms.py:287
msgid ""
"If it is turned on then track changes will be        enabled for all the "
"users."
msgstr "Wenn markiert, wird \"nderungen nachverfolgen\" fr alle Nutzer aktiviert."

#: forms.py:290
msgid "Default visibility"
msgstr "Standard Sichtbarkeit"

#: forms.py:295
msgid "Track changes"
msgstr "nderungen nachverfolgen"

#: forms.py:300
msgid "Default License"
msgstr "Standard Lizenz"

#: forms.py:303
msgid "Default license for newly created books."
msgstr "Standard Lizenz fr neu erstellte Bcher."

#: forms.py:350
msgid "Anyone can register"
msgstr "Jeder kann sich registrieren"

#: forms.py:352
msgid "Anyone can register on the site and create an account"
msgstr "Jeder kann sich registrieren und ein Konto erstellen"

#: forms.py:355
msgid "Only the superuser can create books"
msgstr "Nur der Superuser kann Bcher erstellen"

#: forms.py:359
msgid "Only the superuser can import books"
msgstr "Nur der Superuser kann Bcher importieren"

#: forms.py:387 forms.py:550
msgid "Username"
msgstr "Benutzername"

#: forms.py:390 forms.py:554
msgid "Username is required."
msgstr "Nutzername ist erforderlich"

#: forms.py:391 forms.py:397 forms.py:555 forms.py:560
msgid "Illegal characters in username."
msgstr "Ungltige Zeichen im Nutzernamen"

#: forms.py:403 forms.py:566
msgid "Full name"
msgstr "Vollstndiger Name"

#: forms.py:405 forms.py:568
msgid "Full name is required."
msgstr "Vollstndiger Name bentigt."

#: forms.py:409 forms.py:572
msgid "Email"
msgstr "E-Mail"

#: forms.py:411 forms.py:574
msgid "Email is required."
msgstr "Die E-Mail ist erforderlich."

#: forms.py:415 forms.py:586
msgid "User description"
msgstr "Nutzerbeschreibung"

#: forms.py:420 forms.py:624
msgid "Password"
msgstr "Passwort"

#: forms.py:422 forms.py:429 forms.py:626 forms.py:634
msgid "Password is required."
msgstr "Passwort erforderlich"

#: forms.py:427 forms.py:631
msgid "Password confirmation"
msgstr "Passwortbesttigung"

#: forms.py:432 forms.py:636
msgid "Enter the same password as above, for verification."
msgstr "Zur Besttigung Passwort erneut eingeben"

#: forms.py:435
msgid "Notify person by email"
msgstr "Person per E-Mail benachrichtigen "

#: forms.py:440 forms.py:592
msgid "This person is a superuser"
msgstr "Diese Person ist ein Superuser"

#: forms.py:444
msgid "Successfully created new account."
msgstr "Neuer Account erfolgreich erstellt. "

#: forms.py:470
msgid "That username is already taken."
msgstr "Dieser Benutzername ist schon vergeben."

#: forms.py:476
msgid "Passwords do not match."
msgstr "Passwrter stimmen nicht berein"

#: forms.py:578
msgid "Profile picture"
msgstr "Profilbild"

#: forms.py:596
msgid "Active account"
msgstr "Aktives Konto"

#: forms.py:598
msgid "Indicate whether user's account is archived or active."
msgstr "Anzeigen, ob Nutzerkonto archiviert oder aktiv ist."

#: forms.py:620
msgid "The two password fields didn't match."
msgstr "Passwrter stimmen nicht berein!"

#: forms.py:639
msgid "Send login data"
msgstr "Zugangsdaten senden"

#: forms.py:641
msgid "Send new login data to the user via email."
msgstr "Neue Zugangsdaten an den Nutzer per Email senden"

#: forms.py:645
msgid "Short message"
msgstr "Kurznachricht"

#: forms.py:647
msgid ""
"Will be added in the bottom of email message text, after new user "
"credentials."
msgstr "Wird am Ende des Emailtextes eingefgt, unter den neuen Nutzerberechtigungen."

#: forms.py:649
msgid "You can change password in your profile settings page."
msgstr "Sie knnen Ihr Passwort in Ihren Profileinstellungen ndern."

#: forms.py:674 forms.py:747
msgid "Title"
msgstr "Titel"

#: forms.py:675 forms.py:749 tests.py:49
msgid "Title is required."
msgstr "Titel ist erforderlich."

#: forms.py:680
msgid "Description"
msgstr "Beschreibung"

#: forms.py:685
msgid "Owner"
msgstr "Inhaber"

#: forms.py:686
msgid "Book owner is required."
msgstr "Buch Inhaber ist erforderlich."

#: forms.py:691
msgid "License"
msgstr "Lizenz"

#: forms.py:693
msgid "License is required."
msgstr "Lizenz erforderlich"

#: forms.py:697
msgid "Initially hide from others"
msgstr "Vor anderen Nutzern verborgen"

#: forms.py:701
msgid "Book image"
msgstr "Bild des Buches"

#: forms.py:705
msgid "Successfully created new book."
msgstr "Neues Buch erfolgreich erstellt. "

#: forms.py:709
msgid "That book already exists."
msgstr "Dieses Buch ist bereits vorhanden."

#: forms.py:753
msgid "URL title"
msgstr "URL Titel"

#: forms.py:756
msgid "Illegal characters in URL title."
msgstr "Ungltige Zeichen in URL-Titel."

#: forms.py:757
msgid ""
"If you leave this field empty, a URL        title will be assigned "
"automatically."
msgstr "Bleibt dieses Feld leer, wird automatisch ein URL-Titel zugewiesen."

#: forms.py:797
msgid "Book PDF"
msgstr "Druckbuch PDF"

#: forms.py:801
msgid "Screen PDF"
msgstr "Bildschirm PDF"

#: forms.py:805
msgid "EPUB"
msgstr "EPUB"

#: forms.py:809
msgid "MOBI"
msgstr "MOBI"

#: forms.py:813
msgid "XHTML"
msgstr "XHTML"

#: forms.py:845
msgid "Book CSS"
msgstr "Buch CSS"

#: forms.py:853
msgid "E-Book CSS"
msgstr "E-Buch CSS"

#: forms.py:861
msgid "PDF CSS"
msgstr "PDF CSS"

#: forms.py:869
msgid "ODT CSS"
msgstr "ODT CSS"

#: forms.py:923
msgid "Successfully created new group."
msgstr "Neue Gruppe erfolgreich erstellt. "

#: forms.py:960
msgid "Successfully created new role."
msgstr "Neue Rolle erfolgreich erstellt. "

#: forms.py:993
msgid "Role for anonymous users"
msgstr "Rolle fr anonyme Nutzer."

#: forms.py:997
msgid "Role for registered users"
msgstr "Rolle fr registrierte Nutzer."

#: forms.py:1002
msgid "None"
msgstr "Keine"

#: views.py:50 templates/booktypecontrol/control_center_settings.html:27
msgid "Site Description"
msgstr "Seiteninformationen"

#: views.py:51 templates/booktypecontrol/control_center_settings.html:28
msgid "Site Appearance"
msgstr "Gestaltung der Seite"

#: views.py:52 templates/booktypecontrol/control_center_settings.html:29
msgid "Site Front Page"
msgstr "Front-/Startseite"

#: views.py:53 templates/booktypecontrol/control_center_settings.html:30
msgid "Book Licenses"
msgstr "Urheberrechtsvermerke fr Bcher"

#: views.py:54 templates/booktypecontrol/control_center_settings.html:31
msgid "Book Creation Defaults"
msgstr "Grundeinstellungen Bucherstellung"

#: views.py:55 templates/booktypecontrol/control_center_settings.html:33
msgid "Privacy"
msgstr "Datenschutz"

#: views.py:56 templates/booktypecontrol/control_center_settings.html:38
msgid "Add a New Person"
msgstr "Neue Person hinzufgen"

#: views.py:57 templates/booktypecontrol/_control_center_list_of_people.html:5
#: templates/booktypecontrol/control_center_settings.html:39
msgid "List of People"
msgstr "Liste der Personen"

#: views.py:58 templates/booktypecontrol/_control_center_archived_users.html:5
#: templates/booktypecontrol/control_center_settings.html:40
msgid "Archived Users"
msgstr "Archivierte Nutzer"

#: views.py:59 templates/booktypecontrol/control_center_settings.html:43
msgid "Add a New Book"
msgstr "Neues Buch hinzufgen"

#: views.py:60 templates/booktypecontrol/control_center_settings.html:44
msgid "List of Books"
msgstr "Liste der Bcher"

#: views.py:61 templates/booktypecontrol/control_center_settings.html:34
msgid "Publishing Options"
msgstr "Verffentlichungsoptionen"

#: views.py:62 templates/booktypecontrol/control_center_settings.html:35
msgid "Publishing Defaults"
msgstr "Standard fr Verffentlichungen"

#: views.py:63 templates/booktypecontrol/control_center_settings.html:47
msgid "Add a New Group"
msgstr "Neue Gruppe hinzufgen"

#: views.py:64 templates/booktypecontrol/control_center_settings.html:48
msgid "List of Groups"
msgstr "Liste der Gruppen"

#: views.py:65 templates/booktypecontrol/control_center_settings.html:51
msgid "Add a New Role"
msgstr "Neue Rolle hinzufgen"

#: views.py:66 templates/booktypecontrol/control_center_settings.html:52
msgid "List of Roles"
msgstr "Liste der Rollen"

#: views.py:67 templates/booktypecontrol/control_center_settings.html:32
msgid "Default Roles"
msgstr "Standardrollen"

#: views.py:88 views.py:184 views.py:281 views.py:345 views.py:409
#: views.py:451
msgid "Admin Control Center"
msgstr "Admin Control Center"

#: views.py:195
msgid "Successfully saved settings."
msgstr "Einstellungen erfolgreich gespeichert. "

#: views.py:200
msgid "Unknown error while saving changes."
msgstr "Unbekannter Fehler beim Speichern der nderungen."

#: views.py:284
msgid "Edit Person Info"
msgstr "Personeninfo editieren"

#: views.py:304 views.py:356
msgid "Successfully saved changes."
msgstr "nderungen erfolgreich gespeichert. "

#: views.py:326
msgid "Rename Book"
msgstr "Buch umbenennen"

#: views.py:330
msgid "Book name successfully changed."
msgstr "Name des Buches erfolgreich gendert. "

#: views.py:367
msgid "Your password was changed"
msgstr "Ihr Passwort wurde gendert"

#: views.py:386
#, python-format
msgid "Change Password: %s"
msgstr "Passwort ndern: %s"

#: views.py:401
msgid "Group successfully deleted."
msgstr "Gruppe erfolgreich gelscht."

#: views.py:417
msgid "Edit licence"
msgstr "Lizenz editieren"

#: views.py:423
msgid "License successfully updated."
msgstr "Lizenz erfolgreich aktualisiert."

#: views.py:435
msgid ""
"There are books remaining with this license.                     Unable to "
"remove"
msgstr "Bcher mit dieser Lizenz vorhanden. Lschen nicht mglich"

#: views.py:440
msgid "License successfully deleted."
msgstr "Lizenz erfolgreich gelscht."

#: views.py:459
msgid "Edit role"
msgstr "Rolle editieren"

#: views.py:463
msgid "Role successfully updated."
msgstr "Rolle erfolgreich aktualisiert."

#: views.py:473
msgid "Role successfully deleted."
msgstr "Rolle erfolgreich gelscht."

#: templates/control_base.html:10
msgid "Home"
msgstr "Dashboard"

#: templates/control_base.html:13
#: templates/booktypecontrol/control_center_settings.html:26
msgid "Settings"
msgstr "Einstellungen"

#: templates/control_base.html:16
#: templates/booktypecontrol/control_center_settings.html:37
msgid "People"
msgstr "Personen"

#: templates/control_base.html:19
#: templates/booktypecontrol/_control_center_list_of_groups.html:20
#: templates/booktypecontrol/_control_center_modal_person_info.html:15
#: templates/booktypecontrol/_control_center_modal_person_info.html:76
#: templates/booktypecontrol/control_center_settings.html:42
msgid "Books"
msgstr "Bcher "

#: templates/control_base.html:22
#: templates/booktypecontrol/_control_center_modal_person_info.html:16
#: templates/booktypecontrol/control_center_settings.html:46
msgid "Groups"
msgstr "Gruppen "

#: templates/control_base.html:25
#: templates/booktypecontrol/control_center_settings.html:50
msgid "Roles"
msgstr "Rollen"

#: templates/booktypecontrol/_control_center_add_person.html:4
msgid "Add new person"
msgstr "Neue Person hinzufgen"

#: templates/booktypecontrol/_control_center_archived_users.html:17
#: templates/booktypecontrol/_control_center_list_of_people.html:22
msgid "Edit Info"
msgstr "Info editieren"

#: templates/booktypecontrol/_control_center_archived_users.html:21
#: templates/booktypecontrol/_control_center_list_of_people.html:26
msgid "superuser"
msgstr "Superuser"

#: templates/booktypecontrol/_control_center_archived_users.html:24
#: templates/booktypecontrol/_control_center_list_of_people.html:29
msgid "archived"
msgstr "archiviert"

#: templates/booktypecontrol/_control_center_archived_users.html:35
msgid "There are no archived users at the moment."
msgstr "Zur Zeit gibt es keine archivierten Nutzer."

#: templates/booktypecontrol/_control_center_license.html:4
msgid "Add new license"
msgstr "Neue Lizenz hinzufgen"

#: templates/booktypecontrol/_control_center_license.html:8
msgid "Licenses"
msgstr "Lizenzen "

#: templates/booktypecontrol/_control_center_license_edit.html:6
msgid "Remove"
msgstr "Entfernen"

#: templates/booktypecontrol/_control_center_license_edit.html:9
msgid "Books licensed with"
msgstr "Lizenzierte Bcher mit"

#: templates/booktypecontrol/_control_center_license_edit.html:20
msgid "No books for this license."
msgstr "Keine Bcher fr diese Lizenz vorhanden"

#: templates/booktypecontrol/_control_center_list_of_books.html:11
msgid "Add new book"
msgstr "Neues Buch hinzufgen"

#: templates/booktypecontrol/_control_center_list_of_books.html:14
msgid "Show in a grid"
msgstr "Als Raster anzeigen"

#: templates/booktypecontrol/_control_center_list_of_books.html:15
msgid "Show in a list"
msgstr "Als Liste anzeigen"

#: templates/booktypecontrol/_control_center_list_of_groups.html:9
msgid "Add new group"
msgstr "Neue Gruppe hinzufgen"

#: templates/booktypecontrol/_control_center_list_of_groups.html:20
#: templates/booktypecontrol/_control_center_list_of_roles.html:18
#: templates/booktypecontrol/_control_center_modal_person_info.html:76
msgid "Members"
msgstr "Mitglieder"

#: templates/booktypecontrol/_control_center_list_of_groups.html:24
#: templates/booktypecontrol/_control_center_list_of_roles.html:21
msgid "Edit"
msgstr "Bearbeiten"

#: templates/booktypecontrol/_control_center_list_of_groups.html:25
#: templates/booktypecontrol/_control_center_list_of_roles.html:22
msgid "Delete"
msgstr "Lschen"

#: templates/booktypecontrol/_control_center_list_of_people.html:7
msgid "Add Person"
msgstr "Person hinzufgen"

#: templates/booktypecontrol/_control_center_list_of_people.html:7
msgid "ADD PERSON"
msgstr "Person hinzufgen"

#: templates/booktypecontrol/_control_center_list_of_people.html:19
msgid "Change password"
msgstr "Passwort ndern"

#: templates/booktypecontrol/_control_center_list_of_roles.html:9
msgid "Add new role"
msgstr "Neue Rolle hinzufgen"

#: templates/booktypecontrol/_control_center_modal_delete_group.html:7
#: templates/booktypecontrol/_control_center_modal_delete_group.html:16
msgid "Delete Group"
msgstr "Gruppe lschen"

#: templates/booktypecontrol/_control_center_modal_delete_group.html:11
msgid ""
"Are you sure you would like to delete this group? You will not be able to "
"undo this operation!"
msgstr "Gruppe sicher lschen? Gruppe kann nicht wieder hergestellt werden"

#: templates/booktypecontrol/_control_center_modal_delete_group.html:15
#: templates/booktypecontrol/_control_center_modal_delete_license.html:19
#: templates/booktypecontrol/_control_center_modal_delete_role.html:15
#: templates/booktypecontrol/_control_center_settings.html:15
msgid "Cancel"
msgstr "Abbrechen"

#: templates/booktypecontrol/_control_center_modal_delete_license.html:7
#: templates/booktypecontrol/_control_center_modal_delete_license.html:20
msgid "Delete License"
msgstr "Lizenz lschen"

#: templates/booktypecontrol/_control_center_modal_delete_license.html:12
msgid ""
"There are licensed books with this license. You should change the license "
"for these books before deleting it."
msgstr "Es sind Bcher mit dieser Lizenz vorhanden. Bitte Lizenz fr diese vorher ndern, erst dann Lizenz lschen."

#: templates/booktypecontrol/_control_center_modal_delete_license.html:14
msgid ""
"Are you sure you would like to delete this license? You will not be able to "
"undo this operation!"
msgstr "Lizenz sicher lschen? Lizenz kann nicht wieder hergestellt werden"

#: templates/booktypecontrol/_control_center_modal_delete_role.html:7
#: templates/booktypecontrol/_control_center_modal_delete_role.html:16
msgid "Delete Role"
msgstr "Rolle lschen"

#: templates/booktypecontrol/_control_center_modal_delete_role.html:11
msgid ""
"Are you sure you would like to delete this role? You will not be able to "
"undo this operation!"
msgstr "Rolle sicher lschen? Rolle kann nicht wieder hergestellt werden"

#: templates/booktypecontrol/_control_center_modal_person_info.html:13
#: templates/booktypecontrol/control_center_dashboard.html:21
msgid "Recent Activity"
msgstr "Letzte Aktivitt"

#: templates/booktypecontrol/_control_center_modal_person_info.html:28
#: templates/booktypecontrol/control_center_dashboard.html:28
msgid "ago"
msgstr "vor"

#: templates/booktypecontrol/_control_center_modal_person_info.html:41
msgid "There is no activity yet"
msgstr "Keine Aktivitt"

#: templates/booktypecontrol/_control_center_modal_person_info.html:56
msgid "Current version"
msgstr "Aktuelle Version"

#: templates/booktypecontrol/_control_center_modal_person_info.html:62
msgid "This user has no books"
msgstr "Dieser Nutzer hat keine Bcher"

#: templates/booktypecontrol/_control_center_modal_person_info.html:82
msgid "This user has no groups"
msgstr "Dieser Nutzer hat keine Gruppen"

#: templates/booktypecontrol/_control_center_modal_person_info.html:87
msgid "Close"
msgstr "Schliessen"

#: templates/booktypecontrol/_control_center_settings.html:13
msgid "Save changes"
msgstr "nderungen speichern"

#: templates/booktypecontrol/control_center_dashboard.html:10
msgid "Info"
msgstr "Info"

#: templates/booktypecontrol/control_center_dashboard.html:12
msgid "version"
msgstr "Version"

#: templates/booktypecontrol/control_center_dashboard.html:13
msgid "books"
msgstr "Bcher"

#: templates/booktypecontrol/control_center_dashboard.html:14
msgid "groups"
msgstr "Gruppen"

#: templates/booktypecontrol/control_center_dashboard.html:15
msgid "database size"
msgstr "Gre der Datenbank"

#: templates/booktypecontrol/control_center_dashboard.html:16
msgid "files size"
msgstr "Gre der Dateien "

#: templates/booktypecontrol/control_center_dashboard.html:50
msgid "Online Users"
msgstr "Online Nutzer"

#: templates/booktypecontrol/control_center_dashboard.html:62
#: templates/booktypecontrol/control_center_dashboard.html:93
msgid "Working on:"
msgstr "Arbeiten an:"

#: templates/booktypecontrol/control_center_dashboard.html:76
msgid "No online users"
msgstr "Kein Onlinenutzer"

#: templates/booktypecontrol/control_center_dashboard.html:83
msgid "Most Active Users"
msgstr "Aktivste Nutzer"

#: templates/booktypecontrol/control_center_dashboard.html:83
#: templates/booktypecontrol/control_center_dashboard.html:107
msgid "view all"
msgstr "Siehe alle"

#: templates/booktypecontrol/control_center_dashboard.html:100
msgid "No most active users"
msgstr "Keine aktivsten Nutzer"

#: templates/booktypecontrol/control_center_dashboard.html:107
msgid "Latest Books"
msgstr "Neueste Bcher"

#: templates/booktypecontrol/control_center_dashboard.html:120
msgid "No books here"
msgstr "Keine Bcher vorhanden"

#: templates/booktypecontrol/control_center_dashboard.html:127
msgid "Most Active Books"
msgstr "Aktivste Bcher"

#: templates/booktypecontrol/control_center_dashboard.html:140
msgid "No active books here"
msgstr "Keine aktiven Bcher vorhanden"

#: templates/booktypecontrol/new_person_email.html:3
#, python-format
msgid ""
"You've just had a Booktype account created for you! Please head over to "
"%(server)s to log in. Here are your login credentials:"
msgstr "Soeben wurde ein Booktype-Konto fr Sie erstellt! Bitte gehen Sie zu %(server)s und loggen sich ein. Hier sind Ihre Zugangsdaten:"

#: templates/booktypecontrol/new_person_email.html:7
#: templates/booktypecontrol/password_changed_email.html:5
msgid "Username:"
msgstr "Benutzername:"

#: templates/booktypecontrol/new_person_email.html:8
#: templates/booktypecontrol/password_changed_email.html:6
msgid "Password:"
msgstr "Passwort:"

#: templates/booktypecontrol/password_changed_email.html:2
msgid "Your password was changed. Here are your new login credentials:"
msgstr "Ihr Passwort wurde gendert. Hier sind Ihre neuen Zugangsdaten:"
dnl config.m4 for extension r3

PHP_ARG_WITH(r3, for r3 support,
[  --with-r3             Include r3 support])

dnl PHP_ARG_ENABLE(r3, whether to enable r3 support,
dnl Make sure that the comment is aligned:
dnl [  --enable-r3           Enable r3 support])

if test "$PHP_R3" != "no"; then
  SEARCH_PATH="/usr/local /usr"
  SEARCH_FOR="/include/r3/r3.h"
  if test -r $PHP_R3/$SEARCH_FOR; then
    R3_DIR=$PHP_R3
  else
    AC_MSG_CHECKING([for r3 files in default path])
    for i in $SEARCH_PATH ; do
      if test -r $i/$SEARCH_FOR; then
        R3_DIR=$i
        AC_MSG_RESULT(found in $i)
      fi
    done
  fi

  if test -z "$R3_DIR"; then
    AC_MSG_RESULT([not found])
    AC_MSG_ERROR([Please reinstall the r3 distribution])
  fi

echo $R3_DIR
  dnl # --with-r3 -> add include path
  PHP_ADD_INCLUDE($R3_DIR/include)

  LIBNAME=r3
  LIBSYMBOL=r3_route_create

  PHP_CHECK_LIBRARY($LIBNAME,$LIBSYMBOL,
  [
    PHP_ADD_LIBRARY_WITH_PATH($LIBNAME, $R3_DIR/lib, R3_SHARED_LIBADD)
    AC_DEFINE(HAVE_R3LIB,1,[ ])
  ],[
    AC_MSG_ERROR([wrong r3 lib version or lib not found])
  ],[
    -L$R3_DIR/lib -lm
  ])

  PHP_SUBST(R3_SHARED_LIBADD)

  PHP_NEW_EXTENSION(r3, [ct_helper.c hash.c php_expandable_mux.c php_r3.c r3_controller.c r3_functions.c r3_mux.c r3_persistent.c], $ext_shared)
fi
<?php
/*
 * This file is part of the PommProject/Foundation package.
 *
 * (c) 2014 - 2015 Grgoire HUBERT <hubert.greg@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PommProject\Foundation\Test\Unit\Listener;

use PommProject\Foundation\Tester\FoundationSessionAtoum;
use PommProject\Foundation\Session\Session;
use Mock\PommProject\Foundation\Listener\Listener as MockListener;

class ListenerPooler extends FoundationSessionAtoum
{
    protected function initializeSession(Session $session)
    {
        $session
            ->registerClient(new MockListener('pika'))
            ->registerClient(new MockListener('chu'))
            ;
    }

    public function testNotify()
    {
        $session = $this->buildSession();
        $session->registerClientPooler($this->newTestedInstance());

        $this
            ->assert('notifying one listener.')
            ->object(
                $session
                    ->getPoolerForType('listener')
                    ->notify('pika', [ 'data' => 1 ])
                )
            ->isInstanceOf('\PommProject\Foundation\Listener\ListenerPooler')
            ->mock($session->getClient('listener', 'pika'))
            ->call('notify')
            ->once()
            ->mock($session->getClient('listener', 'chu'))
            ->call('notify')
            ->never()
            ->assert('notifying lot of listeners.')
            ->object(
                $session
                    ->getPoolerForType('listener')
                    ->notify(['pika', 'chu', 'whatever'], [ 'data' => 1 ])
            )
            ->mock($session->getClient('listener', 'pika'))
            ->call('notify')
            ->once()
            ->mock($session->getClient('listener', 'chu'))
            ->call('notify')
            ->once()
            ->assert('notifying all listeners.')
            ->object(
                $session
                    ->getPoolerForType('listener')
                    ->notify('*', [ 'data' => 1 ])
            )
            ->isInstanceOf('\PommProject\Foundation\Listener\ListenerPooler')
            ->mock($session->getClient('listener', 'pika'))
            ->call('notify')
            ->once()
            ->mock($session->getClient('listener', 'chu'))
            ->call('notify')
            ->once()
            ->assert('notifying a listeners with subspace.')
            ->object(
                $session
                    ->getPoolerForType('listener')
                    ->notify('pika:plop', [ 'data' => 1 ])
                )
            ->isInstanceOf('\PommProject\Foundation\Listener\ListenerPooler')
            ->mock($session->getClient('listener', 'pika'))
            ->call('notify')
            ->once()
            ->mock($session->getClient('listener', 'chu'))
            ->call('notify')
            ->never()
            ;
    }
}
<?php
/**
 * This file is part of the Tmdb PHP API created by Michael Roterman.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @package Tmdb
 * @author Michael Roterman <michael@wtfz.net>
 * @copyright (c) 2013, Michael Roterman
 * @version 0.0.1
 */
require_once '../../../vendor/autoload.php';
require_once '../../../apikey.php';

$token  = new \Tmdb\ApiToken(TMDB_API_KEY);
$client = new \Tmdb\Client($token);

$credit = $client->getCreditsApi()->getCredit('52542282760ee313280017f9');

var_dump($credit);
{% load i18n %}
{% extends "html/messaging/page.html" %}

{% block title %}{% trans %}Settings{% endtrans %} | {% trans %}Messaging{% endtrans %}{% endblock %}

{% block class_admin_settings %}sidebar-link-active{% endblock %}

{% block module_title %}{% trans %}Messaging{% endtrans %}{% endblock %}
{% block module_subtitle %}{% trans %}Settings{% endtrans %}{% endblock %}

{% block module_topmenu %}
<a href="{% url messaging_settings_view %}" class="top-menu view-link">{% trans %}View{% endtrans %}</a>
<a href="{% url messaging_settings_edit %}" class="top-menu edit-link-active">{% trans %}Edit{% endtrans %}</a>
{% endblock %}

{% block module_content %}

<form action="" method="post" class="content-form">
{% csrf_token %}
    <ul class="content-form-fields">
        {{ form.as_ul()|htsafe }}
    </ul>
    <div class="content-form-submit">
        <input type="submit" name="save" value="{% trans %}Save{% endtrans %}" />
		<input type="submit" name="cancel" value="{% trans %}Cancel{% endtrans %}" class="cancel" />
    </div>
</form>
{% endblock %}
{% extends "json/services/page.json" %}
{% block module_content %}
   {"agent":
         {
          "id": {{ view_agent.id }},
          "url": "http://{{ site_domain }}{% url services_agent_view view_agent.id %}",
          "name": "{{ view_agent }}",
          "active": {{ view_agent.active }},
          "occupied": {{ view_agent.occupied }},
          {% if view_agent.available_from -%}
          "available_from": {{ view_agent.available_from }},
          {% else -%}
          "available_from": null,
          {% endif -%}
          {% if view_agent.available_to -%}
          "available_to": {{ view_agent.available_to }},
          {% else -%}
          "available_to": null,
          {% endif -%}
          "tickets": [
          {% for ticket in tickets -%}
             {
             "id": {{ ticket.id }},
             "url": "http://{{ site_domain }}{% url services_ticket_view ticket.id %}",
             "name": "{{ ticket }}",
             {% if ticket.caller -%}
             "caller": {
                        "id": {{ ticket.caller_id }},
                        "url": "http://{{ site_domain }}{% url identities_contact_view ticket.caller_id %}",
                        "name": "{{ ticket.caller }}"
                       },
             {% else -%}
             "caller": null,
             {% endif -%}
             "assigned": [
                {%- for assignee in ticket.assigned.all() %}
                   {
                    "id": {{ assignee.id }},
                    "url": "http://{{ site_domain }}{% url services_agent_view assignee.id %}",
                    "name": "{{ assignee }}"
                   {% if loop.last %}}{% else %}},{% endif %}
                {%- endfor -%}
             ],
             "status": {
                        "id": {{ ticket.status_id }},
                        "url": "http://{{ site_domain }}{% url services_status_view ticket.status_id %}",
                        "name": "{{ ticket.status }}"
                       },
             {%- if ticket.queue %}
             "queue": {
                       "id": {{ ticket.queue_id }},
                       "url": "http://{{ site_domain }}{% url services_queue_view ticket.queue_id %}",
                       "name": "{{ ticket.queue }}"
                      },
             {% else -%}
             "queue": null,
             {% endif -%}
             {% if ticket.service -%}
             "service": {
                         "id": {{ ticket.service_id }},
                         "url": "http://{{ site_domain }}{% url services_service_view ticket.service_id %}",
                         "name": "{{ ticket.service }}"
                        },
             {% else -%}
             "service": null,
             {% endif -%}
             {% if ticket.sla -%}
             "sla": {
                     "id": {{ ticket.sla_id }},
                     "url": "http://{{ site_domain }}{% url services_sla_view ticket.sla_id %}",
                     "name": "{{ ticket.sla }}"
                    }
             {% else -%}
             "sla": null
             {% endif -%}
             {% if loop.last -%}
             }
             {% else -%}
             },
             {% endif -%}
          {% endfor -%}
          ]
          }
   }
{%- endblock %}
CKEditor 4 Changelog
====================

## CKEditor 4.3.4

Fixed Issues:

* [#11597](http://dev.ckeditor.com/ticket/11597): [IE11] Fixed: Error thrown when trying to open the [preview](http://ckeditor.com/addon/preview) using the keyboard.
* [#11544](http://dev.ckeditor.com/ticket/11544): [Placeholders](http://ckeditor.com/addon/placeholder) will no longer be upcasted in parents not accepting `<span>` elements.
* [#8663](http://dev.ckeditor.com/ticket/8663): Fixed [`element.renameNode()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.element-method-renameNode) not clearing the [`element.getName()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.element-method-getName) cache.
* [#11574](http://dev.ckeditor.com/ticket/11574): Fixed: *Backspace* destroying the DOM structure if an inline editable is placed in a list item.
* [#11603](http://dev.ckeditor.com/ticket/11603): Fixed: [Table Resize](http://ckeditor.com/addon/tableresize) attaches to tables outside the editable.
* [#9205](http://dev.ckeditor.com/ticket/9205), [#7805](http://dev.ckeditor.com/ticket/7805), [#8216](http://dev.ckeditor.com/ticket/8216): Fixed: `{cke_protected_1}` appearing in data in various cases where HTML comments are placed next to `"` or `'`.
* [#11635](http://dev.ckeditor.com/ticket/11635): Fixed: Some attributes are not protected before the content is passed through the fix bin.
* [#11660](http://dev.ckeditor.com/ticket/11660): [IE] Fixed: Table content is lost when some extra markup is inside the table.
* [#11641](http://dev.ckeditor.com/ticket/11641): Fixed: Switching between modes in the classic editor removes content styles for the inline editor.
* [#11568](http://dev.ckeditor.com/ticket/11568): Fixed: [Styles](http://ckeditor.com/addon/stylescombo) drop-down list is not enabled on selection change.

## CKEditor 4.3.3

Fixed Issues:

* [#11500](http://dev.ckeditor.com/ticket/11500): [Webkit/Blink] Fixed: Selection lost when setting data in another inline editor. Additionally, [`selection.removeAllRanges()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.selection-method-removeAllRanges) is now scoped to selection's [root](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.selection-property-root).
* [#11104](http://dev.ckeditor.com/ticket/11104): [IE] Fixed: Various issues with scrolling and selection when focusing widgets.
* [#11487](http://dev.ckeditor.com/ticket/11487): Moving mouse over the [Enhanced Image](http://ckeditor.com/addon/image2) widget will no longer change the value returned by the [`editor.checkDirty()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-checkDirty) method.
* [#8673](http://dev.ckeditor.com/ticket/8673): [WebKit] Fixed: Cannot select and remove the [Page Break](http://ckeditor.com/addon/pagebreak).
* [#11413](http://dev.ckeditor.com/ticket/11413): Fixed: Incorrect [`editor.execCommand()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-execCommand) behavior.
* [#11438](http://dev.ckeditor.com/ticket/11438): Splitting table cells vertically is no longer changing table structure.
* [#8899](http://dev.ckeditor.com/ticket/8899): Fixed: Links in the [About CKEditor](http://ckeditor.com/addon/about) dialog window now open in a new browser window or tab.
* [#11490](http://dev.ckeditor.com/ticket/11490): Fixed: [Menu button](http://ckeditor.com/addon/menubutton) panel not showing in the source mode.
* [#11417](http://dev.ckeditor.com/ticket/11417): The [`widget.doubleclick`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget-event-doubleclick) event is not canceled anymore after editing was triggered.
* [#11253](http://dev.ckeditor.com/ticket/11253): [IE] Fixed: Clipped upload button in the [Enhanced Image](http://ckeditor.com/addon/image2) dialog window.
* [#11359](http://dev.ckeditor.com/ticket/11359): Standardized the way anchors are discovered by the [Link](http://ckeditor.com/addon/link) plugin.
* [#11058](http://dev.ckeditor.com/ticket/11058): [IE8] Fixed: Error when deleting a table row.
* [#11508](http://dev.ckeditor.com/ticket/11508): Fixed: [`htmlDataProcessor`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlDataProcessor) discovering protected attributes within other attributes' values.
* [#11533](http://dev.ckeditor.com/ticket/11533): Widgets: Avoid recurring upcasts if the DOM structure was modified during an upcast.
* [#11400](http://dev.ckeditor.com/ticket/11400): Fixed: The [`domObject.removeAllListeners()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.domObject-method-removeAllListeners) method does not remove custom listeners completely.
* [#11493](http://dev.ckeditor.com/ticket/11493): Fixed: The [`selection.getRanges()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.selection-method-getRanges) method does not override cached ranges when used with the `onlyEditables` argument.
* [#11390](http://dev.ckeditor.com/ticket/11390): [IE] All [XML](http://ckeditor.com/addon/xml) plugin [methods](http://docs.ckeditor.com/#!/api/CKEDITOR.xml) now work in IE10+.
* [#11542](http://dev.ckeditor.com/ticket/11542): [IE11] Fixed: Blurry toolbar icons when Right-to-Left UI language is set.
* [#11504](http://dev.ckeditor.com/ticket/11504): Fixed: When [`config.fullPage`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-fullPage) is set to `true`, entities are not encoded in editor output.
* [#11004](http://dev.ckeditor.com/ticket/11004): Integrated [Enhanced Image](http://ckeditor.com/addon/image2) dialog window with [Advanced Content Filter](http://docs.ckeditor.com/#!/guide/dev_advanced_content_filter).
* [#11439](http://dev.ckeditor.com/ticket/11439): Fixed: Properties get cloned in the Cell Properties dialog window if multiple cells are selected.

## CKEditor 4.3.2

Fixed Issues:

* [#11331](http://dev.ckeditor.com/ticket/11331): A menu button will have a changed label when selected instead of using the `aria-pressed` attribute.
* [#11177](http://dev.ckeditor.com/ticket/11177): Widget drag handler improvements:
  * [#11176](http://dev.ckeditor.com/ticket/11176): Fixed: Initial position is not updated when the widget data object is empty.
  * [#11001](http://dev.ckeditor.com/ticket/11001): Fixed: Multiple synchronous layout recalculations are caused by initial drag handler positioning causing performance issues.
  * [#11161](http://dev.ckeditor.com/ticket/11161): Fixed: Drag handler is not repositioned in various situations.
  * [#11281](http://dev.ckeditor.com/ticket/11281): Fixed: Drag handler and mask are duplicated after widget reinitialization.
* [#11207](http://dev.ckeditor.com/ticket/11207): [Firefox] Fixed: Misplaced [Enhanced Image](http://ckeditor.com/addon/image2) resizer in the inline editor.
* [#11102](http://dev.ckeditor.com/ticket/11102): `CKEDITOR.template` improvements:
  * [#11102](http://dev.ckeditor.com/ticket/11102): Added newline character support.
  * [#11216](http://dev.ckeditor.com/ticket/11216): Added "\\'" substring support.
* [#11121](http://dev.ckeditor.com/ticket/11121): [Firefox] Fixed: High Contrast mode is enabled when the editor is loaded in a hidden iframe.
* [#11350](http://dev.ckeditor.com/ticket/11350): The default value of [`config.contentsCss`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-contentsCss) is affected by [`CKEDITOR.getUrl()`](http://docs.ckeditor.com/#!/api/CKEDITOR-method-getUrl).
* [#11097](http://dev.ckeditor.com/ticket/11097): Improved the [Autogrow](http://ckeditor.com/addon/autogrow) plugin performance when dealing with very big tables.
* [#11290](http://dev.ckeditor.com/ticket/11290): Removed redundant code in the [Source Dialog](http://ckeditor.com/addon/sourcedialog) plugin.
* [#11133](http://dev.ckeditor.com/ticket/11133): [Page Break](http://ckeditor.com/addon/pagebreak) becomes editable if pasted.
* [#11126](http://dev.ckeditor.com/ticket/11126): Fixed: Native Undo executed once the bottom of the snapshot stack is reached.
* [#11131](http://dev.ckeditor.com/ticket/11131): [Div Editing Area](http://ckeditor.com/addon/divarea): Fixed: Error thrown when switching to source mode if the selection was in widget's nested editable.
* [#11139](http://dev.ckeditor.com/ticket/11139): [Div Editing Area](http://ckeditor.com/addon/divarea): Fixed: Elements Path is not cleared after switching to source mode.
* [#10778](http://dev.ckeditor.com/ticket/10778): Fixed a bug with range enlargement. The range no longer expands to visible whitespace.
* [#11146](http://dev.ckeditor.com/ticket/11146): [IE] Fixed: Preview window switches Internet Explorer to Quirks Mode.
* [#10762](http://dev.ckeditor.com/ticket/10762): [IE] Fixed: JavaScript code displayed in preview window's URL bar.
* [#11186](http://dev.ckeditor.com/ticket/11186): Introduced the [`widgets.repository.addUpcastCallback()`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget.repository-method-addUpcastCallback) method that allows to block upcasting given element to a widget.
* [#11307](http://dev.ckeditor.com/ticket/11307): Fixed: Paste as Plain Text conflict with the [MooTools](http://mootools.net) library.
* [#11140](http://dev.ckeditor.com/ticket/11140): [IE11] Fixed: Anchors are not draggable.
* [#11379](http://dev.ckeditor.com/ticket/11379): Changed default contents `line-height` to unitless values to avoid huge text overlapping (like in [#9696](http://dev.ckeditor.com/ticket/9696)).
* [#10787](http://dev.ckeditor.com/ticket/10787): [Firefox] Fixed: Broken replacement of text while pasting into `div`-based editor.
* [#10884](http://dev.ckeditor.com/ticket/10884): Widgets integration with the [Show Blocks](http://ckeditor.com/addon/showblocks) plugin.
* [#11021](http://dev.ckeditor.com/ticket/11021): Fixed: An error thrown when selecting entire editable contents while fake selection is on.
* [#11086](http://dev.ckeditor.com/ticket/11086): [IE8] Re-enable inline widgets drag&drop in Internet Explorer 8.
* [#11372](http://dev.ckeditor.com/ticket/11372): Widgets: Special characters encoded twice in nested editables.
* [#10068](http://dev.ckeditor.com/ticket/10068): Fixed: Support for protocol-relative URLs.
* [#11283](http://dev.ckeditor.com/ticket/11283): [Enhanced Image](http://ckeditor.com/addon/image2): A `<div>` element with `text-align: center` and an image inside is not recognised correctly.
* [#11196](http://dev.ckeditor.com/ticket/11196): [Accessibility Instructions](http://ckeditor.com/addon/a11yhelp): Allowed additional keyboard button labels to be translated in the dialog window.

## CKEditor 4.3.1

**Important Notes:**

* To match the naming convention, the `language` button is now `Language` ([#11201](http://dev.ckeditor.com/ticket/11201)).
* [Enhanced Image](http://ckeditor.com/addon/image2) button, context menu, command, and icon names match those of the [Image](http://ckeditor.com/addon/image) plugin ([#11222](http://dev.ckeditor.com/ticket/11222)).

Fixed Issues:

* [#11244](http://dev.ckeditor.com/ticket/11244): Changed: The [`widget.repository.checkWidgets()`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget.repository-method-checkWidgets) method now fires the [`widget.repository.checkWidgets`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget.repository-event-checkWidgets) event, so from CKEditor 4.3.1 it is preferred to use the method rather than fire the event.
* [#11171](http://dev.ckeditor.com/ticket/11171): Fixed: [`editor.insertElement()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-insertElement) and [`editor.insertText()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-insertText) methods do not call the [`widget.repository.checkWidgets()`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget.repository-method-checkWidgets) method.
* [#11085](http://dev.ckeditor.com/ticket/11085): [IE8] Replaced preview generated by the [Mathematical Formulas](http://ckeditor.com/addon/mathjax) widget with a placeholder.
* [#11044](http://dev.ckeditor.com/ticket/11044): Enhanced WAI-ARIA support for the [Language](http://ckeditor.com/addon/language) plugin drop-down menu.
* [#11075](http://dev.ckeditor.com/ticket/11075): With drop-down menu button focused, pressing the *Down Arrow* key will now open the menu and focus its first option.
* [#11165](http://dev.ckeditor.com/ticket/11165): Fixed: The [File Browser](http://ckeditor.com/addon/filebrowser) plugin cannot be removed from the editor.
* [#11159](http://dev.ckeditor.com/ticket/11159): [IE9-10] [Enhanced Image](http://ckeditor.com/addon/image2): Fixed buggy discovery of image dimensions.
* [#11101](http://dev.ckeditor.com/ticket/11101): Drop-down lists no longer break when given double quotes.
* [#11077](http://dev.ckeditor.com/ticket/11077): [Enhanced Image](http://ckeditor.com/addon/image2): Empty undo step recorded when resizing the image.
* [#10853](http://dev.ckeditor.com/ticket/10853): [Enhanced Image](http://ckeditor.com/addon/image2): Widget has paragraph wrapper when de-captioning unaligned image.
* [#11198](http://dev.ckeditor.com/ticket/11198): Widgets: Drag handler is not fully visible when an inline widget is in a heading.
* [#11132](http://dev.ckeditor.com/ticket/11132): [Firefox] Fixed: Caret is lost after drag and drop of an inline widget.
* [#11182](http://dev.ckeditor.com/ticket/11182): [IE10-11] Fixed: Editor crashes (IE11) or works with minor issues (IE10) if a page is loaded in Quirks Mode. See [`env.quirks`](http://docs.ckeditor.com/#!/api/CKEDITOR.env-property-quirks) for more details.
* [#11204](http://dev.ckeditor.com/ticket/11204): Added `figure` and `figcaption` styles to the `contents.css` file so [Enhanced Image](http://ckeditor.com/addon/image2) looks nicer.
* [#11202](http://dev.ckeditor.com/ticket/11202): Fixed: No newline in [BBCode](http://ckeditor.com/addon/bbcode) mode.
* [#10890](http://dev.ckeditor.com/ticket/10890): Fixed: Error thrown when pressing the *Delete* key in a list item.
* [#10055](http://dev.ckeditor.com/ticket/10055): [IE8-10] Fixed: *Delete* pressed on a selected image causes the browser to go back.
* [#11183](http://dev.ckeditor.com/ticket/11183): Fixed: Inserting a horizontal rule or a table in multiple row selection causes a browser crash. Additionally, the [`editor.insertElement()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-insertElement) method does not insert the element into every range of a selection any more.
* [#11042](http://dev.ckeditor.com/ticket/11042): Fixed: Selection made on an element containing a non-editable element was not auto faked.
* [#11125](http://dev.ckeditor.com/ticket/11125): Fixed: Keyboard navigation through menu and drop-down items will now cycle.
* [#11011](http://dev.ckeditor.com/ticket/11011): Fixed: The [`editor.applyStyle()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-applyStyle) method removes attributes from nested elements.
* [#11179](http://dev.ckeditor.com/ticket/11179): Fixed: [`editor.destroy()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-destroy) does not cleanup content generated by the [Table Resize](http://ckeditor.com/addon/tableresize) plugin for inline editors.
* [#11237](http://dev.ckeditor.com/ticket/11237): Fixed: Table border attribute value is deleted when pasting content from Microsoft Word.
* [#11250](http://dev.ckeditor.com/ticket/11250): Fixed: HTML entities inside the `<textarea>` element are not encoded.
* [#11260](http://dev.ckeditor.com/ticket/11260): Fixed: Initially disabled buttons are not read by JAWS as disabled.
* [#11200](http://dev.ckeditor.com/ticket/11200):  Added [Clipboard](http://ckeditor.com/addon/clipboard) plugin as a dependency for [Widget](http://ckeditor.com/addon/widget) to fix drag and drop.

## CKEditor 4.3

New Features:

* [#10612](http://dev.ckeditor.com/ticket/10612): Internet Explorer 11 support.
* [#10869](http://dev.ckeditor.com/ticket/10869): Widgets: Added better integration with the [Elements Path](http://ckeditor.com/addon/elementspath) plugin.
* [#10886](http://dev.ckeditor.com/ticket/10886): Widgets: Added tooltip to the drag handle.
* [#10933](http://dev.ckeditor.com/ticket/10933): Widgets: Introduced drag and drop of block widgets with the [Line Utilities](http://ckeditor.com/addon/lineutils) plugin.
* [#10936](http://dev.ckeditor.com/ticket/10936): Widget System changes for easier integration with other dialog systems.
* [#10895](http://dev.ckeditor.com/ticket/10895): [Enhanced Image](http://ckeditor.com/addon/image2): Added file browser integration.
* [#11002](http://dev.ckeditor.com/ticket/11002): Added the [`draggable`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget.definition-property-draggable) option to disable drag and drop support for widgets.
* [#10937](http://dev.ckeditor.com/ticket/10937): [Mathematical Formulas](http://ckeditor.com/addon/mathjax) widget improvements:
  * loading indicator ([#10948](http://dev.ckeditor.com/ticket/10948)),
  * applying paragraph changes (like font color change) to iframe ([#10841](http://dev.ckeditor.com/ticket/10841)),
  * Firefox and IE9 clipboard fixes ([#10857](http://dev.ckeditor.com/ticket/10857)),
  * fixing same origin policy issue ([#10840](http://dev.ckeditor.com/ticket/10840)),
  * fixing undo bugs ([#10842](http://dev.ckeditor.com/ticket/10842), [#10930](http://dev.ckeditor.com/ticket/10930)),
  * fixing other minor bugs.
* [#10862](http://dev.ckeditor.com/ticket/10862): [Placeholder](http://ckeditor.com/addon/placeholder) plugin was rewritten as a widget.
* [#10822](http://dev.ckeditor.com/ticket/10822): Added styles system integration with non-editable elements (for example widgets) and their nested editables. Styles cannot change non-editable content and are applied in nested editable only if allowed by its type and content filter.
* [#10856](http://dev.ckeditor.com/ticket/10856): Menu buttons will now toggle the visibility of their panels when clicked multiple times. [Language](http://ckeditor.com/addon/language) plugin fixes: Added active language highlighting, added an option to remove the language.
* [#10028](http://dev.ckeditor.com/ticket/10028): New [`config.dialog_noConfirmCancel`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-dialog_noConfirmCancel) configuration option that eliminates the need to confirm closing of a dialog window when the user changed any of its fields.
* [#10848](http://dev.ckeditor.com/ticket/10848): Integrate remaining plugins ([Styles](http://ckeditor.com/addon/stylescombo), [Format](http://ckeditor.com/addon/format), [Font](http://ckeditor.com/addon/font), [Color Button](http://ckeditor.com/addon/colorbutton), [Language](http://ckeditor.com/addon/language) and [Indent](http://ckeditor.com/addon/indent)) with [active filter](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-activeFilter).
* [#10855](http://dev.ckeditor.com/ticket/10855): Change the extension of emoticons in the [BBCode](http://ckeditor.com/addon/bbcode) sample from GIF to PNG.

Fixed Issues:

* [#10831](http://dev.ckeditor.com/ticket/10831): [Enhanced Image](http://ckeditor.com/addon/image2): Merged `image2inline` and `image2block` into one `image2` widget.
* [#10835](http://dev.ckeditor.com/ticket/10835): [Enhanced Image](http://ckeditor.com/addon/image2): Improved visibility of the resize handle.
* [#10836](http://dev.ckeditor.com/ticket/10836): [Enhanced Image](http://ckeditor.com/addon/image2): Preserve custom mouse cursor while resizing the image.
* [#10939](http://dev.ckeditor.com/ticket/10939): [Firefox] [Enhanced Image](http://ckeditor.com/addon/image2): hovering the image causes it to change.
* [#10866](http://dev.ckeditor.com/ticket/10866): Fixed: Broken *Tab* key navigation in the [Enhanced Image](http://ckeditor.com/addon/image2) dialog window.
* [#10833](http://dev.ckeditor.com/ticket/10833): Fixed: *Lock ratio* option should be on by default in the [Enhanced Image](http://ckeditor.com/addon/image2) dialog window.
* [#10881](http://dev.ckeditor.com/ticket/10881): Various improvements to *Enter* key behavior in nested editables.
* [#10879](http://dev.ckeditor.com/ticket/10879): [Remove Format](http://ckeditor.com/addon/removeformat) should not leak from a nested editable.
* [#10877](http://dev.ckeditor.com/ticket/10877): Fixed: [WebSpellChecker](http://ckeditor.com/addon/wsc) fails to apply changes if a nested editable was focused.
* [#10877](http://dev.ckeditor.com/ticket/10877): Fixed: [SCAYT](http://ckeditor.com/addon/wsc) blocks typing in nested editables.
* [#11079](http://dev.ckeditor.com/ticket/11079): Add button icons to the [Placeholder](http://ckeditor.com/addon/placeholder) sample.
* [#10870](http://dev.ckeditor.com/ticket/10870): The `paste` command is no longer being disabled when the clipboard is empty.
* [#10854](http://dev.ckeditor.com/ticket/10854): Fixed: Firefox prepends `<br>` to `<body>`, so it is stripped by the HTML data processor.
* [#10823](http://dev.ckeditor.com/ticket/10823): Fixed: [Link](http://ckeditor.com/addon/link) plugin does not work with non-editable content.
* [#10828](http://dev.ckeditor.com/ticket/10828): [Magic Line](http://ckeditor.com/addon/magicline) integration with the Widget System.
* [#10865](http://dev.ckeditor.com/ticket/10865): Improved hiding copybin, so copying widgets works smoothly.
* [#11066](http://dev.ckeditor.com/ticket/11066): Widget's private parts use CSS reset.
* [#11027](http://dev.ckeditor.com/ticket/11027): Fixed: Block commands break on widgets; added the [`contentDomInvalidated`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-contentDomInvalidated) event.
* [#10430](http://dev.ckeditor.com/ticket/10430): Resolve dependence of the [Image](http://ckeditor.com/addon/image) plugin on the [Form Elements](http://ckeditor.com/addon/forms) plugin.
* [#10911](http://dev.ckeditor.com/ticket/10911): Fixed: Browser *Alt* hotkeys will no longer be blocked while a widget is focused.
* [#11082](http://dev.ckeditor.com/ticket/11082): Fixed: Selected widget is not copied or cut when using toolbar buttons or context menu.
* [#11083](http://dev.ckeditor.com/ticket/11083): Fixed list and div element application to block widgets.
* [#10887](http://dev.ckeditor.com/ticket/10887): Internet Explorer 8 compatibility issues related to the Widget System.
* [#11074](http://dev.ckeditor.com/ticket/11074): Temporarily disabled inline widget drag and drop, because of seriously buggy native `range#moveToPoint` method.
* [#11098](http://dev.ckeditor.com/ticket/11098): Fixed: Wrong selection position after undoing widget drag and drop.
* [#11110](http://dev.ckeditor.com/ticket/11110): Fixed: IFrame and Flash objects are being incorrectly pasted in certain conditions.
* [#11129](http://dev.ckeditor.com/ticket/11129): Page break is lost when loading data.
* [#11123](http://dev.ckeditor.com/ticket/11123): [Firefox] Widget is destroyed after being dragged outside of `<body>`.
* [#11124](http://dev.ckeditor.com/ticket/11124): Fixed the [Elements Path](http://ckeditor.com/addon/elementspath) in an editor using the [Div Editing Area](http://ckeditor.com/addon/divarea).

## CKEditor 4.3 Beta

New Features:

* [#9764](http://dev.ckeditor.com/ticket/9764): Widget System.
  * [Widget plugin](http://ckeditor.com/addon/widget) introducing the [Widget API](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.widget).
  * New [`editor.enterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-enterMode) and [`editor.shiftEnterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-shiftEnterMode) properties &ndash; normalized versions of [`config.enterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-enterMode) and [`config.shiftEnterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-shiftEnterMode).
  * Dynamic editor settings. Starting from CKEditor 4.3 Beta, *Enter* mode values and [content filter](http://docs.ckeditor.com/#!/guide/dev_advanced_content_filter) instances may be changed dynamically (for example when the caret was placed in an element in which editor features should be adjusted). When you are implementing a new editor feature, you should base its behavior on [dynamic](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-activeEnterMode) or [static](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-enterMode) *Enter* mode values depending on whether this feature works in selection context or globally on editor content.
      * Dynamic *Enter* mode values &ndash; [`editor.setActiveEnterMode()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setActiveEnterMode) method, [`editor.activeEnterModeChange`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-activeEnterModeChange) event, and two properties: [`editor.activeEnterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-activeEnterMode) and [`editor.activeShiftEnterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-activeShiftEnterMode).
      * Dynamic content filter instances &ndash; [`editor.setActiveFilter()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setActiveFilter) method, [`editor.activeFilterChange`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-activeFilterChange) event, and [`editor.activeFilter`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-activeFilter) property.
  * "Fake" selection was introduced. It makes it possible to virtually select any element when the real selection remains hidden. See the  [`selection.fake()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.selection-method-fake) method.
  * Default [`htmlParser.filter`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.filter) rules are not applied to non-editable elements (elements with `contenteditable` attribute set to `false` and their descendants) anymore. To add a rule which will be applied to all elements you need to pass an additional argument to the [`filter.addRules()`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.filter-method-addRules) method.
  * Dozens of new methods were introduced &ndash; most interesting ones:
      * [`document.find()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.document-method-find),
      * [`document.findOne()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.document-method-findOne),
      * [`editable.insertElementIntoRange()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editable-method-insertElementIntoRange),
      * [`range.moveToClosestEditablePosition()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.range-method-moveToClosestEditablePosition),
      * New methods for [`htmlParser.node`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.node) and [`htmlParser.element`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.element).
* [#10659](http://dev.ckeditor.com/ticket/10659): New [Enhanced Image](http://ckeditor.com/addon/image2) plugin that introduces a widget with integrated image captions, an option to center images, and dynamic "click and drag" resizing.
* [#10664](http://dev.ckeditor.com/ticket/10664): New [Mathematical Formulas](http://ckeditor.com/addon/mathjax) plugin that introduces the MathJax widget.
* [#7987](https://dev.ckeditor.com/ticket/7987): New [Language](http://ckeditor.com/addon/language) plugin that implements Language toolbar button to support [WCAG 3.1.2 Language of Parts](http://www.w3.org/TR/UNDERSTANDING-WCAG20/meaning-other-lang-id.html).
* [#10708](http://dev.ckeditor.com/ticket/10708): New [smileys](http://ckeditor.com/addon/smiley).

## CKEditor 4.2.3

Fixed Issues:

* [#10994](http://dev.ckeditor.com/ticket/10994): Fixed: Loading external jQuery library when opening the [jQuery Adapter](http://docs.ckeditor.com/#!/guide/dev_jquery) sample directly from file.
* [#10975](http://dev.ckeditor.com/ticket/10975): [IE] Fixed: Error thrown while opening the color palette.
* [#9929](http://dev.ckeditor.com/ticket/9929): [Blink/WebKit] Fixed: A non-breaking space is created once a character is deleted and a regular space is typed.
* [#10963](http://dev.ckeditor.com/ticket/10963): Fixed: JAWS issue with the keyboard shortcut for [Magic Line](http://ckeditor.com/addon/magicline).
* [#11096](http://dev.ckeditor.com/ticket/11096): Fixed: TypeError: Object has no method 'is'.

## CKEditor 4.2.2

Fixed Issues:

* [#9314](http://dev.ckeditor.com/ticket/9314): Fixed: Incorrect error message on closing a dialog window without saving changs.
* [#10308](http://dev.ckeditor.com/ticket/10308): [IE10] Fixed: Unspecified error when deleting a row.
* [#10945](http://dev.ckeditor.com/ticket/10945): [Chrome] Fixed: Clicking with a mouse inside the editor does not show the caret.
* [#10912](http://dev.ckeditor.com/ticket/10912): Prevent default action when content of a non-editable link is clicked.
* [#10913](http://dev.ckeditor.com/ticket/10913): Fixed [`CKEDITOR.plugins.addExternal()`](http://docs.ckeditor.com/#!/api/CKEDITOR.resourceManager-method-addExternal) not handling paths including file name specified.
* [#10666](http://dev.ckeditor.com/ticket/10666): Fixed [`CKEDITOR.tools.isArray()`](http://docs.ckeditor.com/#!/api/CKEDITOR.tools-method-isArray) not working cross frame.
* [#10910](http://dev.ckeditor.com/ticket/10910): [IE9] Fixed JavaScript error thrown in Compatibility Mode when clicking and/or typing in the editing area.
* [#10868](http://dev.ckeditor.com/ticket/10868): [IE8] Prevent the browser from crashing when applying the Inline Quotation style.
* [#10915](http://dev.ckeditor.com/ticket/10915): Fixed: Invalid CSS filter in the Kama skin.
* [#10914](http://dev.ckeditor.com/ticket/10914): Plugins [Indent List](http://ckeditor.com/addon/indentlist) and [Indent Block](http://ckeditor.com/addon/indentblock) are now included in the build configuration.
* [#10812](http://dev.ckeditor.com/ticket/10812): Fixed [`range.createBookmark2()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dom.range-method-createBookmark2) incorrectly normalizing offsets. This bug was causing many issues: [#10850](http://dev.ckeditor.com/ticket/10850), [#10842](http://dev.ckeditor.com/ticket/10842).
* [#10951](http://dev.ckeditor.com/ticket/10951): Reviewed and optimized focus handling on panels (combo, menu buttons, color buttons, and context menu) to enhance accessibility. Fixed [#10705](http://dev.ckeditor.com/ticket/10705), [#10706](http://dev.ckeditor.com/ticket/10706) and [#10707](http://dev.ckeditor.com/ticket/10707).
* [#10704](http://dev.ckeditor.com/ticket/10704): Fixed a JAWS issue with the Select Color dialog window title not being announced.
* [#10753](http://dev.ckeditor.com/ticket/10753): The floating toolbar in inline instances now has a dedicated accessibility label.

## CKEditor 4.2.1

Fixed Issues:

* [#10301](http://dev.ckeditor.com/ticket/10301): [IE9-10] Undo fails after 3+ consecutive paste actions with a JavaScript error.
* [#10689](http://dev.ckeditor.com/ticket/10689): Save toolbar button saves only the first editor instance.
* [#10368](http://dev.ckeditor.com/ticket/10368): Move language reading direction definition (`dir`) from main language file to core.
* [#9330](http://dev.ckeditor.com/ticket/9330): Fixed pasting anchors from MS Word.
* [#8103](http://dev.ckeditor.com/ticket/8103): Fixed pasting nested lists from MS Word.
* [#9958](http://dev.ckeditor.com/ticket/9958): [IE9] Pressing the "OK" button will trigger the `onbeforeunload` event in the popup dialog.
* [#10662](http://dev.ckeditor.com/ticket/10662): Fixed styles from the Styles drop-down list not registering to the ACF in case when the [Shared Spaces plugin](http://ckeditor.com/addon/sharedspace) is used.
* [#9654](http://dev.ckeditor.com/ticket/9654): Problems with Internet Explorer 10 Quirks Mode.
* [#9816](http://dev.ckeditor.com/ticket/9816): Floating toolbar does not reposition vertically in several cases.
* [#10646](http://dev.ckeditor.com/ticket/10646): Removing a selected sublist or nested table with *Backspace/Delete* removes the parent element.
* [#10623](http://dev.ckeditor.com/ticket/10623): [WebKit] Page is scrolled when opening a drop-down list.
* [#10004](http://dev.ckeditor.com/ticket/10004): [ChromeVox] Button names are not announced.
* [#10731](http://dev.ckeditor.com/ticket/10731): [WebSpellChecker](http://ckeditor.com/addon/wsc) plugin breaks cloning of editor configuration.
* It is now possible to set per instance [WebSpellChecker](http://ckeditor.com/addon/wsc) plugin configuration instead of setting the configuration globally.

## CKEditor 4.2

**Important Notes:**

* Dropped compatibility support for Internet Explorer 7 and Firefox 3.6.

* Both the Basic and the Standard distribution packages will not contain the new [Indent Block](http://ckeditor.com/addon/indentblock) plugin. Because of this the [Advanced Content Filter](http://docs.ckeditor.com/#!/guide/dev_advanced_content_filter) might remove block indentations from existing contents. If you want to prevent this, either [add an appropriate ACF rule to your filter](http://docs.ckeditor.com/#!/guide/dev_allowed_content_rules) or create a custom build based on the Basic/Standard package and add the Indent Block plugin in [CKBuilder](http://ckeditor.com/builder).

New Features:

* [#10027](http://dev.ckeditor.com/ticket/10027): Separated list and block indentation into two plugins: [Indent List](http://ckeditor.com/addon/indentlist) and [Indent Block](http://ckeditor.com/addon/indentblock).
* [#8244](http://dev.ckeditor.com/ticket/8244): Use *(Shift+)Tab* to indent and outdent lists.
* [#10281](http://dev.ckeditor.com/ticket/10281): The [jQuery Adapter](http://docs.ckeditor.com/#!/guide/dev_jquery) is now available. Several jQuery-related issues fixed: [#8261](http://dev.ckeditor.com/ticket/8261), [#9077](http://dev.ckeditor.com/ticket/9077), [#8710](http://dev.ckeditor.com/ticket/8710), [#8530](http://dev.ckeditor.com/ticket/8530), [#9019](http://dev.ckeditor.com/ticket/9019), [#6181](http://dev.ckeditor.com/ticket/6181), [#7876](http://dev.ckeditor.com/ticket/7876), [#6906](http://dev.ckeditor.com/ticket/6906).
* [#10042](http://dev.ckeditor.com/ticket/10042): Introduced [`config.title`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-title) setting to change the human-readable title of the editor.
* [#9794](http://dev.ckeditor.com/ticket/9794): Added [`editor.onChange`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-change) event.
* [#9923](http://dev.ckeditor.com/ticket/9923): HiDPI support in the editor UI. HiDPI icons for [Moono skin](http://ckeditor.com/addon/moono) added.
* [#8031](http://dev.ckeditor.com/ticket/8031): Handle `required` attributes on `<textarea>` elements &mdash; introduced [`editor.required`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-required) event.
* [#10280](http://dev.ckeditor.com/ticket/10280): Ability to replace `<textarea>` elements with the inline editor.

Fixed Issues:

* [#10599](http://dev.ckeditor.com/ticket/10599): [Indent](http://ckeditor.com/addon/indent) plugin is no longer required by the [List](http://ckeditor.com/addon/list) plugin.
* [#10370](http://dev.ckeditor.com/ticket/10370): Inconsistency in data events between framed and inline editors.
* [#10438](http://dev.ckeditor.com/ticket/10438): [FF, IE] No selection is done on an editable element on executing [`editor.setData()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setData).

## CKEditor 4.1.3

New Features:

* Added new translation: Indonesian.

Fixed Issues:

* [#10644](http://dev.ckeditor.com/ticket/10644): Fixed a critical bug when pasting plain text in Blink-based browsers.
* [#5189](http://dev.ckeditor.com/ticket/5189): [Find/Replace](http://ckeditor.com/addon/find) dialog window: rename "Cancel" button to "Close".
* [#10562](http://dev.ckeditor.com/ticket/10562): [Housekeeping] Unified CSS gradient filter formats in the [Moono](http://ckeditor.com/addon/moono) skin.
* [#10537](http://dev.ckeditor.com/ticket/10537): Advanced Content Filter should register a default rule for [`config.shiftEnterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-shiftEnterMode).
* [#10610](http://dev.ckeditor.com/ticket/10610): [`CKEDITOR.dialog.addIframe()`](http://docs.ckeditor.com/#!/api/CKEDITOR.dialog-static-method-addIframe) incorrectly sets the iframe size in dialog windows.

## CKEditor 4.1.2

New Features:

* Added new translation: Sinhala.

Fixed Issues:

* [#10339](http://dev.ckeditor.com/ticket/10339): Fixed: Error thrown when inserted data was totally stripped out after filtering and processing.
* [#10298](http://dev.ckeditor.com/ticket/10298): Fixed: Data processor breaks attributes containing protected parts.
* [#10367](http://dev.ckeditor.com/ticket/10367): Fixed: [`editable.insertText()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editable-method-insertText) loses characters when `RegExp` replace controls are being inserted.
* [#10165](http://dev.ckeditor.com/ticket/10165): [IE] Access denied error when `document.domain` has been altered.
* [#9761](http://dev.ckeditor.com/ticket/9761): Update the *Backspace* key state in [`keystrokeHandler.blockedKeystrokes`](http://docs.ckeditor.com/#!/api/CKEDITOR.keystrokeHandler-property-blockedKeystrokes) when calling [`editor.setReadOnly()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setReadOnly).
* [#6504](http://dev.ckeditor.com/ticket/6504): Fixed: Race condition while loading several [`config.customConfig`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-customConfig) files.
* [#10146](http://dev.ckeditor.com/ticket/10146): [Firefox] Empty lines are being removed while [`config.enterMode`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-enterMode) is [`CKEDITOR.ENTER_BR`](http://docs.ckeditor.com/#!/api/CKEDITOR-property-ENTER_BR).
* [#10360](http://dev.ckeditor.com/ticket/10360): Fixed: ARIA `role="application"` should not be used for dialog windows.
* [#10361](http://dev.ckeditor.com/ticket/10361): Fixed: ARIA `role="application"` should not be used for floating panels.
* [#10510](http://dev.ckeditor.com/ticket/10510): Introduced unique voice labels to differentiate between different editor instances.
* [#9945](http://dev.ckeditor.com/ticket/9945): [iOS] Scrolling not possible on iPad.
* [#10389](http://dev.ckeditor.com/ticket/10389): Fixed: Invalid HTML in the "Text and Table" template.
* [WebSpellChecker](http://ckeditor.com/addon/wsc) plugin user interface was changed to match CKEditor 4 style.

## CKEditor 4.1.1

New Features:

* Added new translation: Albanian.

Fixed Issues:

* [#10172](http://dev.ckeditor.com/ticket/10172): Pressing *Delete* or *Backspace* in an empty table cell moves the cursor to the next/previous cell.
* [#10219](http://dev.ckeditor.com/ticket/10219): Error thrown when destroying an editor instance in parallel with a `mouseup` event.
* [#10265](http://dev.ckeditor.com/ticket/10265): Wrong loop type in the [File Browser](http://ckeditor.com/addon/filebrowser) plugin.
* [#10249](http://dev.ckeditor.com/ticket/10249): Wrong undo/redo states at start.
* [#10268](http://dev.ckeditor.com/ticket/10268): [Show Blocks](http://ckeditor.com/addon/showblocks) does not recover after switching to Source view.
* [#9995](http://dev.ckeditor.com/ticket/9995): HTML code in the `<textarea>` should not be modified by the [`htmlDataProcessor`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlDataProcessor).
* [#10320](http://dev.ckeditor.com/ticket/10320): [Justify](http://ckeditor.com/addon/justify) plugin should add elements to Advanced Content Filter based on current [Enter mode](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-enterMode).
* [#10260](http://dev.ckeditor.com/ticket/10260): Fixed: Advanced Content Filter blocks [`tabSpaces`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-tabSpaces). Unified `data-cke-*` attributes filtering.
* [#10315](http://dev.ckeditor.com/ticket/10315): [WebKit] [Undo manager](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.undo.UndoManager) should not record snapshots after a filling character was added/removed.
* [#10291](http://dev.ckeditor.com/ticket/10291): [WebKit] Space after a filling character should be secured.
* [#10330](http://dev.ckeditor.com/ticket/10330): [WebKit] The filling character is not removed on `keydown` in specific cases.
* [#10285](http://dev.ckeditor.com/ticket/10285): Fixed: Styled text pasted from MS Word causes an infinite loop.
* [#10131](http://dev.ckeditor.com/ticket/10131): Fixed: [`undoManager.update()`](http://docs.ckeditor.com/#!/api/CKEDITOR.plugins.undo.UndoManager-method-update) does not refresh the command state.
* [#10337](http://dev.ckeditor.com/ticket/10337): Fixed: Unable to remove `<s>` using [Remove Format](http://ckeditor.com/addon/removeformat).

## CKEditor 4.1

Fixed Issues:

* [#10192](http://dev.ckeditor.com/ticket/10192): Closing lists with the *Enter* key does not work with [Advanced Content Filter](http://docs.ckeditor.com/#!/guide/dev_advanced_content_filter) in several cases.
* [#10191](http://dev.ckeditor.com/ticket/10191): Fixed allowed content rules unification, so the [`filter.allowedContent`](http://docs.ckeditor.com/#!/api/CKEDITOR.filter-property-allowedContent) property always contains rules in the same format.
* [#10224](http://dev.ckeditor.com/ticket/10224): Advanced Content Filter does not remove non-empty `<a>` elements anymore.
* Minor issues in plugin integration with Advanced Content Filter:
  * [#10166](http://dev.ckeditor.com/ticket/10166): Added transformation from the `align` attribute to `float` style to preserve backward compatibility after the introduction of Advanced Content Filter.
  * [#10195](http://dev.ckeditor.com/ticket/10195): [Image](http://ckeditor.com/addon/image) plugin no longer registers rules for links to Advanced Content Filter.
  * [#10213](http://dev.ckeditor.com/ticket/10213): [Justify](http://ckeditor.com/addon/justify) plugin is now correctly registering rules to Advanced Content Filter when [`config.justifyClasses`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-justifyClasses) is defined.

## CKEditor 4.1 RC

New Features:

* [#9829](http://dev.ckeditor.com/ticket/9829): Advanced Content Filter - data and features activation based on editor configuration.

  Brand new data filtering system that works in 2 modes:

  * Based on loaded features (toolbar items, plugins) - the data will be filtered according to what the editor in its
  current configuration can handle.
  * Based on [`config.allowedContent`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) rules - the data
  will be filtered and the editor features (toolbar items, commands, keystrokes) will be enabled if they are allowed.

  See the `datafiltering.html` sample, [guides](http://docs.ckeditor.com/#!/guide/dev_advanced_content_filter) and [`CKEDITOR.filter` API documentation](http://docs.ckeditor.com/#!/api/CKEDITOR.filter).
* [#9387](http://dev.ckeditor.com/ticket/9387): Reintroduced [Shared Spaces](http://ckeditor.com/addon/sharedspace) - the ability to display toolbar and bottom editor space in selected locations and to share them by different editor instances.
* [#9907](http://dev.ckeditor.com/ticket/9907): Added the [`contentPreview`](http://docs.ckeditor.com/#!/api/CKEDITOR-event-contentPreview) event for preview data manipulation.
* [#9713](http://dev.ckeditor.com/ticket/9713): Introduced the [Source Dialog](http://ckeditor.com/addon/sourcedialog) plugin that brings raw HTML editing for inline editor instances.
* Included in [#9829](http://dev.ckeditor.com/ticket/9829): Introduced new events, [`toHtml`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-toHtml) and [`toDataFormat`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-toDataFormat), allowing for better integration with data processing.
* [#9981](http://dev.ckeditor.com/ticket/9981): Added ability to filter [`htmlParser.fragment`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.fragment), [`htmlParser.element`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.element) etc. by many [`htmlParser.filter`](http://docs.ckeditor.com/#!/api/CKEDITOR.htmlParser.filter)s before writing structure to an HTML string.
* Included in [#10103](http://dev.ckeditor.com/ticket/10103):
  * Introduced the [`editor.status`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-status) property to make it easier to check the current status of the editor.
  * Default [`command`](http://docs.ckeditor.com/#!/api/CKEDITOR.command) state is now [`CKEDITOR.TRISTATE_DISABLE`](http://docs.ckeditor.com/#!/api/CKEDITOR-property-TRISTATE_DISABLED). It will be activated on [`editor.instanceReady`](http://docs.ckeditor.com/#!/api/CKEDITOR-event-instanceReady) or immediately after being added if the editor is already initialized.
* [#9796](http://dev.ckeditor.com/ticket/9796): Introduced `<s>` as a default tag for strikethrough, which replaces obsolete `<strike>` in HTML5.

## CKEditor 4.0.3

Fixed Issues:

* [#10196](http://dev.ckeditor.com/ticket/10196): Fixed context menus not opening with keyboard shortcuts when [Autogrow](http://ckeditor.com/addon/autogrow) is enabled.
* [#10212](http://dev.ckeditor.com/ticket/10212): [IE7-10] Undo command throws errors after multiple switches between Source and WYSIWYG view.
* [#10219](http://dev.ckeditor.com/ticket/10219): [Inline editor] Error thrown after calling [`editor.destroy()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-destroy).

## CKEditor 4.0.2

Fixed Issues:

* [#9779](http://dev.ckeditor.com/ticket/9779): Fixed overriding [`CKEDITOR.getUrl()`](http://docs.ckeditor.com/#!/api/CKEDITOR-method-getUrl) with `CKEDITOR_GETURL`.
* [#9772](http://dev.ckeditor.com/ticket/9772): Custom buttons in the dialog window footer have different look and size ([Moono](http://ckeditor.com/addon/moono), [Kama](http://ckeditor.com/addon/kama) skins).
* [#9029](http://dev.ckeditor.com/ticket/9029): Custom styles added with the [`stylesSet.add()`](http://docs.ckeditor.com/#!/api/CKEDITOR.stylesSet-method-add) are displayed in the wrong order.
* [#9887](http://dev.ckeditor.com/ticket/9887): Disable [Magic Line](http://ckeditor.com/addon/magicline) when [`editor.readOnly`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-property-readOnly) is set.
* [#9882](http://dev.ckeditor.com/ticket/9882): Fixed empty document title on [`editor.getData()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-getData) if set via the Document Properties dialog window.
* [#9773](http://dev.ckeditor.com/ticket/9773): Fixed rendering problems with selection fields in the Kama skin.
* [#9851](http://dev.ckeditor.com/ticket/9851): The [`selectionChange`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-selectionChange) event is not fired when mouse selection ended outside editable.
* [#9903](http://dev.ckeditor.com/ticket/9903): [Inline editor] Bad positioning of floating space with page horizontal scroll.
* [#9872](http://dev.ckeditor.com/ticket/9872): [`editor.checkDirty()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-checkDirty) returns `true` when called onload. Removed the obsolete `editor.mayBeDirty` flag.
* [#9893](http://dev.ckeditor.com/ticket/9893): [IE] Fixed broken toolbar when editing mixed direction content in Quirks mode.
* [#9845](http://dev.ckeditor.com/ticket/9845): Fixed TAB navigation in the [Link](http://ckeditor.com/addon/link) dialog window when the Anchor option is used and no anchors are available.
* [#9883](http://dev.ckeditor.com/ticket/9883): Maximizing was making the entire page editable with [divarea](http://ckeditor.com/addon/divarea)-based editors.
* [#9940](http://dev.ckeditor.com/ticket/9940): [Firefox] Navigating back to a page with the editor was making the entire page editable.
* [#9966](http://dev.ckeditor.com/ticket/9966): Fixed: Unable to type square brackets with French keyboard layout. Changed [Magic Line](http://ckeditor.com/addon/magicline) keystrokes.
* [#9507](http://dev.ckeditor.com/ticket/9507): [Firefox] Selection is moved before editable position when the editor is focused for the first time.
* [#9947](http://dev.ckeditor.com/ticket/9947): [WebKit] Editor overflows parent container in some edge cases.
* [#10105](http://dev.ckeditor.com/ticket/10105): Fixed: Broken [sourcearea](http://ckeditor.com/addon/sourcearea) view when an RTL language is set.
* [#10123](http://dev.ckeditor.com/ticket/10123): [WebKit] Fixed: Several dialog windows have broken layout since the latest WebKit release.
* [#10152](http://dev.ckeditor.com/ticket/10152): Fixed: Invalid ARIA property used on menu items.

## CKEditor 4.0.1.1

Fixed Issues:

* Security update: Added protection against XSS attack and possible path disclosure in the PHP sample.

## CKEditor 4.0.1

Fixed Issues:

* [#9655](http://dev.ckeditor.com/ticket/9655): Support for IE Quirks Mode in the new [Moono skin](http://ckeditor.com/addon/moono).
* Accessibility issues (mainly in inline editor): [#9364](http://dev.ckeditor.com/ticket/9364), [#9368](http://dev.ckeditor.com/ticket/9368), [#9369](http://dev.ckeditor.com/ticket/9369), [#9370](http://dev.ckeditor.com/ticket/9370), [#9541](http://dev.ckeditor.com/ticket/9541), [#9543](http://dev.ckeditor.com/ticket/9543), [#9841](http://dev.ckeditor.com/ticket/9841), [#9844](http://dev.ckeditor.com/ticket/9844).
* [Magic Line](http://ckeditor.com/addon/magicline) plugin:
    * [#9481](http://dev.ckeditor.com/ticket/9481): Added accessibility support for Magic Line.
    * [#9509](http://dev.ckeditor.com/ticket/9509): Added Magic Line support for forms.
    * [#9573](http://dev.ckeditor.com/ticket/9573): Magic Line does not disappear on `mouseout` in a specific case.
* [#9754](http://dev.ckeditor.com/ticket/9754): [WebKit] Cutting & pasting simple unformatted text generates an inline wrapper in WebKit browsers.
* [#9456](http://dev.ckeditor.com/ticket/9456): [Chrome] Properly paste bullet list style from MS Word.
* [#9699](http://dev.ckeditor.com/ticket/9699), [#9758](http://dev.ckeditor.com/ticket/9758): Improved selection locking when selecting by dragging.
* Context menu:
    * [#9712](http://dev.ckeditor.com/ticket/9712): Opening the context menu destroys editor focus.
    * [#9366](http://dev.ckeditor.com/ticket/9366): Context menu should be displayed over the floating toolbar.
    * [#9706](http://dev.ckeditor.com/ticket/9706): Context menu generates a JavaScript error in inline mode when the editor is attached to a header element.
* [#9800](http://dev.ckeditor.com/ticket/9800): Hide float panel when resizing the window.
* [#9721](http://dev.ckeditor.com/ticket/9721): Padding in content of div-based editor puts the editing area under the bottom UI space.
* [#9528](http://dev.ckeditor.com/ticket/9528): Host page `box-sizing` style should not influence the editor UI elements.
* [#9503](http://dev.ckeditor.com/ticket/9503): [Form Elements](http://ckeditor.com/addon/forms) plugin adds context menu listeners only on supported input types. Added support for `tel`, `email`, `search` and `url` input types.
* [#9769](http://dev.ckeditor.com/ticket/9769): Improved floating toolbar positioning in a narrow window.
* [#9875](http://dev.ckeditor.com/ticket/9875): Table dialog window does not populate width correctly.
* [#8675](http://dev.ckeditor.com/ticket/8675): Deleting cells in a nested table removes the outer table cell.
* [#9815](http://dev.ckeditor.com/ticket/9815): Cannot edit dialog window fields in an editor initialized in the jQuery UI modal dialog.
* [#8888](http://dev.ckeditor.com/ticket/8888): CKEditor dialog windows do not show completely in a small window.
* [#9360](http://dev.ckeditor.com/ticket/9360): [Inline editor] Blocks shown for a `<div>` element stay permanently even after the user exits editing the `<div>`.
* [#9531](http://dev.ckeditor.com/ticket/9531): [Firefox & Inline editor] Toolbar is lost when closing the Format drop-down list by clicking its button.
* [#9553](http://dev.ckeditor.com/ticket/9553): Table width incorrectly set when the `border-width` style is specified.
* [#9594](http://dev.ckeditor.com/ticket/9594): Cannot tab past CKEditor when it is in read-only mode.
* [#9658](http://dev.ckeditor.com/ticket/9658): [IE9] Justify not working on selected images.
* [#9686](http://dev.ckeditor.com/ticket/9686): Added missing contents styles for `<pre>` elements.
* [#9709](http://dev.ckeditor.com/ticket/9709): [Paste from Word](http://ckeditor.com/addon/pastefromword) should not depend on configuration from other styles.
* [#9726](http://dev.ckeditor.com/ticket/9726): Removed [Color Dialog](http://ckeditor.com/addon/colordialog) plugin dependency from [Table Tools](http://ckeditor.com/addon/tabletools).
* [#9765](http://dev.ckeditor.com/ticket/9765): Toolbar Collapse command documented incorrectly in the [Accessibility Instructions](http://ckeditor.com/addon/a11yhelp) dialog window.
* [#9771](http://dev.ckeditor.com/ticket/9771): [WebKit & Opera] Fixed scrolling issues when pasting.
* [#9787](http://dev.ckeditor.com/ticket/9787): [IE9] `onChange` is not fired for checkboxes in dialogs.
* [#9842](http://dev.ckeditor.com/ticket/9842): [Firefox 17] When opening a toolbar menu for the first time and pressing the *Down Arrow* key, focus goes to the next toolbar button instead of the menu options.
* [#9847](http://dev.ckeditor.com/ticket/9847): [Elements Path](http://ckeditor.com/addon/elementspath) should not be initialized in the inline editor.
* [#9853](http://dev.ckeditor.com/ticket/9853): [`editor.addRemoveFormatFilter()`](http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-addRemoveFormatFilter) is exposed before it really works.
* [#8893](http://dev.ckeditor.com/ticket/8893): Value of the [`pasteFromWordCleanupFile`](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-pasteFromWordCleanupFile) configuration option is now taken from the instance configuration.
* [#9693](http://dev.ckeditor.com/ticket/9693): Removed "Live Preview" checkbox from UI color picker.


## CKEditor 4.0

The first stable release of the new CKEditor 4 code line.

The CKEditor JavaScript API has been kept compatible with CKEditor 4, whenever
possible. The list of relevant changes can be found in the [API Changes page of
the CKEditor 4 documentation][1].

[1]: http://docs.ckeditor.com/#!/guide/dev_api_changes "API Changes"
/********************** ls_channelbucket: LinnStrument ChannelBucket class ************************
Coming from the operating System for the LinnStrument (c) music controller by Roger Linn Design (www.rogerlinndesign.com).

Written by Roger Linn and Geert Bevin (http://gbevin.com).

LinnStrument Operating System is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License,
viewable at <http://creativecommons.org/licenses/by-sa/3.0/>.

This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/
or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
***************************************************************************************************
Handles the handing out of MIDI channels from a bucket of allowed channel numbers.

The available channels are added to the bucket in the beginning.

When a note needs a new channel, it just takes it. The channel will move to the bottom of the
bucket and will be reused when all the other channels have been taken also. This makes it
possible for the same channel number to be in use by different note, depending on the number of
channels that were added to the bucket and the polyphony of the notes that are being played.

At the same time, the bucket keeps track of which channels are taken and which channels are
released and free from any touches. This is achieved by dividing the bucket in two sections, an
upper section with all the released channels and a bottom section with all the channels that are
already taken.

When a note is released, it should release its channel. If the channel is still in use by another
note since the polyphony was exceeded, the channel will move to the bottom of the taken section.
If no other notes are using the channel, the channel will be moved to the bottom of the released
section, somewhere in the middle of the whole bucket.

This whole approach ensures that channels are reused as late as possible, while attempting to
prevent handing out the same channel for multiple notes. Postponing the reuse of a channel as much
as possible is important for sounds that have long releases.
**************************************************************************************************/

#ifndef CHANNELBUCKET_H_
#define CHANNELBUCKET_H_

typedef unsigned char byte;

class ChannelBucket {
public:
  ChannelBucket() {
    clear();
  }

  ~ChannelBucket() {}

  void add(byte channel) {
    // we can't add a MIDI channel that exceeds 16
    if (channel > 16) return;

    // offset the channel for a 0-based array
    channel -= 1;

    // don't add a channel several times
    if (next_[channel] != -1) return;

    // this is the first channel to be added to the bucket
    if (-1 == top_) {
      top_ = channel;
      previous_[channel] = channel;
      next_[channel] = channel;
      taken_[channel] = 0;
      bottomReleased_ = channel;
    }
    // add the channel to right after the current bottom-most released channel
    // and make the new channel the bottom-most released one
    else {
      previous_[channel] = bottomReleased_;
      previous_[next_[bottomReleased_]] = channel;

      next_[channel] = next_[bottomReleased_];
      next_[bottomReleased_] = channel;

      taken_[channel] = 0;
      bottomReleased_ = channel;
    }
  }

  byte take() {
    // return an invalid channel if none have been added
    if (-1 == top_) return 0;

    // get the channel at the top of the bucket
    byte channel = top_;

    // sink the channel to the bottom of the entire bucket, also crossing
    // the release/taken marker. Essentially the channel goes to the bottom
    // of the taken section. Since the channel was already at the top of the
    // bucket, this is very simply done by adjusting the top marker to the
    // next channel available
    top_ = next_[channel];

    // indicate that the channel was taken once more
    taken_[channel]++;

    // if this channel was the last of the released section, indicate that
    // the released marker has become invalid
    if (channel == bottomReleased_) {
      bottomReleased_ = -1;
    }

    // adjust for 1-base channel numbers
    return channel+1;
  }

  byte take(byte channel) {
    // we can't take a MIDI channel that exceeds 16, nor can we work with an empty bucket
    // we expect this channel to also be already in the bucket
    if (channel > 16 || -1 == top_ || -1 == next_[channel-1]) return 0;

    // offset the channel for a 0-based array
    channel -= 1;

    // indicate that the channel was taken one more time
    taken_[channel]++;

    // adjust the released section marker to either become invalid is this
    // valid the last channel that was released, or to shift one up in the
    // released section
    if (bottomReleased_ == channel) {
      if (top_ == channel) {
        bottomReleased_ = -1;
      }
      else {
        bottomReleased_ = previous_[channel];
      }
    }

    // if this channel was at the top, readjust the top marker to point to the next channel
    if (top_ == channel) {
      top_ = next_[channel];
    }

    // ensure that the channel goes to the bottom of the taken section
    extremize(channel);

    // adjust for 1-base channel numbers
    return channel+1;
  }

  void release(byte channel) {
    // we can't release a MIDI channel that exceeds 16, nor can we work with an empty bucket
    // we expect this channel to also be already in the bucket
    if (channel > 16 || -1 == top_ || -1 == next_[channel-1]) return;

    // offset the channel for a 0-based array
    channel -= 1;

    // indicate that the channel was taken one less time
    taken_[channel]--;

    // if the channel is still taken, ensure it goes to the bottom of the taken section
    if (taken_[channel] > 0) {
      extremize(channel);
      top_ = next_[channel];
    }
    // if this release was the one using the channel, ensure that the channel goes at the bottom of the released section
    else {
      // if the released section doesn't exist anymore (all channels were taken),
      // put the channel at the extremes of the bucket and mark it as being the new
      // top channel
      if (bottomReleased_ == -1) {
        extremize(channel);
        top_ = channel;
      }
      // put the channel at the bottom of the released section
      else {
        // however, if the channel happens to be at the top of the
        // taken section (right after the released section), we don't need to do anything
        // besides readjusting the marker of the released section
        if (next_[bottomReleased_] != channel) {

          // determine the edges of both the released and the taken sections
          int releasedEdge = bottomReleased_;
          int takenEdge = next_[bottomReleased_];

          // extract the channel from the bucket so that nothing is pointing
          // towards it anymore
          extract(channel);

          // re-insert the channel between the current released and taken sections
          previous_[channel] = releasedEdge;
          next_[releasedEdge] = channel;

          previous_[takenEdge] = channel;
          next_[channel] = takenEdge;
        }
      }

      // this channel is the last released one now
      bottomReleased_ = channel;
    }
  }

  // remove all channels from the bucket
  void clear() {
    top_ = -1;
    for (int ch = 0; ch < 16; ++ch) {
      previous_[ch] = -1;
      next_[ch] = -1;
      taken_[ch] = 0;
    }
  }

private:

  void extract(byte channel) {
    if (next_[channel] != -1) {
      next_[previous_[channel]] = next_[channel];
      previous_[next_[channel]] = previous_[channel];

      previous_[channel] = -1;
      next_[channel] = -1;
    }
  }

  void extremize(byte channel) {
    int bottom = previous_[top_];
    if (bottom == channel) {
      bottom = previous_[channel];
    }
    int top = top_;
    if (top == channel) {
      top = next_[channel];
    }

    extract(channel);

    previous_[channel] = bottom;
    next_[bottom] = channel;

    previous_[top] = channel;
    next_[channel] = top;
  }

  void debugBucket() {
    pic::logmsg() << "top=" << top_ << " bottomReleased=" << bottomReleased_;
    for (int ch = 0; ch < 16; ++ch) {
      pic::logmsg() << "channel=" << ch
        << " previous=" << previous_[ch]
        << " next=" << next_[ch]
        << " taken=" << (unsigned long)taken_[ch];
    }
  }

  int top_;            // the channel number of the top one in the bucket
  int previous_[16];   // the channel number of the previous channel in the bucket for each individual channel
  int next_[16];       // the channel number of the next channel in the bucket for each individual channel
  byte taken_[16];     // counts how many times each channel is still taken
  int bottomReleased_; // marks the bottom of the released section
};

#endif
{
  "images" : [
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-Small@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "icon_40x40@2x-1.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "icon_60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "icon_60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-Small.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-Small@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "icon_40x40.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "icon_40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "icon_76x76.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "icon_76x76@2x.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

//  base64.hpp 
//  Autor Konstantin Pilipchuk
//  mailto:lostd@ukr.net
//
//

#if !defined(__BASE64_H_INCLUDED__)
#define __BASE64_H_INCLUDED__ 1

#include <iterator>
#include <ios>

static
int _base64Chars[]= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
				     'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
			         '0','1','2','3','4','5','6','7','8','9',
			         '+','/' };


#define _0000_0011 0x03
#define _1111_1100 0xFC
#define _1111_0000 0xF0
#define _0011_0000 0x30
#define _0011_1100 0x3C
#define _0000_1111 0x0F
#define _1100_0000 0xC0
#define _0011_1111 0x3F

#define _EQUAL_CHAR   (-1)
#define _UNKNOWN_CHAR (-2)

#define _IOS_FAILBIT   std::ios_base::failbit
#define _IOS_EOFBIT    std::ios_base::eofbit
#define _IOS_BADBIT    std::ios_base::badbit
#define _IOS_GOODBIT   std::ios_base::goodbit

// TEMPLATE CLASS base64_put
template<class _E = char, class _Tr = std::char_traits<_E> >
class base64
{
public:

	typedef unsigned char byte_t;
	typedef _E            char_type;
	typedef _Tr           traits_type; 

	// base64 requires max line length <= 72 characters
	// you can fill end of line
	// it may be crlf, crlfsp, noline or other class like it


	struct crlf
	{
		template<class _OI>
			_OI operator()(_OI _To) const{
			*_To = _Tr::to_char_type('\r'); ++_To;
			*_To = _Tr::to_char_type('\n'); ++_To;

			return (_To);
		}
	};


	struct crlfsp
	{
		template<class _OI>
			_OI operator()(_OI _To) const{
			*_To = _Tr::to_char_type('\r'); ++_To;
			*_To = _Tr::to_char_type('\n'); ++_To;
			*_To = _Tr::to_char_type(' '); ++_To;

			return (_To);
		}
	};

	struct noline
	{
		template<class _OI>
			_OI operator()(_OI _To) const{
			return (_To);
		}
	};

	struct three2four
	{
		void zero()
		{
			_data[0] = 0;
			_data[1] = 0;
			_data[2] = 0;
		}

		byte_t get_0()	const
		{
			return _data[0];
		}
		byte_t get_1()	const
		{
			return _data[1];
		}
		byte_t get_2()	const
		{
			return _data[2];
		}

		void set_0(byte_t _ch)
		{
			_data[0] = _ch;
		}

		void set_1(byte_t _ch)
		{
			_data[1] = _ch;
		}

		void set_2(byte_t _ch)
		{
			_data[2] = _ch;
		}

		// 0000 0000  1111 1111  2222 2222
		// xxxx xxxx  xxxx xxxx  xxxx xxxx
		// 0000 0011  1111 2222  2233 3333

		int b64_0()	const	{return (_data[0] & _1111_1100) >> 2;}
		int b64_1()	const	{return ((_data[0] & _0000_0011) << 4) + ((_data[1] & _1111_0000)>>4);}
		int b64_2()	const	{return ((_data[1] & _0000_1111) << 2) + ((_data[2] & _1100_0000)>>6);}
		int b64_3()	const	{return (_data[2] & _0011_1111);}

		void b64_0(int _ch)	{_data[0] = ((_ch & _0011_1111) << 2) | (_0000_0011 & _data[0]);}

		void b64_1(int _ch)	{
			_data[0] = ((_ch & _0011_0000) >> 4) | (_1111_1100 & _data[0]);
			_data[1] = ((_ch & _0000_1111) << 4) | (_0000_1111 & _data[1]);	}

		void b64_2(int _ch)	{
			_data[1] = ((_ch & _0011_1100) >> 2) | (_1111_0000 & _data[1]);
			_data[2] = ((_ch & _0000_0011) << 6) | (_0011_1111 & _data[2]);	}

		void b64_3(int _ch){
			_data[2] = (_ch & _0011_1111) | (_1100_0000 & _data[2]);}

	private:
		byte_t _data[3];

	};




	template<class _II, class _OI, class _State, class _Endline>
		_II put(_II _First, _II _Last, _OI _To, _State& _St, _Endline _Endl)  const
	{
		three2four _3to4;
		int line_octets = 0;

		while(_First != _Last)
		{
			_3to4.zero();

			//   3 
			_3to4.set_0(*_First);
			_First++;

			if(_First == _Last)
			{
				*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_0()]); ++_To;
				*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_1()]); ++_To;
				*_To = _Tr::to_char_type('='); ++_To;
				*_To = _Tr::to_char_type('='); ++_To;
				goto __end;
			}

			_3to4.set_1(*_First);
			_First++;

			if(_First == _Last)
			{
				*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_0()]); ++_To;
				*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_1()]); ++_To;
				*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_2()]); ++_To;
				*_To = _Tr::to_char_type('='); ++_To;
				goto __end;
			}

			_3to4.set_2(*_First);
			_First++;

			*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_0()]); ++_To;
			*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_1()]); ++_To;
			*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_2()]); ++_To;
			*_To = _Tr::to_char_type(_base64Chars[_3to4.b64_3()]); ++_To;

			if(line_octets == 17) // base64      72 
			{
				//_To = _Endl(_To);
        *_To = '\n'; ++_To;
				line_octets = 0;
			}
			else
				++line_octets;
		}

		__end: ;

		return (_First);

	}


	template<class _II, class _OI, class _State>
		_II get(_II _First, _II _Last, _OI _To, _State& _St) const
	{
		three2four _3to4;
		int _Char;

		while(_First != _Last)
		{

			// Take octet
			_3to4.zero();

			// -- 0 --
			// Search next valid char... 
			while((_Char =  _getCharType(*_First)) < 0 && _Char == _UNKNOWN_CHAR)
			{
				if(++_First == _Last)
				{
					_St |= _IOS_FAILBIT|_IOS_EOFBIT; return _First; // unexpected EOF
				}
			}

			if(_Char == _EQUAL_CHAR){
				// Error! First character in octet can't be '='
				_St |= _IOS_FAILBIT; 
				return _First; 
			}
			else
				_3to4.b64_0(_Char);


			// -- 1 --
			// Search next valid char... 
			while(++_First != _Last)
				if((_Char = _getCharType(*_First)) != _UNKNOWN_CHAR)
					break;

			if(_First == _Last)	{
				_St |= _IOS_FAILBIT|_IOS_EOFBIT; // unexpected EOF 
				return _First;
			}

			if(_Char == _EQUAL_CHAR){
				// Error! Second character in octet can't be '='
				_St |= _IOS_FAILBIT; 
				return _First; 
			}
			else
				_3to4.b64_1(_Char);


			// -- 2 --
			// Search next valid char... 
			while(++_First != _Last)
				if((_Char = _getCharType(*_First)) != _UNKNOWN_CHAR)
					break;

			if(_First == _Last)	{
				// Error! Unexpected EOF. Must be '=' or base64 character
				_St |= _IOS_FAILBIT|_IOS_EOFBIT; 
				return _First; 
			}

			if(_Char == _EQUAL_CHAR){
				// OK!
				_3to4.b64_2(0); 
				_3to4.b64_3(0); 

				// chek for EOF
				if(++_First == _Last)
				{
					// Error! Unexpected EOF. Must be '='. Ignore it.
					//_St |= _IOS_BADBIT|_IOS_EOFBIT;
					_St |= _IOS_EOFBIT;
				}
				else 
					if(_getCharType(*_First) != _EQUAL_CHAR)
					{
						// Error! Must be '='. Ignore it.
						//_St |= _IOS_BADBIT;
					}
				else
					++_First; // Skip '='

				// write 1 byte to output
				*_To = (byte_t) _3to4.get_0();
				return _First;
			}
			else
				_3to4.b64_2(_Char);


			// -- 3 --
			// Search next valid char... 
			while(++_First != _Last)
				if((_Char = _getCharType(*_First)) != _UNKNOWN_CHAR)
					break;

			if(_First == _Last)	{
				// Unexpected EOF. It's error. But ignore it.
				//_St |= _IOS_FAILBIT|_IOS_EOFBIT; 
					_St |= _IOS_EOFBIT; 
				
				return _First; 
			}

			if(_Char == _EQUAL_CHAR)
			{
				// OK!
				_3to4.b64_3(0); 

				// write to output 2 bytes
				*_To = (byte_t) _3to4.get_0();
				*_To = (byte_t) _3to4.get_1();

				++_First; // set position to next character

				return _First;
			}
			else
				_3to4.b64_3(_Char);


			// write to output 3 bytes
			*_To = (byte_t) _3to4.get_0();
			*_To = (byte_t) _3to4.get_1();
			*_To = (byte_t) _3to4.get_2();

			++_First;
			

		} // while(_First != _Last)

		return (_First);
	}

protected:
	
	int _getCharType(int _Ch) const
	{
		if(_base64Chars[62] == _Ch)
			return 62;

		if(_base64Chars[63] == _Ch)
			return 63;

		if((_base64Chars[0] <= _Ch) && (_base64Chars[25] >= _Ch))
			return _Ch - _base64Chars[0];

		if((_base64Chars[26] <= _Ch) && (_base64Chars[51] >= _Ch))
			return _Ch - _base64Chars[26] + 26;

		if((_base64Chars[52] <= _Ch) && (_base64Chars[61] >= _Ch))
			return _Ch - _base64Chars[52] + 52;

		if(_Ch == _Tr::to_int_type('='))
			return _EQUAL_CHAR;

		return _UNKNOWN_CHAR;
	}


};


#endif
# Update versions in config.toml as well
githubRepo = "node-mongodb-native"
githubBranch = "2.1"
currentVersion = "2.1"
highlightTheme = "idea.css"
apiUrl = "/api"
/*
 * Copyright (c) 2003, 2007-8 Matteo Frigo
 * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/* This file was automatically generated --- DO NOT EDIT */
/* Generated on Mon Feb  9 19:56:59 EST 2009 */

#include "codelet-rdft.h"

#ifdef HAVE_FMA

/* Generated by: ../../../genfft/gen_hc2cdft_c -fma -reorder-insns -schedule-for-pipeline -simd -compact -variables 4 -pipeline-latency 8 -trivial-stores -variables 32 -no-generate-bytw -n 32 -dit -name hc2cfdftv_32 -include hc2cfv.h */

/*
 * This function contains 249 FP additions, 224 FP multiplications,
 * (or, 119 additions, 94 multiplications, 130 fused multiply/add),
 * 167 stack variables, 8 constants, and 64 memory accesses
 */
#include "hc2cfv.h"

static void hc2cfdftv_32(R *Rp, R *Ip, R *Rm, R *Im, const R *W, stride rs, INT mb, INT me, INT ms)
{
     DVK(KP831469612, +0.831469612302545237078788377617905756738560812);
     DVK(KP980785280, +0.980785280403230449126182236134239036973933731);
     DVK(KP668178637, +0.668178637919298919997757686523080761552472251);
     DVK(KP198912367, +0.198912367379658006911597622644676228597850501);
     DVK(KP500000000, +0.500000000000000000000000000000000000000000000);
     DVK(KP923879532, +0.923879532511286756128183189396788286822416626);
     DVK(KP414213562, +0.414213562373095048801688724209698078569671875);
     DVK(KP707106781, +0.707106781186547524400844362104849039284835938);
     INT m;
     for (m = mb, W = W + ((mb - 1) * ((TWVL / VL) * 62)); m < me; m = m + VL, Rp = Rp + (VL * ms), Ip = Ip + (VL * ms), Rm = Rm - (VL * ms), Im = Im - (VL * ms), W = W + (TWVL * 62), MAKE_VOLATILE_STRIDE(rs)) {
	  V T2m, T2b, T2c, T2d, T2v, T2r, T20, T2i, T2n, T2e, T2o, T2u, T2j, T2f, T2t;
	  V T2s, T2x, T2w, T2l, T2k, T2h, T2g;
	  {
	       V T41, T3B, T40, T3a, T2J, T27, T2y, Ts, T2C, T1X, T2B, T1Q, T3F, T3w, T4l;
	       V T49, T1b, T1s, T3c, TB, T1f, T3g, T44, T1l, T3k, T3o, T4b, T28, T14, T1d;
	       V T3b, TK;
	       {
		    V T1V, T1E, T3A, Th, T3v, T47, T1J, T3q, T8, T38, T25, T39, T3z, Tq, T1O;
		    V T3r, T3, T7, T3u, T24, T22, T3t, T1I, Tn, T1G, To, Tm, T1K, Tl, T1N;
		    V Tp, T1L, TU, T3f, T3m, T13, T3e, T3n, T1i, TH, TI, T1k, TG, TF, T1c;
		    V TJ;
		    {
			 V T1x, T1y, T1U, T1B, T1S, T1C, T1A, T23, T21, T1z, T1, T2, T1T, T5, T6;
			 V T1R, T4, T1w, Ta, Tb, T1H, Te, Tf, Td, Tc, T1F, T9, T1D, Tj, Tk;
			 V Ti, Tg, T1M;
			 T1 = LD(&(Rp[0]), ms, &(Rp[0]));
			 T2 = LD(&(Rm[0]), -ms, &(Rm[0]));
			 T1T = LDW(&(W[0]));
			 T5 = LD(&(Rp[WS(rs, 8)]), ms, &(Rp[0]));
			 T6 = LD(&(Rm[WS(rs, 8)]), -ms, &(Rm[0]));
			 T1R = LDW(&(W[TWVL * 32]));
			 T4 = LDW(&(W[TWVL * 30]));
			 T1x = LD(&(Rp[WS(rs, 12)]), ms, &(Rp[0]));
			 T1y = LD(&(Rm[WS(rs, 12)]), -ms, &(Rm[0]));
			 T3 = VFMACONJ(T2, T1);
			 T1U = VZMULIJ(T1T, VFNMSCONJ(T2, T1));
			 T1w = LDW(&(W[TWVL * 48]));
			 T1B = LD(&(Rp[WS(rs, 4)]), ms, &(Rp[0]));
			 T1S = VZMULIJ(T1R, VFNMSCONJ(T6, T5));
			 T7 = VZMULJ(T4, VFMACONJ(T6, T5));
			 T1C = LD(&(Rm[WS(rs, 4)]), -ms, &(Rm[0]));
			 T1A = LDW(&(W[TWVL * 16]));
			 T23 = LDW(&(W[TWVL * 46]));
			 T21 = LDW(&(W[TWVL * 14]));
			 T1z = VZMULIJ(T1w, VFNMSCONJ(T1y, T1x));
			 Ta = LD(&(Rp[WS(rs, 2)]), ms, &(Rp[0]));
			 T3u = VADD(T1U, T1S);
			 T1V = VSUB(T1S, T1U);
			 Tb = LD(&(Rm[WS(rs, 2)]), -ms, &(Rm[0]));
			 T9 = LDW(&(W[TWVL * 6]));
			 T1D = VZMULIJ(T1A, VFNMSCONJ(T1C, T1B));
			 T24 = VZMULJ(T23, VFMACONJ(T1y, T1x));
			 T22 = VZMULJ(T21, VFMACONJ(T1C, T1B));
			 T1H = LDW(&(W[TWVL * 8]));
			 Te = LD(&(Rp[WS(rs, 10)]), ms, &(Rp[0]));
			 Tf = LD(&(Rm[WS(rs, 10)]), -ms, &(Rm[0]));
			 Td = LDW(&(W[TWVL * 38]));
			 Tc = VZMULJ(T9, VFMACONJ(Tb, Ta));
			 T1E = VSUB(T1z, T1D);
			 T3t = VADD(T1D, T1z);
			 T1F = LDW(&(W[TWVL * 40]));
			 Tj = LD(&(Rp[WS(rs, 14)]), ms, &(Rp[0]));
			 T1I = VZMULIJ(T1H, VFNMSCONJ(Tb, Ta));
			 Tk = LD(&(Rm[WS(rs, 14)]), -ms, &(Rm[0]));
			 Ti = LDW(&(W[TWVL * 54]));
			 Tg = VZMULJ(Td, VFMACONJ(Tf, Te));
			 T1M = LDW(&(W[TWVL * 56]));
			 Tn = LD(&(Rp[WS(rs, 6)]), ms, &(Rp[0]));
			 T1G = VZMULIJ(T1F, VFNMSCONJ(Tf, Te));
			 To = LD(&(Rm[WS(rs, 6)]), -ms, &(Rm[0]));
			 Tm = LDW(&(W[TWVL * 22]));
			 T1K = LDW(&(W[TWVL * 24]));
			 Tl = VZMULJ(Ti, VFMACONJ(Tk, Tj));
			 T3A = VADD(Tc, Tg);
			 Th = VSUB(Tc, Tg);
			 T1N = VZMULIJ(T1M, VFNMSCONJ(Tk, Tj));
		    }
		    T3v = VSUB(T3t, T3u);
		    T47 = VADD(T3u, T3t);
		    T1J = VSUB(T1G, T1I);
		    T3q = VADD(T1I, T1G);
		    Tp = VZMULJ(Tm, VFMACONJ(To, Tn));
		    T1L = VZMULIJ(T1K, VFNMSCONJ(To, Tn));
		    T8 = VSUB(T3, T7);
		    T38 = VADD(T3, T7);
		    T25 = VSUB(T22, T24);
		    T39 = VADD(T22, T24);
		    T3z = VADD(Tl, Tp);
		    Tq = VSUB(Tl, Tp);
		    T1O = VSUB(T1L, T1N);
		    T3r = VADD(T1N, T1L);
		    {
			 V T10, T11, TZ, T1o, TY, T1r, TN, TO, TM, T19, TR, TS, TQ, T17, T26;
			 V Tr, T1W, T1P, T3s, T48, TW, TX, TP, T1a, TV, T1q, TT, T18, Ty, Tz;
			 V Tx, Tw, T1j, Tu, T12, T1p, Tv, Tt, T1h, TD, TA, TE, TC, T1e;
			 TN = LD(&(Rp[WS(rs, 3)]), ms, &(Rp[WS(rs, 1)]));
			 TO = LD(&(Rm[WS(rs, 3)]), -ms, &(Rm[WS(rs, 1)]));
			 T41 = VADD(T3A, T3z);
			 T3B = VSUB(T3z, T3A);
			 T26 = VSUB(Tq, Th);
			 Tr = VADD(Th, Tq);
			 T1W = VADD(T1J, T1O);
			 T1P = VSUB(T1J, T1O);
			 T3s = VSUB(T3q, T3r);
			 T48 = VADD(T3q, T3r);
			 T40 = VADD(T38, T39);
			 T3a = VSUB(T38, T39);
			 T2J = VFNMS(LDK(KP707106781), T26, T25);
			 T27 = VFMA(LDK(KP707106781), T26, T25);
			 T2y = VFMA(LDK(KP707106781), Tr, T8);
			 Ts = VFNMS(LDK(KP707106781), Tr, T8);
			 T2C = VFMA(LDK(KP707106781), T1W, T1V);
			 T1X = VFNMS(LDK(KP707106781), T1W, T1V);
			 T2B = VFMA(LDK(KP707106781), T1P, T1E);
			 T1Q = VFNMS(LDK(KP707106781), T1P, T1E);
			 T3F = VFMA(LDK(KP414213562), T3s, T3v);
			 T3w = VFNMS(LDK(KP414213562), T3v, T3s);
			 T4l = VSUB(T48, T47);
			 T49 = VADD(T47, T48);
			 TM = LDW(&(W[TWVL * 10]));
			 T19 = LDW(&(W[TWVL * 12]));
			 TR = LD(&(Rp[WS(rs, 11)]), ms, &(Rp[WS(rs, 1)]));
			 TS = LD(&(Rm[WS(rs, 11)]), -ms, &(Rm[WS(rs, 1)]));
			 TQ = LDW(&(W[TWVL * 42]));
			 T17 = LDW(&(W[TWVL * 44]));
			 TW = LD(&(Rp[WS(rs, 15)]), ms, &(Rp[WS(rs, 1)]));
			 TX = LD(&(Rm[WS(rs, 15)]), -ms, &(Rm[WS(rs, 1)]));
			 TP = VZMULJ(TM, VFMACONJ(TO, TN));
			 T1a = VZMULIJ(T19, VFNMSCONJ(TO, TN));
			 TV = LDW(&(W[TWVL * 58]));
			 T1q = LDW(&(W[TWVL * 60]));
			 TT = VZMULJ(TQ, VFMACONJ(TS, TR));
			 T18 = VZMULIJ(T17, VFNMSCONJ(TS, TR));
			 T10 = LD(&(Rp[WS(rs, 7)]), ms, &(Rp[WS(rs, 1)]));
			 T11 = LD(&(Rm[WS(rs, 7)]), -ms, &(Rm[WS(rs, 1)]));
			 TZ = LDW(&(W[TWVL * 26]));
			 T1o = LDW(&(W[TWVL * 28]));
			 TY = VZMULJ(TV, VFMACONJ(TX, TW));
			 T1r = VZMULIJ(T1q, VFNMSCONJ(TX, TW));
			 TU = VSUB(TP, TT);
			 T3f = VADD(TP, TT);
			 T1b = VSUB(T18, T1a);
			 T3m = VADD(T1a, T18);
			 Tu = LD(&(Rp[WS(rs, 5)]), ms, &(Rp[WS(rs, 1)]));
			 T12 = VZMULJ(TZ, VFMACONJ(T11, T10));
			 T1p = VZMULIJ(T1o, VFNMSCONJ(T11, T10));
			 Tv = LD(&(Rm[WS(rs, 5)]), -ms, &(Rm[WS(rs, 1)]));
			 Tt = LDW(&(W[TWVL * 18]));
			 T1h = LDW(&(W[TWVL * 20]));
			 Ty = LD(&(Rp[WS(rs, 13)]), ms, &(Rp[WS(rs, 1)]));
			 Tz = LD(&(Rm[WS(rs, 13)]), -ms, &(Rm[WS(rs, 1)]));
			 Tx = LDW(&(W[TWVL * 50]));
			 T13 = VSUB(TY, T12);
			 T3e = VADD(TY, T12);
			 T1s = VSUB(T1p, T1r);
			 T3n = VADD(T1r, T1p);
			 Tw = VZMULJ(Tt, VFMACONJ(Tv, Tu));
			 T1i = VZMULIJ(T1h, VFNMSCONJ(Tv, Tu));
			 T1j = LDW(&(W[TWVL * 52]));
			 TD = LD(&(Rp[WS(rs, 1)]), ms, &(Rp[WS(rs, 1)]));
			 TA = VZMULJ(Tx, VFMACONJ(Tz, Ty));
			 TE = LD(&(Rm[WS(rs, 1)]), -ms, &(Rm[WS(rs, 1)]));
			 TC = LDW(&(W[TWVL * 2]));
			 T1e = LDW(&(W[TWVL * 4]));
			 TH = LD(&(Rp[WS(rs, 9)]), ms, &(Rp[WS(rs, 1)]));
			 TI = LD(&(Rm[WS(rs, 9)]), -ms, &(Rm[WS(rs, 1)]));
			 T1k = VZMULIJ(T1j, VFNMSCONJ(Tz, Ty));
			 TG = LDW(&(W[TWVL * 34]));
			 T3c = VADD(Tw, TA);
			 TB = VSUB(Tw, TA);
			 TF = VZMULJ(TC, VFMACONJ(TE, TD));
			 T1f = VZMULIJ(T1e, VFNMSCONJ(TE, TD));
			 T1c = LDW(&(W[TWVL * 36]));
		    }
		    T3g = VSUB(T3e, T3f);
		    T44 = VADD(T3e, T3f);
		    T1l = VSUB(T1i, T1k);
		    T3k = VADD(T1i, T1k);
		    TJ = VZMULJ(TG, VFMACONJ(TI, TH));
		    T3o = VSUB(T3m, T3n);
		    T4b = VADD(T3n, T3m);
		    T28 = VFMA(LDK(KP414213562), TU, T13);
		    T14 = VFNMS(LDK(KP414213562), T13, TU);
		    T1d = VZMULIJ(T1c, VFNMSCONJ(TI, TH));
		    T3b = VADD(TF, TJ);
		    TK = VSUB(TF, TJ);
	       }
	       {
		    V T4k, T4p, T2z, T2a, T2K, T15, T2E, T1n, T2F, T1u, T4c, T3R, T3D, T3i, T3O;
		    V T46, T4g, T3G, T3P, T3S, T3x, T4q, T4n, T42, T1g, T3j, T3E, T3p, T4m, T3d;
		    V T43, T29, TL, T1m, T1t, T3l, T4a, T3C, T3h, T45, T3Q, T3W, T4d, T4h, T3H;
		    V T3L, T3y, T3K, T4r, T4v, T4o, T4u, T4j, T4i, T4e, T4f, T3N, T3M, T3I, T3J;
		    V T4x, T4w, T4s, T4t;
		    T42 = VADD(T40, T41);
		    T4k = VSUB(T40, T41);
		    T1g = VSUB(T1d, T1f);
		    T3j = VADD(T1f, T1d);
		    T3d = VSUB(T3b, T3c);
		    T43 = VADD(T3b, T3c);
		    T29 = VFNMS(LDK(KP414213562), TB, TK);
		    TL = VFMA(LDK(KP414213562), TK, TB);
		    T1m = VSUB(T1g, T1l);
		    T1t = VADD(T1g, T1l);
		    T3l = VSUB(T3j, T3k);
		    T4a = VADD(T3j, T3k);
		    T3C = VSUB(T3g, T3d);
		    T3h = VADD(T3d, T3g);
		    T45 = VADD(T43, T44);
		    T4p = VSUB(T44, T43);
		    T2z = VADD(T29, T28);
		    T2a = VSUB(T28, T29);
		    T2K = VADD(TL, T14);
		    T15 = VSUB(TL, T14);
		    T2E = VFMA(LDK(KP707106781), T1m, T1b);
		    T1n = VFNMS(LDK(KP707106781), T1m, T1b);
		    T2F = VFMA(LDK(KP707106781), T1t, T1s);
		    T1u = VFNMS(LDK(KP707106781), T1t, T1s);
		    T3E = VFNMS(LDK(KP414213562), T3l, T3o);
		    T3p = VFMA(LDK(KP414213562), T3o, T3l);
		    T4m = VSUB(T4a, T4b);
		    T4c = VADD(T4a, T4b);
		    T3R = VFMA(LDK(KP707106781), T3C, T3B);
		    T3D = VFNMS(LDK(KP707106781), T3C, T3B);
		    T3i = VFNMS(LDK(KP707106781), T3h, T3a);
		    T3O = VFMA(LDK(KP707106781), T3h, T3a);
		    T46 = VSUB(T42, T45);
		    T4g = VADD(T42, T45);
		    T3G = VSUB(T3E, T3F);
		    T3P = VADD(T3F, T3E);
		    T3S = VADD(T3w, T3p);
		    T3x = VSUB(T3p, T3w);
		    T4q = VSUB(T4m, T4l);
		    T4n = VADD(T4l, T4m);
		    T4d = VSUB(T49, T4c);
		    T4h = VADD(T49, T4c);
		    T3H = VFNMS(LDK(KP923879532), T3G, T3D);
		    T3L = VFMA(LDK(KP923879532), T3G, T3D);
		    T3y = VFMA(LDK(KP923879532), T3x, T3i);
		    T3K = VFNMS(LDK(KP923879532), T3x, T3i);
		    T4r = VFMA(LDK(KP707106781), T4q, T4p);
		    T4v = VFNMS(LDK(KP707106781), T4q, T4p);
		    T4o = VFMA(LDK(KP707106781), T4n, T4k);
		    T4u = VFNMS(LDK(KP707106781), T4n, T4k);
		    T3Q = VFMA(LDK(KP923879532), T3P, T3O);
		    T3W = VFNMS(LDK(KP923879532), T3P, T3O);
		    T4j = VCONJ(VMUL(LDK(KP500000000), VADD(T4h, T4g)));
		    T4i = VMUL(LDK(KP500000000), VSUB(T4g, T4h));
		    T4e = VMUL(LDK(KP500000000), VFMAI(T4d, T46));
		    T4f = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T4d, T46)));
		    T3N = VMUL(LDK(KP500000000), VFMAI(T3L, T3K));
		    T3M = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T3L, T3K)));
		    T3I = VMUL(LDK(KP500000000), VFNMSI(T3H, T3y));
		    T3J = VCONJ(VMUL(LDK(KP500000000), VFMAI(T3H, T3y)));
		    T4x = VCONJ(VMUL(LDK(KP500000000), VFMAI(T4v, T4u)));
		    T4w = VMUL(LDK(KP500000000), VFNMSI(T4v, T4u));
		    T4s = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T4r, T4o)));
		    T4t = VMUL(LDK(KP500000000), VFMAI(T4r, T4o));
		    ST(&(Rp[0]), T4i, ms, &(Rp[0]));
		    ST(&(Rm[WS(rs, 15)]), T4j, -ms, &(Rm[WS(rs, 1)]));
		    ST(&(Rm[WS(rs, 7)]), T4f, -ms, &(Rm[WS(rs, 1)]));
		    ST(&(Rp[WS(rs, 8)]), T4e, ms, &(Rp[0]));
		    ST(&(Rm[WS(rs, 9)]), T3M, -ms, &(Rm[WS(rs, 1)]));
		    ST(&(Rp[WS(rs, 10)]), T3N, ms, &(Rp[0]));
		    ST(&(Rm[WS(rs, 5)]), T3J, -ms, &(Rm[WS(rs, 1)]));
		    ST(&(Rp[WS(rs, 6)]), T3I, ms, &(Rp[0]));
		    ST(&(Rp[WS(rs, 12)]), T4w, ms, &(Rp[0]));
		    ST(&(Rm[WS(rs, 11)]), T4x, -ms, &(Rm[WS(rs, 1)]));
		    ST(&(Rp[WS(rs, 4)]), T4t, ms, &(Rp[0]));
		    ST(&(Rm[WS(rs, 3)]), T4s, -ms, &(Rm[WS(rs, 1)]));
		    {
			 V T2A, T2W, T2L, T2Z, T2D, T2N, T2M, T2G, T3T, T3X, T16, T2p, T1v, T35, T31;
			 V T2I, T2S, T34, T2Y, T2P, T2T, T1Y, T2H, T30, T3Z, T3Y, T3U, T3V, T2O, T2X;
			 V T32, T33, T36, T37, T2U, T2V, T2Q, T2R, T1Z, T2q;
			 T2A = VFNMS(LDK(KP923879532), T2z, T2y);
			 T2W = VFMA(LDK(KP923879532), T2z, T2y);
			 T2L = VFNMS(LDK(KP923879532), T2K, T2J);
			 T2Z = VFMA(LDK(KP923879532), T2K, T2J);
			 T2D = VFMA(LDK(KP198912367), T2C, T2B);
			 T2N = VFNMS(LDK(KP198912367), T2B, T2C);
			 T2M = VFMA(LDK(KP198912367), T2E, T2F);
			 T2G = VFNMS(LDK(KP198912367), T2F, T2E);
			 T3T = VFMA(LDK(KP923879532), T3S, T3R);
			 T3X = VFNMS(LDK(KP923879532), T3S, T3R);
			 T16 = VFNMS(LDK(KP923879532), T15, Ts);
			 T2m = VFMA(LDK(KP923879532), T15, Ts);
			 T2H = VSUB(T2D, T2G);
			 T30 = VADD(T2D, T2G);
			 T2b = VFNMS(LDK(KP923879532), T2a, T27);
			 T2p = VFMA(LDK(KP923879532), T2a, T27);
			 T1v = VFMA(LDK(KP668178637), T1u, T1n);
			 T2c = VFNMS(LDK(KP668178637), T1n, T1u);
			 T3Z = VCONJ(VMUL(LDK(KP500000000), VFMAI(T3X, T3W)));
			 T3Y = VMUL(LDK(KP500000000), VFNMSI(T3X, T3W));
			 T3U = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T3T, T3Q)));
			 T3V = VMUL(LDK(KP500000000), VFMAI(T3T, T3Q));
			 T2O = VSUB(T2M, T2N);
			 T2X = VADD(T2N, T2M);
			 T35 = VFNMS(LDK(KP980785280), T30, T2Z);
			 T31 = VFMA(LDK(KP980785280), T30, T2Z);
			 T2I = VFMA(LDK(KP980785280), T2H, T2A);
			 T2S = VFNMS(LDK(KP980785280), T2H, T2A);
			 ST(&(Rp[WS(rs, 14)]), T3Y, ms, &(Rp[0]));
			 ST(&(Rm[WS(rs, 13)]), T3Z, -ms, &(Rm[WS(rs, 1)]));
			 ST(&(Rp[WS(rs, 2)]), T3V, ms, &(Rp[0]));
			 ST(&(Rm[WS(rs, 1)]), T3U, -ms, &(Rm[WS(rs, 1)]));
			 T34 = VFNMS(LDK(KP980785280), T2X, T2W);
			 T2Y = VFMA(LDK(KP980785280), T2X, T2W);
			 T2P = VFMA(LDK(KP980785280), T2O, T2L);
			 T2T = VFNMS(LDK(KP980785280), T2O, T2L);
			 T2d = VFMA(LDK(KP668178637), T1Q, T1X);
			 T1Y = VFNMS(LDK(KP668178637), T1X, T1Q);
			 T32 = VMUL(LDK(KP500000000), VFNMSI(T31, T2Y));
			 T33 = VCONJ(VMUL(LDK(KP500000000), VFMAI(T31, T2Y)));
			 T36 = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T35, T34)));
			 T37 = VMUL(LDK(KP500000000), VFMAI(T35, T34));
			 T2U = VMUL(LDK(KP500000000), VFNMSI(T2T, T2S));
			 T2V = VCONJ(VMUL(LDK(KP500000000), VFMAI(T2T, T2S)));
			 T2Q = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T2P, T2I)));
			 T2R = VMUL(LDK(KP500000000), VFMAI(T2P, T2I));
			 T1Z = VSUB(T1v, T1Y);
			 T2q = VADD(T1Y, T1v);
			 ST(&(Rm[0]), T33, -ms, &(Rm[0]));
			 ST(&(Rp[WS(rs, 1)]), T32, ms, &(Rp[WS(rs, 1)]));
			 ST(&(Rp[WS(rs, 15)]), T37, ms, &(Rp[WS(rs, 1)]));
			 ST(&(Rm[WS(rs, 14)]), T36, -ms, &(Rm[0]));
			 ST(&(Rm[WS(rs, 8)]), T2V, -ms, &(Rm[0]));
			 ST(&(Rp[WS(rs, 9)]), T2U, ms, &(Rp[WS(rs, 1)]));
			 ST(&(Rp[WS(rs, 7)]), T2R, ms, &(Rp[WS(rs, 1)]));
			 ST(&(Rm[WS(rs, 6)]), T2Q, -ms, &(Rm[0]));
			 T2v = VFNMS(LDK(KP831469612), T2q, T2p);
			 T2r = VFMA(LDK(KP831469612), T2q, T2p);
			 T20 = VFMA(LDK(KP831469612), T1Z, T16);
			 T2i = VFNMS(LDK(KP831469612), T1Z, T16);
		    }
	       }
	  }
	  T2n = VADD(T2d, T2c);
	  T2e = VSUB(T2c, T2d);
	  T2o = VFMA(LDK(KP831469612), T2n, T2m);
	  T2u = VFNMS(LDK(KP831469612), T2n, T2m);
	  T2j = VFMA(LDK(KP831469612), T2e, T2b);
	  T2f = VFNMS(LDK(KP831469612), T2e, T2b);
	  T2t = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T2r, T2o)));
	  T2s = VMUL(LDK(KP500000000), VFMAI(T2r, T2o));
	  T2x = VCONJ(VMUL(LDK(KP500000000), VFMAI(T2v, T2u)));
	  T2w = VMUL(LDK(KP500000000), VFNMSI(T2v, T2u));
	  T2l = VCONJ(VMUL(LDK(KP500000000), VFNMSI(T2j, T2i)));
	  T2k = VMUL(LDK(KP500000000), VFMAI(T2j, T2i));
	  T2h = VCONJ(VMUL(LDK(KP500000000), VFMAI(T2f, T20)));
	  T2g = VMUL(LDK(KP500000000), VFNMSI(T2f, T20));
	  ST(&(Rm[WS(rs, 2)]), T2t, -ms, &(Rm[0]));
	  ST(&(Rp[WS(rs, 3)]), T2s, ms, &(Rp[WS(rs, 1)]));
	  ST(&(Rm[WS(rs, 12)]), T2x, -ms, &(Rm[0]));
	  ST(&(Rp[WS(rs, 13)]), T2w, ms, &(Rp[WS(rs, 1)]));
	  ST(&(Rm[WS(rs, 10)]), T2l, -ms, &(Rm[0]));
	  ST(&(Rp[WS(rs, 11)]), T2k, ms, &(Rp[WS(rs, 1)]));
	  ST(&(Rm[WS(rs, 4)]), T2h, -ms, &(Rm[0]));
	  ST(&(Rp[WS(rs, 5)]), T2g, ms, &(Rp[WS(rs, 1)]));
     }
}

static const tw_instr twinstr[] = {
     VTW(1, 1),
     VTW(1, 2),
     VTW(1, 3),
     VTW(1, 4),
     VTW(1, 5),
     VTW(1, 6),
     VTW(1, 7),
     VTW(1, 8),
     VTW(1, 9),
     VTW(1, 10),
     VTW(1, 11),
     VTW(1, 12),
     VTW(1, 13),
     VTW(1, 14),
     VTW(1, 15),
     VTW(1, 16),
     VTW(1, 17),
     VTW(1, 18),
     VTW(1, 19),
     VTW(1, 20),
     VTW(1, 21),
     VTW(1, 22),
     VTW(1, 23),
     VTW(1, 24),
     VTW(1, 25),
     VTW(1, 26),
     VTW(1, 27),
     VTW(1, 28),
     VTW(1, 29),
     VTW(1, 30),
     VTW(1, 31),
     {TW_NEXT, VL, 0}
};

static const hc2c_desc desc = { 32, "hc2cfdftv_32", twinstr, &GENUS, {119, 94, 130, 0} };

void X(codelet_hc2cfdftv_32) (planner *p) {
     X(khc2c_register) (p, hc2cfdftv_32, &desc, HC2C_VIA_DFT);
}
#else				/* HAVE_FMA */

/* Generated by: ../../../genfft/gen_hc2cdft_c -simd -compact -variables 4 -pipeline-latency 8 -trivial-stores -variables 32 -no-generate-bytw -n 32 -dit -name hc2cfdftv_32 -include hc2cfv.h */

/*
 * This function contains 249 FP additions, 133 FP multiplications,
 * (or, 233 additions, 117 multiplications, 16 fused multiply/add),
 * 130 stack variables, 9 constants, and 64 memory accesses
 */
#include "hc2cfv.h"

static void hc2cfdftv_32(R *Rp, R *Ip, R *Rm, R *Im, const R *W, stride rs, INT mb, INT me, INT ms)
{
     DVK(KP555570233, +0.555570233019602224742830813948532874374937191);
     DVK(KP831469612, +0.831469612302545237078788377617905756738560812);
     DVK(KP195090322, +0.195090322016128267848284868477022240927691618);
     DVK(KP980785280, +0.980785280403230449126182236134239036973933731);
     DVK(KP382683432, +0.382683432365089771728459984030398866761344562);
     DVK(KP923879532, +0.923879532511286756128183189396788286822416626);
     DVK(KP707106781, +0.707106781186547524400844362104849039284835938);
     DVK(KP353553390, +0.353553390593273762200422181052424519642417969);
     DVK(KP500000000, +0.500000000000000000000000000000000000000000000);
     INT m;
     for (m = mb, W = W + ((mb - 1) * ((TWVL / VL) * 62)); m < me; m = m + VL, Rp = Rp + (VL * ms), Ip = Ip + (VL * ms), Rm = Rm - (VL * ms), Im = Im - (VL * ms), W = W + (TWVL * 62), MAKE_VOLATILE_STRIDE(rs)) {
	  V Ta, T2m, Tx, T2h, T3R, T4h, T3q, T4g, T3B, T4n, T3E, T4o, T1B, T2S, T1O;
	  V T2R, TV, T2p, T1i, T2o, T3L, T4q, T3I, T4r, T3w, T4k, T3t, T4j, T26, T2V;
	  V T2d, T2U;
	  {
	       V T4, T1m, T1H, T2j, T1M, T2l, T9, T1o, Tf, T1r, Tq, T1w, Tv, T1y, Tk;
	       V T1t, Tl, Tw, T3P, T3Q, T3o, T3p, T3z, T3A, T3C, T3D, T1p, T1N, T1A, T1C;
	       V T1u, T1z;
	       {
		    V T1, T3, T2, T1l, T1G, T1F, T1E, T1D, T2i, T1L, T1K, T1J, T1I, T2k, T6;
		    V T8, T7, T5, T1n, Tc, Te, Td, Tb, T1q, Tn, Tp, To, Tm, T1v, Ts;
		    V Tu, Tt, Tr, T1x, Th, Tj, Ti, Tg, T1s;
		    T1 = LD(&(Rp[0]), ms, &(Rp[0]));
		    T2 = LD(&(Rm[0]), -ms, &(Rm[0]));
		    T3 = VCONJ(T2);
		    T4 = VADD(T1, T3);
		    T1l = LDW(&(W[0]));
		    T1m = VZMULIJ(T1l, VSUB(T3, T1));
		    T1G = LD(&(Rp[WS(rs, 4)]), ms, &(Rp[0]));
		    T1E = LD(&(Rm[WS(rs, 4)]), -ms, &(Rm[0]));
		    T1F = VCONJ(T1E);
		    T1D = LDW(&(W[TWVL * 16]));
		    T1H = VZMULIJ(T1D, VSUB(T1F, T1G));
		    T2i = LDW(&(W[TWVL * 14]));
		    T2j = VZMULJ(T2i, VADD(T1G, T1F));
		    T1L = LD(&(Rp[WS(rs, 12)]), ms, &(Rp[0]));
		    T1J = LD(&(Rm[WS(rs, 12)]), -ms, &(Rm[0]));
		    T1K = VCONJ(T1J);
		    T1I = LDW(&(W[TWVL * 48]));
		    T1M = VZMULIJ(T1I, VSUB(T1K, T1L));
		    T2k = LDW(&(W[TWVL * 46]));
		    T2l = VZMULJ(T2k, VADD(T1L, T1K));
		    T6 = LD(&(Rp[WS(rs, 8)]), ms, &(Rp[0]));
		    T7 = LD(&(Rm[WS(rs, 8)]), -ms, &(Rm[0]));
		    T8 = VCONJ(T7);
		    T5 = LDW(&(W[TWVL * 30]));
		    T9 = VZMULJ(T5, VADD(T6, T8));
		    T1n = LDW(&(W[TWVL * 32]));
		    T1o = VZMULIJ(T1n, VSUB(T8, T6));
		    Tc = LD(&(Rp[WS(rs, 2)]), ms, &(Rp[0]));
		    Td = LD(&(Rm[WS(rs, 2)]), -ms, &(Rm[0]));
		    Te = VCONJ(Td);
		    Tb = LDW(&(W[TWVL * 6]));
		    Tf = VZMULJ(Tb, VADD(Tc, Te));
		    T1q = LDW(&(W[TWVL * 8]));
		    T1r = VZMULIJ(T1q, VSUB(Te, Tc));
		    Tn = LD(&(Rp[WS(rs, 14)]), ms, &(Rp[0]));
		    To = LD(&(Rm[WS(rs, 14)]), -ms, &(Rm[0]));
		    Tp = VCONJ(To);
		    Tm = LDW(&(W[TWVL * 54]));
		    Tq = VZMULJ(Tm, VADD(Tn, Tp));
		    T1v = LDW(&(W[TWVL * 56]));
		    T1w = VZMULIJ(T1v, VSUB(Tp, Tn));
		    Ts = LD(&(Rp[WS(rs, 6)]), ms, &(Rp[0]));
		    Tt = LD(&(Rm[WS(rs, 6)]), -ms, &(Rm[0]));
		    Tu = VCONJ(Tt);
		    Tr = LDW(&(W[TWVL * 22]));
		    Tv = VZMULJ(Tr, VADD(Ts, Tu));
		    T1x = LDW(&(W[TWVL * 24]));
		    T1y = VZMULIJ(T1x, VSUB(Tu, Ts));
		    Th = LD(&(Rp[WS(rs, 10)]), ms, &(Rp[0]));
		    Ti = LD(&(Rm[WS(rs, 10)]), -ms, &(Rm[0]));
		    Tj = VCONJ(Ti);
		    Tg = LDW(&(W[TWVL * 38]));
		    Tk = VZMULJ(Tg, VADD(Th, Tj));
		    T1s = LDW(&(W[TWVL * 40]));
		    T1t = VZMULIJ(T1s, VSUB(Tj, Th));
	       }
	       Ta = VMUL(LDK(KP500000000), VSUB(T4, T9));
	       T2m = VSUB(T2j, T2l);
	       Tl = VSUB(Tf, Tk);
	       Tw = VSUB(Tq, Tv);
	       Tx = VMUL(LDK(KP353553390), VADD(Tl, Tw));
	       T2h = VMUL(LDK(KP707106781), VSUB(Tw, Tl));
	       T3P = VADD(Tq, Tv);
	       T3Q = VADD(Tf, Tk);
	       T3R = VSUB(T3P, T3Q);
	       T4h = VADD(T3Q, T3P);
	       T3o = VADD(T4, T9);
	       T3p = VADD(T2j, T2l);
	       T3q = VMUL(LDK(KP500000000), VSUB(T3o, T3p));
	       T4g = VADD(T3o, T3p);
	       T3z = VADD(T1m, T1o);
	       T3A = VADD(T1H, T1M);
	       T3B = VSUB(T3z, T3A);
	       T4n = VADD(T3z, T3A);
	       T3C = VADD(T1w, T1y);
	       T3D = VADD(T1r, T1t);
	       T3E = VSUB(T3C, T3D);
	       T4o = VADD(T3D, T3C);
	       T1p = VSUB(T1m, T1o);
	       T1N = VSUB(T1H, T1M);
	       T1u = VSUB(T1r, T1t);
	       T1z = VSUB(T1w, T1y);
	       T1A = VMUL(LDK(KP707106781), VADD(T1u, T1z));
	       T1C = VMUL(LDK(KP707106781), VSUB(T1z, T1u));
	       T1B = VADD(T1p, T1A);
	       T2S = VADD(T1N, T1C);
	       T1O = VSUB(T1C, T1N);
	       T2R = VSUB(T1p, T1A);
	  }
	  {
	       V TD, T1R, T1b, T29, T1g, T2b, TI, T1T, TO, T1Y, T10, T22, T15, T24, TT;
	       V T1W, TJ, TU, T16, T1h, T3J, T3K, T3G, T3H, T3u, T3v, T3r, T3s, T25, T2c;
	       V T20, T27, T1U, T1Z;
	       {
		    V TA, TC, TB, Tz, T1Q, T18, T1a, T19, T17, T28, T1d, T1f, T1e, T1c, T2a;
		    V TF, TH, TG, TE, T1S, TL, TN, TM, TK, T1X, TX, TZ, TY, TW, T21;
		    V T12, T14, T13, T11, T23, TQ, TS, TR, TP, T1V;
		    TA = LD(&(Rp[WS(rs, 1)]), ms, &(Rp[WS(rs, 1)]));
		    TB = LD(&(Rm[WS(rs, 1)]), -ms, &(Rm[WS(rs, 1)]));
		    TC = VCONJ(TB);
		    Tz = LDW(&(W[TWVL * 2]));
		    TD = VZMULJ(Tz, VADD(TA, TC));
		    T1Q = LDW(&(W[TWVL * 4]));
		    T1R = VZMULIJ(T1Q, VSUB(TC, TA));
		    T18 = LD(&(Rp[WS(rs, 3)]), ms, &(Rp[WS(rs, 1)]));
		    T19 = LD(&(Rm[WS(rs, 3)]), -ms, &(Rm[WS(rs, 1)]));
		    T1a = VCONJ(T19);
		    T17 = LDW(&(W[TWVL * 10]));
		    T1b = VZMULJ(T17, VADD(T18, T1a));
		    T28 = LDW(&(W[TWVL * 12]));
		    T29 = VZMULIJ(T28, VSUB(T1a, T18));
		    T1d = LD(&(Rp[WS(rs, 11)]), ms, &(Rp[WS(rs, 1)]));
		    T1e = LD(&(Rm[WS(rs, 11)]), -ms, &(Rm[WS(rs, 1)]));
		    T1f = VCONJ(T1e);
		    T1c = LDW(&(W[TWVL * 42]));
		    T1g = VZMULJ(T1c, VADD(T1d, T1f));
		    T2a = LDW(&(W[TWVL * 44]));
		    T2b = VZMULIJ(T2a, VSUB(T1f, T1d));
		    TF = LD(&(Rp[WS(rs, 9)]), ms, &(Rp[WS(rs, 1)]));
		    TG = LD(&(Rm[WS(rs, 9)]), -ms, &(Rm[WS(rs, 1)]));
		    TH = VCONJ(TG);
		    TE = LDW(&(W[TWVL * 34]));
		    TI = VZMULJ(TE, VADD(TF, TH));
		    T1S = LDW(&(W[TWVL * 36]));
		    T1T = VZMULIJ(T1S, VSUB(TH, TF));
		    TL = LD(&(Rp[WS(rs, 5)]), ms, &(Rp[WS(rs, 1)]));
		    TM = LD(&(Rm[WS(rs, 5)]), -ms, &(Rm[WS(rs, 1)]));
		    TN = VCONJ(TM);
		    TK = LDW(&(W[TWVL * 18]));
		    TO = VZMULJ(TK, VADD(TL, TN));
		    T1X = LDW(&(W[TWVL * 20]));
		    T1Y = VZMULIJ(T1X, VSUB(TN, TL));
		    TX = LD(&(Rp[WS(rs, 15)]), ms, &(Rp[WS(rs, 1)]));
		    TY = LD(&(Rm[WS(rs, 15)]), -ms, &(Rm[WS(rs, 1)]));
		    TZ = VCONJ(TY);
		    TW = LDW(&(W[TWVL * 58]));
		    T10 = VZMULJ(TW, VADD(TX, TZ));
		    T21 = LDW(&(W[TWVL * 60]));
		    T22 = VZMULIJ(T21, VSUB(TZ, TX));
		    T12 = LD(&(Rp[WS(rs, 7)]), ms, &(Rp[WS(rs, 1)]));
		    T13 = LD(&(Rm[WS(rs, 7)]), -ms, &(Rm[WS(rs, 1)]));
		    T14 = VCONJ(T13);
		    T11 = LDW(&(W[TWVL * 26]));
		    T15 = VZMULJ(T11, VADD(T12, T14));
		    T23 = LDW(&(W[TWVL * 28]));
		    T24 = VZMULIJ(T23, VSUB(T14, T12));
		    TQ = LD(&(Rp[WS(rs, 13)]), ms, &(Rp[WS(rs, 1)]));
		    TR = LD(&(Rm[WS(rs, 13)]), -ms, &(Rm[WS(rs, 1)]));
		    TS = VCONJ(TR);
		    TP = LDW(&(W[TWVL * 50]));
		    TT = VZMULJ(TP, VADD(TQ, TS));
		    T1V = LDW(&(W[TWVL * 52]));
		    T1W = VZMULIJ(T1V, VSUB(TS, TQ));
	       }
	       TJ = VSUB(TD, TI);
	       TU = VSUB(TO, TT);
	       TV = VFNMS(LDK(KP382683432), TU, VMUL(LDK(KP923879532), TJ));
	       T2p = VFMA(LDK(KP382683432), TJ, VMUL(LDK(KP923879532), TU));
	       T16 = VSUB(T10, T15);
	       T1h = VSUB(T1b, T1g);
	       T1i = VFMA(LDK(KP923879532), T16, VMUL(LDK(KP382683432), T1h));
	       T2o = VFNMS(LDK(KP923879532), T1h, VMUL(LDK(KP382683432), T16));
	       T3J = VADD(T1Y, T1W);
	       T3K = VADD(T1R, T1T);
	       T3L = VSUB(T3J, T3K);
	       T4q = VADD(T3K, T3J);
	       T3G = VADD(T22, T24);
	       T3H = VADD(T29, T2b);
	       T3I = VSUB(T3G, T3H);
	       T4r = VADD(T3G, T3H);
	       T3u = VADD(T10, T15);
	       T3v = VADD(T1b, T1g);
	       T3w = VSUB(T3u, T3v);
	       T4k = VADD(T3u, T3v);
	       T3r = VADD(TD, TI);
	       T3s = VADD(TO, TT);
	       T3t = VSUB(T3r, T3s);
	       T4j = VADD(T3r, T3s);
	       T25 = VSUB(T22, T24);
	       T2c = VSUB(T29, T2b);
	       T1U = VSUB(T1R, T1T);
	       T1Z = VSUB(T1W, T1Y);
	       T20 = VMUL(LDK(KP707106781), VADD(T1U, T1Z));
	       T27 = VMUL(LDK(KP707106781), VSUB(T1Z, T1U));
	       T26 = VADD(T20, T25);
	       T2V = VADD(T27, T2c);
	       T2d = VSUB(T27, T2c);
	       T2U = VSUB(T25, T20);
	  }
	  {
	       V T4m, T4w, T4t, T4x, T4i, T4l, T4p, T4s, T4u, T4z, T4v, T4y, T4E, T4L, T4H;
	       V T4K, T4A, T4F, T4D, T4G, T4B, T4C, T4I, T4N, T4J, T4M, T3O, T4c, T4d, T3X;
	       V T40, T46, T49, T41, T3y, T47, T3T, T45, T3N, T44, T3W, T48, T3x, T3S, T3F;
	       V T3M, T3U, T3V, T3Y, T4e, T4f, T3Z, T42, T4a, T4b, T43;
	       T4i = VADD(T4g, T4h);
	       T4l = VADD(T4j, T4k);
	       T4m = VADD(T4i, T4l);
	       T4w = VSUB(T4i, T4l);
	       T4p = VADD(T4n, T4o);
	       T4s = VADD(T4q, T4r);
	       T4t = VADD(T4p, T4s);
	       T4x = VBYI(VSUB(T4s, T4p));
	       T4u = VCONJ(VMUL(LDK(KP500000000), VSUB(T4m, T4t)));
	       ST(&(Rm[WS(rs, 15)]), T4u, -ms, &(Rm[WS(rs, 1)]));
	       T4z = VMUL(LDK(KP500000000), VADD(T4w, T4x));
	       ST(&(Rp[WS(rs, 8)]), T4z, ms, &(Rp[0]));
	       T4v = VMUL(LDK(KP500000000), VADD(T4m, T4t));
	       ST(&(Rp[0]), T4v, ms, &(Rp[0]));
	       T4y = VCONJ(VMUL(LDK(KP500000000), VSUB(T4w, T4x)));
	       ST(&(Rm[WS(rs, 7)]), T4y, -ms, &(Rm[WS(rs, 1)]));
	       T4A = VMUL(LDK(KP500000000), VSUB(T4g, T4h));
	       T4F = VSUB(T4k, T4j);
	       T4B = VSUB(T4n, T4o);
	       T4C = VSUB(T4r, T4q);
	       T4D = VMUL(LDK(KP353553390), VADD(T4B, T4C));
	       T4G = VMUL(LDK(KP707106781), VSUB(T4C, T4B));
	       T4E = VADD(T4A, T4D);
	       T4L = VMUL(LDK(KP500000000), VBYI(VSUB(T4G, T4F)));
	       T4H = VMUL(LDK(KP500000000), VBYI(VADD(T4F, T4G)));
	       T4K = VSUB(T4A, T4D);
	       T4I = VCONJ(VSUB(T4E, T4H));
	       ST(&(Rm[WS(rs, 3)]), T4I, -ms, &(Rm[WS(rs, 1)]));
	       T4N = VADD(T4K, T4L);
	       ST(&(Rp[WS(rs, 12)]), T4N, ms, &(Rp[0]));
	       T4J = VADD(T4E, T4H);
	       ST(&(Rp[WS(rs, 4)]), T4J, ms, &(Rp[0]));
	       T4M = VCONJ(VSUB(T4K, T4L));
	       ST(&(Rm[WS(rs, 11)]), T4M, -ms, &(Rm[WS(rs, 1)]));
	       T3x = VMUL(LDK(KP353553390), VADD(T3t, T3w));
	       T3y = VADD(T3q, T3x);
	       T47 = VSUB(T3q, T3x);
	       T3S = VMUL(LDK(KP707106781), VSUB(T3w, T3t));
	       T3T = VADD(T3R, T3S);
	       T45 = VSUB(T3S, T3R);
	       T3F = VFMA(LDK(KP923879532), T3B, VMUL(LDK(KP382683432), T3E));
	       T3M = VFNMS(LDK(KP382683432), T3L, VMUL(LDK(KP923879532), T3I));
	       T3N = VMUL(LDK(KP500000000), VADD(T3F, T3M));
	       T44 = VSUB(T3M, T3F);
	       T3U = VFNMS(LDK(KP382683432), T3B, VMUL(LDK(KP923879532), T3E));
	       T3V = VFMA(LDK(KP923879532), T3L, VMUL(LDK(KP382683432), T3I));
	       T3W = VADD(T3U, T3V);
	       T48 = VMUL(LDK(KP500000000), VSUB(T3V, T3U));
	       T3O = VADD(T3y, T3N);
	       T4c = VMUL(LDK(KP500000000), VBYI(VADD(T45, T44)));
	       T4d = VADD(T47, T48);
	       T3X = VMUL(LDK(KP500000000), VBYI(VADD(T3T, T3W)));
	       T40 = VSUB(T3y, T3N);
	       T46 = VMUL(LDK(KP500000000), VBYI(VSUB(T44, T45)));
	       T49 = VSUB(T47, T48);
	       T41 = VMUL(LDK(KP500000000), VBYI(VSUB(T3W, T3T)));
	       T3Y = VCONJ(VSUB(T3O, T3X));
	       ST(&(Rm[WS(rs, 1)]), T3Y, -ms, &(Rm[WS(rs, 1)]));
	       T4e = VADD(T4c, T4d);
	       ST(&(Rp[WS(rs, 6)]), T4e, ms, &(Rp[0]));
	       T4f = VCONJ(VSUB(T4d, T4c));
	       ST(&(Rm[WS(rs, 5)]), T4f, -ms, &(Rm[WS(rs, 1)]));
	       T3Z = VADD(T3O, T3X);
	       ST(&(Rp[WS(rs, 2)]), T3Z, ms, &(Rp[0]));
	       T42 = VCONJ(VSUB(T40, T41));
	       ST(&(Rm[WS(rs, 13)]), T42, -ms, &(Rm[WS(rs, 1)]));
	       T4a = VADD(T46, T49);
	       ST(&(Rp[WS(rs, 10)]), T4a, ms, &(Rp[0]));
	       T4b = VCONJ(VSUB(T49, T46));
	       ST(&(Rm[WS(rs, 9)]), T4b, -ms, &(Rm[WS(rs, 1)]));
	       T43 = VADD(T40, T41);
	       ST(&(Rp[WS(rs, 14)]), T43, ms, &(Rp[0]));
	       {
		    V T2g, T2K, T2L, T2v, T2y, T2E, T2H, T2z, T1k, T2F, T2u, T2G, T2f, T2C, T2r;
		    V T2D, Ty, T1j, T2s, T2t, T1P, T2e, T2n, T2q, T2w, T2M, T2N, T2x, T2A, T2I;
		    V T2J, T2B;
		    Ty = VADD(Ta, Tx);
		    T1j = VMUL(LDK(KP500000000), VADD(TV, T1i));
		    T1k = VADD(Ty, T1j);
		    T2F = VSUB(Ty, T1j);
		    T2s = VFNMS(LDK(KP195090322), T1B, VMUL(LDK(KP980785280), T1O));
		    T2t = VFMA(LDK(KP195090322), T26, VMUL(LDK(KP980785280), T2d));
		    T2u = VADD(T2s, T2t);
		    T2G = VMUL(LDK(KP500000000), VSUB(T2t, T2s));
		    T1P = VFMA(LDK(KP980785280), T1B, VMUL(LDK(KP195090322), T1O));
		    T2e = VFNMS(LDK(KP195090322), T2d, VMUL(LDK(KP980785280), T26));
		    T2f = VMUL(LDK(KP500000000), VADD(T1P, T2e));
		    T2C = VSUB(T2e, T1P);
		    T2n = VSUB(T2h, T2m);
		    T2q = VSUB(T2o, T2p);
		    T2r = VADD(T2n, T2q);
		    T2D = VSUB(T2q, T2n);
		    T2g = VADD(T1k, T2f);
		    T2K = VMUL(LDK(KP500000000), VBYI(VADD(T2D, T2C)));
		    T2L = VADD(T2F, T2G);
		    T2v = VMUL(LDK(KP500000000), VBYI(VADD(T2r, T2u)));
		    T2y = VSUB(T1k, T2f);
		    T2E = VMUL(LDK(KP500000000), VBYI(VSUB(T2C, T2D)));
		    T2H = VSUB(T2F, T2G);
		    T2z = VMUL(LDK(KP500000000), VBYI(VSUB(T2u, T2r)));
		    T2w = VCONJ(VSUB(T2g, T2v));
		    ST(&(Rm[0]), T2w, -ms, &(Rm[0]));
		    T2M = VADD(T2K, T2L);
		    ST(&(Rp[WS(rs, 7)]), T2M, ms, &(Rp[WS(rs, 1)]));
		    T2N = VCONJ(VSUB(T2L, T2K));
		    ST(&(Rm[WS(rs, 6)]), T2N, -ms, &(Rm[0]));
		    T2x = VADD(T2g, T2v);
		    ST(&(Rp[WS(rs, 1)]), T2x, ms, &(Rp[WS(rs, 1)]));
		    T2A = VCONJ(VSUB(T2y, T2z));
		    ST(&(Rm[WS(rs, 14)]), T2A, -ms, &(Rm[0]));
		    T2I = VADD(T2E, T2H);
		    ST(&(Rp[WS(rs, 9)]), T2I, ms, &(Rp[WS(rs, 1)]));
		    T2J = VCONJ(VSUB(T2H, T2E));
		    ST(&(Rm[WS(rs, 8)]), T2J, -ms, &(Rm[0]));
		    T2B = VADD(T2y, T2z);
		    ST(&(Rp[WS(rs, 15)]), T2B, ms, &(Rp[WS(rs, 1)]));
	       }
	       {
		    V T2Y, T3k, T3l, T35, T38, T3e, T3h, T39, T2Q, T3f, T34, T3g, T2X, T3c, T31;
		    V T3d, T2O, T2P, T32, T33, T2T, T2W, T2Z, T30, T36, T3m, T3n, T37, T3a, T3i;
		    V T3j, T3b;
		    T2O = VSUB(Ta, Tx);
		    T2P = VMUL(LDK(KP500000000), VADD(T2p, T2o));
		    T2Q = VADD(T2O, T2P);
		    T3f = VSUB(T2O, T2P);
		    T32 = VFNMS(LDK(KP555570233), T2R, VMUL(LDK(KP831469612), T2S));
		    T33 = VFMA(LDK(KP555570233), T2U, VMUL(LDK(KP831469612), T2V));
		    T34 = VADD(T32, T33);
		    T3g = VMUL(LDK(KP500000000), VSUB(T33, T32));
		    T2T = VFMA(LDK(KP831469612), T2R, VMUL(LDK(KP555570233), T2S));
		    T2W = VFNMS(LDK(KP555570233), T2V, VMUL(LDK(KP831469612), T2U));
		    T2X = VMUL(LDK(KP500000000), VADD(T2T, T2W));
		    T3c = VSUB(T2W, T2T);
		    T2Z = VADD(T2m, T2h);
		    T30 = VSUB(T1i, TV);
		    T31 = VADD(T2Z, T30);
		    T3d = VSUB(T30, T2Z);
		    T2Y = VADD(T2Q, T2X);
		    T3k = VMUL(LDK(KP500000000), VBYI(VADD(T3d, T3c)));
		    T3l = VADD(T3f, T3g);
		    T35 = VMUL(LDK(KP500000000), VBYI(VADD(T31, T34)));
		    T38 = VSUB(T2Q, T2X);
		    T3e = VMUL(LDK(KP500000000), VBYI(VSUB(T3c, T3d)));
		    T3h = VSUB(T3f, T3g);
		    T39 = VMUL(LDK(KP500000000), VBYI(VSUB(T34, T31)));
		    T36 = VCONJ(VSUB(T2Y, T35));
		    ST(&(Rm[WS(rs, 2)]), T36, -ms, &(Rm[0]));
		    T3m = VADD(T3k, T3l);
		    ST(&(Rp[WS(rs, 5)]), T3m, ms, &(Rp[WS(rs, 1)]));
		    T3n = VCONJ(VSUB(T3l, T3k));
		    ST(&(Rm[WS(rs, 4)]), T3n, -ms, &(Rm[0]));
		    T37 = VADD(T2Y, T35);
		    ST(&(Rp[WS(rs, 3)]), T37, ms, &(Rp[WS(rs, 1)]));
		    T3a = VCONJ(VSUB(T38, T39));
		    ST(&(Rm[WS(rs, 12)]), T3a, -ms, &(Rm[0]));
		    T3i = VADD(T3e, T3h);
		    ST(&(Rp[WS(rs, 11)]), T3i, ms, &(Rp[WS(rs, 1)]));
		    T3j = VCONJ(VSUB(T3h, T3e));
		    ST(&(Rm[WS(rs, 10)]), T3j, -ms, &(Rm[0]));
		    T3b = VADD(T38, T39);
		    ST(&(Rp[WS(rs, 13)]), T3b, ms, &(Rp[WS(rs, 1)]));
	       }
	  }
     }
}

static const tw_instr twinstr[] = {
     VTW(1, 1),
     VTW(1, 2),
     VTW(1, 3),
     VTW(1, 4),
     VTW(1, 5),
     VTW(1, 6),
     VTW(1, 7),
     VTW(1, 8),
     VTW(1, 9),
     VTW(1, 10),
     VTW(1, 11),
     VTW(1, 12),
     VTW(1, 13),
     VTW(1, 14),
     VTW(1, 15),
     VTW(1, 16),
     VTW(1, 17),
     VTW(1, 18),
     VTW(1, 19),
     VTW(1, 20),
     VTW(1, 21),
     VTW(1, 22),
     VTW(1, 23),
     VTW(1, 24),
     VTW(1, 25),
     VTW(1, 26),
     VTW(1, 27),
     VTW(1, 28),
     VTW(1, 29),
     VTW(1, 30),
     VTW(1, 31),
     {TW_NEXT, VL, 0}
};

static const hc2c_desc desc = { 32, "hc2cfdftv_32", twinstr, &GENUS, {233, 117, 16, 0} };

void X(codelet_hc2cfdftv_32) (planner *p) {
     X(khc2c_register) (p, hc2cfdftv_32, &desc, HC2C_VIA_DFT);
}
#endif				/* HAVE_FMA */
@set UPDATED 5 February 2009
@set UPDATED-MONTH February 2009
@set EDITION 3.2.1
@set VERSION 3.2.1
/*
  ==============================================================================

   This file is part of the JUCE library.
   Copyright (c) 2015 - ROLI Ltd.

   Permission is granted to use this software under the terms of either:
   a) the GPL v2 (or any later version)
   b) the Affero GPL v3

   Details of these licenses can be found at: www.gnu.org/licenses

   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

   ------------------------------------------------------------------------------

   To release a closed-source product which uses JUCE, commercial licenses are
   available: visit www.juce.com for more information.

  ==============================================================================
*/

interface ISampleGrabberCB  : public IUnknown
{
    virtual STDMETHODIMP SampleCB (double, IMediaSample*) = 0;
    virtual STDMETHODIMP BufferCB (double, BYTE*, long) = 0;
};

interface ISampleGrabber  : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetOneShot (BOOL) = 0;
    virtual HRESULT STDMETHODCALLTYPE SetMediaType (const AM_MEDIA_TYPE*) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType (AM_MEDIA_TYPE*) = 0;
    virtual HRESULT STDMETHODCALLTYPE SetBufferSamples (BOOL) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer (long*, long*) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetCurrentSample (IMediaSample**) = 0;
    virtual HRESULT STDMETHODCALLTYPE SetCallback (ISampleGrabberCB*, long) = 0;
};

static const IID IID_ISampleGrabberCB  = { 0x0579154A, 0x2B53, 0x4994, { 0xB0, 0xD0, 0xE7, 0x73, 0x14, 0x8E, 0xFF, 0x85 } };
static const IID IID_ISampleGrabber    = { 0x6B652FFF, 0x11FE, 0x4fce, { 0x92, 0xAD, 0x02, 0x66, 0xB5, 0xD7, 0xC7, 0x8F } };
static const CLSID CLSID_SampleGrabber = { 0xC1F400A0, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };
static const CLSID CLSID_NullRenderer  = { 0xC1F400A4, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };


struct CameraDevice::Pimpl  : public ChangeBroadcaster
{
    Pimpl (const String&, int index,
           int minWidth, int minHeight,
           int maxWidth, int maxHeight)
       : isRecording (false),
         openedSuccessfully (false),
         imageNeedsFlipping (false),
         width (0), height (0),
         activeUsers (0),
         recordNextFrameTime (false),
         previewMaxFPS (60)
    {
        HRESULT hr = captureGraphBuilder.CoCreateInstance (CLSID_CaptureGraphBuilder2);
        if (FAILED (hr))
            return;

        filter = enumerateCameras (nullptr, index);
        if (filter == nullptr)
            return;

        hr = graphBuilder.CoCreateInstance (CLSID_FilterGraph);
        if (FAILED (hr))
            return;

        hr = captureGraphBuilder->SetFiltergraph (graphBuilder);
        if (FAILED (hr))
            return;

        hr = graphBuilder.QueryInterface (mediaControl);
        if (FAILED (hr))
            return;

        {
            ComSmartPtr<IAMStreamConfig> streamConfig;

            hr = captureGraphBuilder->FindInterface (&PIN_CATEGORY_CAPTURE, 0, filter,
                                                     IID_IAMStreamConfig, (void**) streamConfig.resetAndGetPointerAddress());

            if (streamConfig != nullptr)
            {
                getVideoSizes (streamConfig);

                if (! selectVideoSize (streamConfig, minWidth, minHeight, maxWidth, maxHeight))
                    return;
            }
        }

        hr = graphBuilder->AddFilter (filter, _T("Video Capture"));
        if (FAILED (hr))
            return;

        hr = smartTee.CoCreateInstance (CLSID_SmartTee);
        if (FAILED (hr))
            return;

        hr = graphBuilder->AddFilter (smartTee, _T("Smart Tee"));
        if (FAILED (hr))
            return;

        if (! connectFilters (filter, smartTee))
            return;

        ComSmartPtr<IBaseFilter> sampleGrabberBase;
        hr = sampleGrabberBase.CoCreateInstance (CLSID_SampleGrabber);
        if (FAILED (hr))
            return;

        hr = sampleGrabberBase.QueryInterface (IID_ISampleGrabber, sampleGrabber);
        if (FAILED (hr))
            return;

        {
            AM_MEDIA_TYPE mt = { 0 };
            mt.majortype = MEDIATYPE_Video;
            mt.subtype = MEDIASUBTYPE_RGB24;
            mt.formattype = FORMAT_VideoInfo;
            sampleGrabber->SetMediaType (&mt);
        }

        callback = new GrabberCallback (*this);
        hr = sampleGrabber->SetCallback (callback, 1);

        hr = graphBuilder->AddFilter (sampleGrabberBase, _T("Sample Grabber"));
        if (FAILED (hr))
            return;

        ComSmartPtr<IPin> grabberInputPin;
        if (! (getPin (smartTee, PINDIR_OUTPUT, smartTeeCaptureOutputPin, "capture")
                && getPin (smartTee, PINDIR_OUTPUT, smartTeePreviewOutputPin, "preview")
                && getPin (sampleGrabberBase, PINDIR_INPUT, grabberInputPin)))
            return;

        hr = graphBuilder->Connect (smartTeePreviewOutputPin, grabberInputPin);
        if (FAILED (hr))
            return;

        AM_MEDIA_TYPE mt = { 0 };
        hr = sampleGrabber->GetConnectedMediaType (&mt);
        VIDEOINFOHEADER* pVih = (VIDEOINFOHEADER*) (mt.pbFormat);
        width = pVih->bmiHeader.biWidth;
        height = pVih->bmiHeader.biHeight;

        ComSmartPtr<IBaseFilter> nullFilter;
        hr = nullFilter.CoCreateInstance (CLSID_NullRenderer);
        hr = graphBuilder->AddFilter (nullFilter, _T("Null Renderer"));

        if (connectFilters (sampleGrabberBase, nullFilter)
              && addGraphToRot())
        {
            activeImage = Image (Image::RGB, width, height, true);
            loadingImage = Image (Image::RGB, width, height, true);

            openedSuccessfully = true;
        }
    }

    ~Pimpl()
    {
        if (mediaControl != nullptr)
            mediaControl->Stop();

        removeGraphFromRot();
        disconnectAnyViewers();

        if (sampleGrabber != nullptr)
        {
            sampleGrabber->SetCallback (nullptr, 0);
            sampleGrabber = nullptr;
        }

        callback = nullptr;
        graphBuilder = nullptr;
        mediaControl = nullptr;
        filter = nullptr;
        captureGraphBuilder = nullptr;
        smartTee = nullptr;
        smartTeePreviewOutputPin = nullptr;
        smartTeeCaptureOutputPin = nullptr;
        asfWriter = nullptr;
    }

    bool openedOk() const noexcept       { return openedSuccessfully; }

    void startRecordingToFile (const File& file, int quality)
    {
        addUser();
        isRecording = createFileCaptureFilter (file, quality);
    }

    void stopRecording()
    {
        if (isRecording)
        {
            removeFileCaptureFilter();
            removeUser();
            isRecording = false;
        }
    }

    Time getTimeOfFirstRecordedFrame() const
    {
        return firstRecordedTime;
    }

    void addListener (CameraDevice::Listener* listenerToAdd)
    {
        const ScopedLock sl (listenerLock);

        if (listeners.size() == 0)
            addUser();

        listeners.addIfNotAlreadyThere (listenerToAdd);
    }

    void removeListener (CameraDevice::Listener* listenerToRemove)
    {
        const ScopedLock sl (listenerLock);
        listeners.removeAllInstancesOf (listenerToRemove);

        if (listeners.size() == 0)
            removeUser();
    }

    void callListeners (const Image& image)
    {
        const ScopedLock sl (listenerLock);

        for (int i = listeners.size(); --i >= 0;)
            if (CameraDevice::Listener* const l = listeners[i])
                l->imageReceived (image);
    }

    void addUser()
    {
        if (openedSuccessfully && activeUsers++ == 0)
            mediaControl->Run();
    }

    void removeUser()
    {
        if (openedSuccessfully && --activeUsers == 0)
            mediaControl->Stop();
    }

    void handleFrame (double /*time*/, BYTE* buffer, long /*bufferSize*/)
    {
        if (recordNextFrameTime)
        {
            const double defaultCameraLatency = 0.1;

            firstRecordedTime = Time::getCurrentTime() - RelativeTime (defaultCameraLatency);
            recordNextFrameTime = false;

            ComSmartPtr<IPin> pin;
            if (getPin (filter, PINDIR_OUTPUT, pin))
            {
                ComSmartPtr<IAMPushSource> pushSource;
                HRESULT hr = pin.QueryInterface (pushSource);

                if (pushSource != nullptr)
                {
                    REFERENCE_TIME latency = 0;
                    hr = pushSource->GetLatency (&latency);

                    firstRecordedTime = firstRecordedTime - RelativeTime ((double) latency);
                }
            }
        }

        {
            const int lineStride = width * 3;
            const ScopedLock sl (imageSwapLock);

            {
                loadingImage.duplicateIfShared();
                const Image::BitmapData destData (loadingImage, 0, 0, width, height, Image::BitmapData::writeOnly);

                for (int i = 0; i < height; ++i)
                    memcpy (destData.getLinePointer ((height - 1) - i),
                            buffer + lineStride * i,
                            lineStride);
            }

            imageNeedsFlipping = true;
        }

        if (listeners.size() > 0)
            callListeners (loadingImage);

        sendChangeMessage();
    }

    void drawCurrentImage (Graphics& g, Rectangle<int> area)
    {
        if (imageNeedsFlipping)
        {
            const ScopedLock sl (imageSwapLock);
            std::swap (loadingImage, activeImage);
            imageNeedsFlipping = false;
        }

        Rectangle<int> centred (RectanglePlacement (RectanglePlacement::centred)
                                    .appliedTo (Rectangle<int> (width, height), area));

        RectangleList<int> borders (area);
        borders.subtract (centred);
        g.setColour (Colours::black);
        g.fillRectList (borders);

        g.drawImage (activeImage, centred.getX(), centred.getY(),
                     centred.getWidth(), centred.getHeight(), 0, 0, width, height);
    }

    bool createFileCaptureFilter (const File& file, int quality)
    {
        removeFileCaptureFilter();
        file.deleteFile();
        mediaControl->Stop();
        firstRecordedTime = Time();
        recordNextFrameTime = true;
        previewMaxFPS = 60;

        HRESULT hr = asfWriter.CoCreateInstance (CLSID_WMAsfWriter);

        if (SUCCEEDED (hr))
        {
            ComSmartPtr<IFileSinkFilter> fileSink;
            hr = asfWriter.QueryInterface (fileSink);

            if (SUCCEEDED (hr))
            {
                hr = fileSink->SetFileName (file.getFullPathName().toWideCharPointer(), 0);

                if (SUCCEEDED (hr))
                {
                    hr = graphBuilder->AddFilter (asfWriter, _T("AsfWriter"));

                    if (SUCCEEDED (hr))
                    {
                        ComSmartPtr<IConfigAsfWriter> asfConfig;
                        hr = asfWriter.QueryInterface (asfConfig);
                        asfConfig->SetIndexMode (true);
                        ComSmartPtr<IWMProfileManager> profileManager;
                        hr = WMCreateProfileManager (profileManager.resetAndGetPointerAddress());

                        // This gibberish is the DirectShow profile for a video-only wmv file.
                        String prof ("<profile version=\"589824\" storageformat=\"1\" name=\"Quality\" description=\"Quality type for output.\">"
                                       "<streamconfig majortype=\"{73646976-0000-0010-8000-00AA00389B71}\" streamnumber=\"1\" "
                                                     "streamname=\"Video Stream\" inputname=\"Video409\" bitrate=\"894960\" "
                                                     "bufferwindow=\"0\" reliabletransport=\"1\" decodercomplexity=\"AU\" rfc1766langid=\"en-us\">"
                                         "<videomediaprops maxkeyframespacing=\"50000000\" quality=\"90\"/>"
                                         "<wmmediatype subtype=\"{33564D57-0000-0010-8000-00AA00389B71}\" bfixedsizesamples=\"0\" "
                                                      "btemporalcompression=\"1\" lsamplesize=\"0\">"
                                         "<videoinfoheader dwbitrate=\"894960\" dwbiterrorrate=\"0\" avgtimeperframe=\"$AVGTIMEPERFRAME\">"
                                             "<rcsource left=\"0\" top=\"0\" right=\"$WIDTH\" bottom=\"$HEIGHT\"/>"
                                             "<rctarget left=\"0\" top=\"0\" right=\"$WIDTH\" bottom=\"$HEIGHT\"/>"
                                             "<bitmapinfoheader biwidth=\"$WIDTH\" biheight=\"$HEIGHT\" biplanes=\"1\" bibitcount=\"24\" "
                                                               "bicompression=\"WMV3\" bisizeimage=\"0\" bixpelspermeter=\"0\" biypelspermeter=\"0\" "
                                                               "biclrused=\"0\" biclrimportant=\"0\"/>"
                                           "</videoinfoheader>"
                                         "</wmmediatype>"
                                       "</streamconfig>"
                                     "</profile>");

                        const int fps[] = { 10, 15, 30 };
                        int maxFramesPerSecond = fps [jlimit (0, numElementsInArray (fps) - 1, quality & 0xff)];

                        if ((quality & 0xff000000) != 0) // (internal hacky way to pass explicit frame rates for testing)
                            maxFramesPerSecond = (quality >> 24) & 0xff;

                        prof = prof.replace ("$WIDTH", String (width))
                                   .replace ("$HEIGHT", String (height))
                                   .replace ("$AVGTIMEPERFRAME", String (10000000 / maxFramesPerSecond));

                        ComSmartPtr<IWMProfile> currentProfile;
                        hr = profileManager->LoadProfileByData (prof.toWideCharPointer(), currentProfile.resetAndGetPointerAddress());
                        hr = asfConfig->ConfigureFilterUsingProfile (currentProfile);

                        if (SUCCEEDED (hr))
                        {
                            ComSmartPtr<IPin> asfWriterInputPin;

                            if (getPin (asfWriter, PINDIR_INPUT, asfWriterInputPin, "Video Input 01"))
                            {
                                hr = graphBuilder->Connect (smartTeeCaptureOutputPin, asfWriterInputPin);

                                if (SUCCEEDED (hr) && openedSuccessfully && activeUsers > 0
                                     && SUCCEEDED (mediaControl->Run()))
                                {
                                    previewMaxFPS = (quality < 2) ? 15 : 25; // throttle back the preview comps to try to leave the cpu free for encoding

                                    if ((quality & 0x00ff0000) != 0)  // (internal hacky way to pass explicit frame rates for testing)
                                        previewMaxFPS = (quality >> 16) & 0xff;

                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }

        removeFileCaptureFilter();

        if (openedSuccessfully && activeUsers > 0)
            mediaControl->Run();

        return false;
    }

    void removeFileCaptureFilter()
    {
        mediaControl->Stop();

        if (asfWriter != nullptr)
        {
            graphBuilder->RemoveFilter (asfWriter);
            asfWriter = nullptr;
        }

        if (openedSuccessfully && activeUsers > 0)
            mediaControl->Run();

        previewMaxFPS = 60;
    }

    static ComSmartPtr<IBaseFilter> enumerateCameras (StringArray* names, const int deviceIndexToOpen)
    {
        int index = 0;
        ComSmartPtr<ICreateDevEnum> pDevEnum;

        if (SUCCEEDED (pDevEnum.CoCreateInstance (CLSID_SystemDeviceEnum)))
        {
            ComSmartPtr<IEnumMoniker> enumerator;
            HRESULT hr = pDevEnum->CreateClassEnumerator (CLSID_VideoInputDeviceCategory, enumerator.resetAndGetPointerAddress(), 0);

            if (SUCCEEDED (hr) && enumerator != nullptr)
            {
                ComSmartPtr<IMoniker> moniker;
                ULONG fetched;

                while (enumerator->Next (1, moniker.resetAndGetPointerAddress(), &fetched) == S_OK)
                {
                    ComSmartPtr<IBaseFilter> captureFilter;
                    hr = moniker->BindToObject (0, 0, IID_IBaseFilter, (void**) captureFilter.resetAndGetPointerAddress());

                    if (SUCCEEDED (hr))
                    {
                        ComSmartPtr<IPropertyBag> propertyBag;
                        hr = moniker->BindToStorage (0, 0, IID_IPropertyBag, (void**) propertyBag.resetAndGetPointerAddress());

                        if (SUCCEEDED (hr))
                        {
                            VARIANT var;
                            var.vt = VT_BSTR;

                            hr = propertyBag->Read (_T("FriendlyName"), &var, 0);
                            propertyBag = nullptr;

                            if (SUCCEEDED (hr))
                            {
                                if (names != nullptr)
                                    names->add (var.bstrVal);

                                if (index == deviceIndexToOpen)
                                    return captureFilter;

                                ++index;
                            }
                        }
                    }
                }
            }
        }

        return nullptr;
    }

    static StringArray getAvailableDevices()
    {
        StringArray devs;
        enumerateCameras (&devs, -1);
        return devs;
    }

    class GrabberCallback   : public ComBaseClassHelperBase<ISampleGrabberCB>
    {
    public:
        GrabberCallback (Pimpl& p)
            : ComBaseClassHelperBase<ISampleGrabberCB> (0), owner (p) {}

        JUCE_COMRESULT QueryInterface (REFIID refId, void** result)
        {
            if (refId == IID_ISampleGrabberCB)
                return castToType<ISampleGrabberCB> (result);

            return ComBaseClassHelperBase<ISampleGrabberCB>::QueryInterface (refId, result);
        }

        STDMETHODIMP SampleCB (double, IMediaSample*)  { return E_FAIL; }

        STDMETHODIMP BufferCB (double time, BYTE* buffer, long bufferSize)
        {
            owner.handleFrame (time, buffer, bufferSize);
            return S_OK;
        }

    private:
        Pimpl& owner;

        JUCE_DECLARE_NON_COPYABLE (GrabberCallback)
    };

    ComSmartPtr<GrabberCallback> callback;
    Array<CameraDevice::Listener*> listeners;
    CriticalSection listenerLock;

    bool isRecording, openedSuccessfully;
    int width, height;
    Time firstRecordedTime;

    Array<ViewerComponent*> viewerComps;

    ComSmartPtr<ICaptureGraphBuilder2> captureGraphBuilder;
    ComSmartPtr<IBaseFilter> filter, smartTee, asfWriter;
    ComSmartPtr<IGraphBuilder> graphBuilder;
    ComSmartPtr<ISampleGrabber> sampleGrabber;
    ComSmartPtr<IMediaControl> mediaControl;
    ComSmartPtr<IPin> smartTeePreviewOutputPin, smartTeeCaptureOutputPin;
    int activeUsers;
    Array<int> widths, heights;
    DWORD graphRegistrationID;

    CriticalSection imageSwapLock;
    bool imageNeedsFlipping;
    Image loadingImage, activeImage;

    bool recordNextFrameTime;
    int previewMaxFPS;

private:
    void getVideoSizes (IAMStreamConfig* const streamConfig)
    {
        widths.clear();
        heights.clear();

        int count = 0, size = 0;
        streamConfig->GetNumberOfCapabilities (&count, &size);

        if (size == sizeof (VIDEO_STREAM_CONFIG_CAPS))
        {
            for (int i = 0; i < count; ++i)
            {
                VIDEO_STREAM_CONFIG_CAPS scc;
                AM_MEDIA_TYPE* config;

                HRESULT hr = streamConfig->GetStreamCaps (i, &config, (BYTE*) &scc);

                if (SUCCEEDED (hr))
                {
                    const int w = scc.InputSize.cx;
                    const int h = scc.InputSize.cy;

                    bool duplicate = false;

                    for (int j = widths.size(); --j >= 0;)
                    {
                        if (w == widths.getUnchecked (j) && h == heights.getUnchecked (j))
                        {
                            duplicate = true;
                            break;
                        }
                    }

                    if (! duplicate)
                    {
                        DBG ("Camera capture size: " + String (w) + ", " + String (h));
                        widths.add (w);
                        heights.add (h);
                    }

                    deleteMediaType (config);
                }
            }
        }
    }

    bool selectVideoSize (IAMStreamConfig* const streamConfig,
                          const int minWidth, const int minHeight,
                          const int maxWidth, const int maxHeight)
    {
        int count = 0, size = 0, bestArea = 0, bestIndex = -1;
        streamConfig->GetNumberOfCapabilities (&count, &size);

        if (size == sizeof (VIDEO_STREAM_CONFIG_CAPS))
        {
            AM_MEDIA_TYPE* config;
            VIDEO_STREAM_CONFIG_CAPS scc;

            for (int i = 0; i < count; ++i)
            {
                HRESULT hr = streamConfig->GetStreamCaps (i, &config, (BYTE*) &scc);

                if (SUCCEEDED (hr))
                {
                    if (scc.InputSize.cx >= minWidth
                         && scc.InputSize.cy >= minHeight
                         && scc.InputSize.cx <= maxWidth
                         && scc.InputSize.cy <= maxHeight)
                    {
                        int area = scc.InputSize.cx * scc.InputSize.cy;
                        if (area > bestArea)
                        {
                            bestIndex = i;
                            bestArea = area;
                        }
                    }

                    deleteMediaType (config);
                }
            }

            if (bestIndex >= 0)
            {
                HRESULT hr = streamConfig->GetStreamCaps (bestIndex, &config, (BYTE*) &scc);

                hr = streamConfig->SetFormat (config);
                deleteMediaType (config);
                return SUCCEEDED (hr);
            }
        }

        return false;
    }

    static bool getPin (IBaseFilter* filter, const PIN_DIRECTION wantedDirection,
                        ComSmartPtr<IPin>& result, const char* pinName = nullptr)
    {
        ComSmartPtr<IEnumPins> enumerator;
        ComSmartPtr<IPin> pin;

        filter->EnumPins (enumerator.resetAndGetPointerAddress());

        while (enumerator->Next (1, pin.resetAndGetPointerAddress(), 0) == S_OK)
        {
            PIN_DIRECTION dir;
            pin->QueryDirection (&dir);

            if (wantedDirection == dir)
            {
                PIN_INFO info = { 0 };
                pin->QueryPinInfo (&info);

                if (pinName == nullptr || String (pinName).equalsIgnoreCase (String (info.achName)))
                {
                    result = pin;
                    return true;
                }
            }
        }

        return false;
    }

    bool connectFilters (IBaseFilter* const first, IBaseFilter* const second) const
    {
        ComSmartPtr<IPin> in, out;

        return getPin (first, PINDIR_OUTPUT, out)
                && getPin (second, PINDIR_INPUT, in)
                && SUCCEEDED (graphBuilder->Connect (out, in));
    }

    bool addGraphToRot()
    {
        ComSmartPtr<IRunningObjectTable> rot;
        if (FAILED (GetRunningObjectTable (0, rot.resetAndGetPointerAddress())))
            return false;

        ComSmartPtr<IMoniker> moniker;
        WCHAR buffer[128];
        HRESULT hr = CreateItemMoniker (_T("!"), buffer, moniker.resetAndGetPointerAddress());
        if (FAILED (hr))
            return false;

        graphRegistrationID = 0;
        return SUCCEEDED (rot->Register (0, graphBuilder, moniker, &graphRegistrationID));
    }

    void removeGraphFromRot()
    {
        ComSmartPtr<IRunningObjectTable> rot;

        if (SUCCEEDED (GetRunningObjectTable (0, rot.resetAndGetPointerAddress())))
            rot->Revoke (graphRegistrationID);
    }

    void disconnectAnyViewers();

    static void deleteMediaType (AM_MEDIA_TYPE* const pmt)
    {
        if (pmt->cbFormat != 0)
            CoTaskMemFree ((PVOID) pmt->pbFormat);

        if (pmt->pUnk != nullptr)
            pmt->pUnk->Release();

        CoTaskMemFree (pmt);
    }

    JUCE_DECLARE_NON_COPYABLE (Pimpl)
};

//==============================================================================
struct CameraDevice::ViewerComponent  : public Component,
                                        public ChangeListener
{
    ViewerComponent (CameraDevice& d)
       : owner (d.pimpl), maxFPS (15), lastRepaintTime (0)
    {
        setOpaque (true);
        owner->addChangeListener (this);
        owner->addUser();
        owner->viewerComps.add (this);
        setSize (owner->width, owner->height);
    }

    ~ViewerComponent()
    {
        if (owner != nullptr)
        {
            owner->viewerComps.removeFirstMatchingValue (this);
            owner->removeUser();
            owner->removeChangeListener (this);
        }
    }

    void ownerDeleted()
    {
        owner = nullptr;
    }

    void paint (Graphics& g) override
    {
        g.setColour (Colours::black);
        g.setImageResamplingQuality (Graphics::lowResamplingQuality);

        if (owner != nullptr)
            owner->drawCurrentImage (g, getLocalBounds());
        else
            g.fillAll();
    }

    void changeListenerCallback (ChangeBroadcaster*) override
    {
        const int64 now = Time::currentTimeMillis();

        if (now >= lastRepaintTime + (1000 / maxFPS))
        {
            lastRepaintTime = now;
            repaint();

            if (owner != nullptr)
                maxFPS = owner->previewMaxFPS;
        }
    }

private:
    Pimpl* owner;
    int maxFPS;
    int64 lastRepaintTime;
};

void CameraDevice::Pimpl::disconnectAnyViewers()
{
    for (int i = viewerComps.size(); --i >= 0;)
        viewerComps.getUnchecked(i)->ownerDeleted();
}

String CameraDevice::getFileExtension()
{
    return ".wmv";
}
/*
Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.
For licensing, see LICENSE.html or http://ckeditor.com/license
*/
CKEDITOR.lang['ms']={"editor":"Rich Text Editor","editorPanel":"Rich Text Editor panel","common":{"editorHelp":"Press ALT 0 for help","browseServer":"Browse Server","url":"URL","protocol":"Protokol","upload":"Muat Naik","uploadSubmit":"Hantar ke Server","image":"Gambar","flash":"Flash","form":"Borang","checkbox":"Checkbox","radio":"Butang Radio","textField":"Text Field","textarea":"Textarea","hiddenField":"Field Tersembunyi","button":"Butang","select":"Field Pilihan","imageButton":"Butang Bergambar","notSet":"<tidak di set>","id":"Id","name":"Nama","langDir":"Arah Tulisan","langDirLtr":"Kiri ke Kanan (LTR)","langDirRtl":"Kanan ke Kiri (RTL)","langCode":"Kod Bahasa","longDescr":"Butiran Panjang URL","cssClass":"Kelas-kelas Stylesheet","advisoryTitle":"Tajuk Makluman","cssStyle":"Stail","ok":"OK","cancel":"Batal","close":"Close","preview":"Prebiu","resize":"Resize","generalTab":"General","advancedTab":"Advanced","validateNumberFailed":"This value is not a number.","confirmNewPage":"Any unsaved changes to this content will be lost. Are you sure you want to load new page?","confirmCancel":"You have changed some options. Are you sure you want to close the dialog window?","options":"Options","target":"Sasaran","targetNew":"New Window (_blank)","targetTop":"Topmost Window (_top)","targetSelf":"Same Window (_self)","targetParent":"Parent Window (_parent)","langDirLTR":"Kiri ke Kanan (LTR)","langDirRTL":"Kanan ke Kiri (RTL)","styles":"Stail","cssClasses":"Kelas-kelas Stylesheet","width":"Lebar","height":"Tinggi","align":"Jajaran","alignLeft":"Kiri","alignRight":"Kanan","alignCenter":"Tengah","alignTop":"Atas","alignMiddle":"Pertengahan","alignBottom":"Bawah","alignNone":"None","invalidValue":"Invalid value.","invalidHeight":"Height must be a number.","invalidWidth":"Width must be a number.","invalidCssLength":"Value specified for the \"%1\" field must be a positive number with or without a valid CSS measurement unit (px, %, in, cm, mm, em, ex, pt, or pc).","invalidHtmlLength":"Value specified for the \"%1\" field must be a positive number with or without a valid HTML measurement unit (px or %).","invalidInlineStyle":"Value specified for the inline style must consist of one or more tuples with the format of \"name : value\", separated by semi-colons.","cssLengthTooltip":"Enter a number for a value in pixels or a number with a valid CSS unit (px, %, in, cm, mm, em, ex, pt, or pc).","unavailable":"%1<span class=\"cke_accessibility\">, unavailable</span>"},"about":{"copy":"Copyright &copy; $1. All rights reserved.","dlgTitle":"About CKEditor","help":"Check $1 for help.","moreInfo":"For licensing information please visit our web site:","title":"About CKEditor","userGuide":"CKEditor User's Guide"},"basicstyles":{"bold":"Bold","italic":"Italic","strike":"Strike Through","subscript":"Subscript","superscript":"Superscript","underline":"Underline"},"bidi":{"ltr":"Text direction from left to right","rtl":"Text direction from right to left"},"blockquote":{"toolbar":"Block Quote"},"clipboard":{"copy":"Salin","copyError":"Keselamatan perisian browser anda tidak membenarkan operasi salinan text/imej. Sila gunakan papan kekunci (Ctrl/Cmd+C).","cut":"Potong","cutError":"Keselamatan perisian browser anda tidak membenarkan operasi suntingan text/imej. Sila gunakan papan kekunci (Ctrl/Cmd+X).","paste":"Tampal","pasteArea":"Paste Area","pasteMsg":"Please paste inside the following box using the keyboard (<strong>Ctrl/Cmd+V</strong>) and hit OK","securityMsg":"Because of your browser security settings, the editor is not able to access your clipboard data directly. You are required to paste it again in this window.","title":"Tampal"},"button":{"selectedLabel":"%1 (Selected)"},"colorbutton":{"auto":"Otomatik","bgColorTitle":"Warna Latarbelakang","colors":{"000":"Black","800000":"Maroon","8B4513":"Saddle Brown","2F4F4F":"Dark Slate Gray","008080":"Teal","000080":"Navy","4B0082":"Indigo","696969":"Dark Gray","B22222":"Fire Brick","A52A2A":"Brown","DAA520":"Golden Rod","006400":"Dark Green","40E0D0":"Turquoise","0000CD":"Medium Blue","800080":"Purple","808080":"Gray","F00":"Red","FF8C00":"Dark Orange","FFD700":"Gold","008000":"Green","0FF":"Cyan","00F":"Blue","EE82EE":"Violet","A9A9A9":"Dim Gray","FFA07A":"Light Salmon","FFA500":"Orange","FFFF00":"Yellow","00FF00":"Lime","AFEEEE":"Pale Turquoise","ADD8E6":"Light Blue","DDA0DD":"Plum","D3D3D3":"Light Grey","FFF0F5":"Lavender Blush","FAEBD7":"Antique White","FFFFE0":"Light Yellow","F0FFF0":"Honeydew","F0FFFF":"Azure","F0F8FF":"Alice Blue","E6E6FA":"Lavender","FFF":"White"},"more":"Warna lain-lain...","panelTitle":"Colors","textColorTitle":"Warna Text"},"colordialog":{"clear":"Clear","highlight":"Highlight","options":"Color Options","selected":"Selected Color","title":"Select color"},"templates":{"button":"Templat","emptyListMsg":"(Tiada Templat Disimpan)","insertOption":"Replace actual contents","options":"Template Options","selectPromptMsg":"Sila pilih templat untuk dibuka oleh editor<br>(kandungan sebenar akan hilang):","title":"Templat Kandungan"},"contextmenu":{"options":"Context Menu Options"},"div":{"IdInputLabel":"Id","advisoryTitleInputLabel":"Advisory Title","cssClassInputLabel":"Stylesheet Classes","edit":"Edit Div","inlineStyleInputLabel":"Inline Style","langDirLTRLabel":"Left to Right (LTR)","langDirLabel":"Language Direction","langDirRTLLabel":"Right to Left (RTL)","languageCodeInputLabel":" Language Code","remove":"Remove Div","styleSelectLabel":"Style","title":"Create Div Container","toolbar":"Create Div Container"},"toolbar":{"toolbarCollapse":"Collapse Toolbar","toolbarExpand":"Expand Toolbar","toolbarGroups":{"document":"Document","clipboard":"Clipboard/Undo","editing":"Editing","forms":"Forms","basicstyles":"Basic Styles","paragraph":"Paragraph","links":"Links","insert":"Insert","styles":"Styles","colors":"Colors","tools":"Tools"},"toolbars":"Editor toolbars"},"elementspath":{"eleLabel":"Elements path","eleTitle":"%1 element"},"find":{"find":"Cari","findOptions":"Find Options","findWhat":"Perkataan yang dicari:","matchCase":"Padanan case huruf","matchCyclic":"Match cyclic","matchWord":"Padana Keseluruhan perkataan","notFoundMsg":"Text yang dicari tidak dijumpai.","replace":"Ganti","replaceAll":"Ganti semua","replaceSuccessMsg":"%1 occurrence(s) replaced.","replaceWith":"Diganti dengan:","title":"Find and Replace"},"fakeobjects":{"anchor":"Anchor","flash":"Flash Animation","hiddenfield":"Hidden Field","iframe":"IFrame","unknown":"Unknown Object"},"flash":{"access":"Script Access","accessAlways":"Always","accessNever":"Never","accessSameDomain":"Same domain","alignAbsBottom":"Bawah Mutlak","alignAbsMiddle":"Pertengahan Mutlak","alignBaseline":"Garis Dasar","alignTextTop":"Atas Text","bgcolor":"Warna Latarbelakang","chkFull":"Allow Fullscreen","chkLoop":"Loop","chkMenu":"Enable Flash Menu","chkPlay":"Auto Play","flashvars":"Variables for Flash","hSpace":"Ruang Melintang","properties":"Flash Properties","propertiesTab":"Properties","quality":"Quality","qualityAutoHigh":"Auto High","qualityAutoLow":"Auto Low","qualityBest":"Best","qualityHigh":"High","qualityLow":"Low","qualityMedium":"Medium","scale":"Scale","scaleAll":"Show all","scaleFit":"Exact Fit","scaleNoBorder":"No Border","title":"Flash Properties","vSpace":"Ruang Menegak","validateHSpace":"HSpace must be a number.","validateSrc":"Sila taip sambungan URL","validateVSpace":"VSpace must be a number.","windowMode":"Window mode","windowModeOpaque":"Opaque","windowModeTransparent":"Transparent","windowModeWindow":"Window"},"font":{"fontSize":{"label":"Saiz","voiceLabel":"Font Size","panelTitle":"Saiz"},"label":"Font","panelTitle":"Font","voiceLabel":"Font"},"forms":{"button":{"title":"Ciri-ciri Butang","text":"Teks (Nilai)","type":"Jenis","typeBtn":"Button","typeSbm":"Submit","typeRst":"Reset"},"checkboxAndRadio":{"checkboxTitle":"Ciri-ciri Checkbox","radioTitle":"Ciri-ciri Butang Radio","value":"Nilai","selected":"Dipilih"},"form":{"title":"Ciri-ciri Borang","menu":"Ciri-ciri Borang","action":"Tindakan borang","method":"Cara borang dihantar","encoding":"Encoding"},"hidden":{"title":"Ciri-ciri Field Tersembunyi","name":"Nama","value":"Nilai"},"select":{"title":"Ciri-ciri Selection Field","selectInfo":"Select Info","opAvail":"Pilihan sediada","value":"Nilai","size":"Saiz","lines":"garisan","chkMulti":"Benarkan pilihan pelbagai","opText":"Teks","opValue":"Nilai","btnAdd":"Tambah Pilihan","btnModify":"Ubah Pilihan","btnUp":"Naik ke atas","btnDown":"Turun ke bawah","btnSetValue":"Set sebagai nilai terpilih","btnDelete":"Padam"},"textarea":{"title":"Ciri-ciri Textarea","cols":"Lajur","rows":"Baris"},"textfield":{"title":"Ciri-ciri Text Field","name":"Nama","value":"Nilai","charWidth":"Lebar isian","maxChars":"Isian Maksimum","type":"Jenis","typeText":"Teks","typePass":"Kata Laluan","typeEmail":"Email","typeSearch":"Search","typeTel":"Telephone Number","typeUrl":"URL"}},"format":{"label":"Format","panelTitle":"Format","tag_address":"Alamat","tag_div":"Perenggan (DIV)","tag_h1":"Heading 1","tag_h2":"Heading 2","tag_h3":"Heading 3","tag_h4":"Heading 4","tag_h5":"Heading 5","tag_h6":"Heading 6","tag_p":"Normal","tag_pre":"Telah Diformat"},"horizontalrule":{"toolbar":"Masukkan Garisan Membujur"},"iframe":{"border":"Show frame border","noUrl":"Please type the iframe URL","scrolling":"Enable scrollbars","title":"IFrame Properties","toolbar":"IFrame"},"image":{"alertUrl":"Sila taip URL untuk fail gambar","alt":"Text Alternatif","border":"Border","btnUpload":"Hantar ke Server","button2Img":"Do you want to transform the selected image button on a simple image?","hSpace":"Ruang Melintang","img2Button":"Do you want to transform the selected image on a image button?","infoTab":"Info Imej","linkTab":"Sambungan","lockRatio":"Tetapkan Nisbah","menu":"Ciri-ciri Imej","resetSize":"Saiz Set Semula","title":"Ciri-ciri Imej","titleButton":"Ciri-ciri Butang Bergambar","upload":"Muat Naik","urlMissing":"Image source URL is missing.","vSpace":"Ruang Menegak","validateBorder":"Border must be a whole number.","validateHSpace":"HSpace must be a whole number.","validateVSpace":"VSpace must be a whole number."},"indent":{"indent":"Tambahkan Inden","outdent":"Kurangkan Inden"},"smiley":{"options":"Smiley Options","title":"Masukkan Smiley","toolbar":"Smiley"},"justify":{"block":"Jajaran Blok","center":"Jajaran Tengah","left":"Jajaran Kiri","right":"Jajaran Kanan"},"language":{"button":"Set language","remove":"Remove language"},"link":{"acccessKey":"Kunci Akses","advanced":"Advanced","advisoryContentType":"Jenis Kandungan Makluman","advisoryTitle":"Tajuk Makluman","anchor":{"toolbar":"Masukkan/Sunting Pautan","menu":"Ciri-ciri Pautan","title":"Ciri-ciri Pautan","name":"Nama Pautan","errorName":"Sila taip nama pautan","remove":"Remove Anchor"},"anchorId":"dengan menggunakan ID elemen","anchorName":"dengan menggunakan nama pautan","charset":"Linked Resource Charset","cssClasses":"Kelas-kelas Stylesheet","emailAddress":"Alamat E-Mail","emailBody":"Isi Kandungan Mesej","emailSubject":"Subjek Mesej","id":"Id","info":"Butiran Sambungan","langCode":"Arah Tulisan","langDir":"Arah Tulisan","langDirLTR":"Kiri ke Kanan (LTR)","langDirRTL":"Kanan ke Kiri (RTL)","menu":"Sunting Sambungan","name":"Nama","noAnchors":"(Tiada pautan terdapat dalam dokumen ini)","noEmail":"Sila taip alamat e-mail","noUrl":"Sila taip sambungan URL","other":"<lain>","popupDependent":"Bergantungan (Netscape)","popupFeatures":"Ciri Tetingkap Popup","popupFullScreen":"Skrin Penuh (IE)","popupLeft":"Posisi Kiri","popupLocationBar":"Bar Lokasi","popupMenuBar":"Bar Menu","popupResizable":"Resizable","popupScrollBars":"Bar-bar skrol","popupStatusBar":"Bar Status","popupToolbar":"Toolbar","popupTop":"Posisi Atas","rel":"Relationship","selectAnchor":"Sila pilih pautan","styles":"Stail","tabIndex":"Indeks Tab ","target":"Sasaran","targetFrame":"<bingkai>","targetFrameName":"Nama Bingkai Sasaran","targetPopup":"<tetingkap popup>","targetPopupName":"Nama Tetingkap Popup","title":"Sambungan","toAnchor":"Pautan dalam muka surat ini","toEmail":"E-Mail","toUrl":"URL","toolbar":"Masukkan/Sunting Sambungan","type":"Jenis Sambungan","unlink":"Buang Sambungan","upload":"Muat Naik"},"list":{"bulletedlist":"Senarai tidak bernombor","numberedlist":"Senarai bernombor"},"liststyle":{"armenian":"Armenian numbering","bulletedTitle":"Bulleted List Properties","circle":"Circle","decimal":"Decimal (1, 2, 3, etc.)","decimalLeadingZero":"Decimal leading zero (01, 02, 03, etc.)","disc":"Disc","georgian":"Georgian numbering (an, ban, gan, etc.)","lowerAlpha":"Lower Alpha (a, b, c, d, e, etc.)","lowerGreek":"Lower Greek (alpha, beta, gamma, etc.)","lowerRoman":"Lower Roman (i, ii, iii, iv, v, etc.)","none":"None","notset":"<not set>","numberedTitle":"Numbered List Properties","square":"Square","start":"Start","type":"Type","upperAlpha":"Upper Alpha (A, B, C, D, E, etc.)","upperRoman":"Upper Roman (I, II, III, IV, V, etc.)","validateStartNumber":"List start number must be a whole number."},"magicline":{"title":"Insert paragraph here"},"maximize":{"maximize":"Maximize","minimize":"Minimize"},"newpage":{"toolbar":"Helaian Baru"},"pagebreak":{"alt":"Page Break","toolbar":"Insert Page Break for Printing"},"pastetext":{"button":"Tampal sebagai text biasa","title":"Tampal sebagai text biasa"},"pastefromword":{"confirmCleanup":"The text you want to paste seems to be copied from Word. Do you want to clean it before pasting?","error":"It was not possible to clean up the pasted data due to an internal error","title":"Tampal dari Word","toolbar":"Tampal dari Word"},"preview":{"preview":"Prebiu"},"print":{"toolbar":"Cetak"},"removeformat":{"toolbar":"Buang Format"},"save":{"toolbar":"Simpan"},"selectall":{"toolbar":"Pilih Semua"},"showblocks":{"toolbar":"Show Blocks"},"sourcearea":{"toolbar":"Sumber"},"specialchar":{"options":"Special Character Options","title":"Sila pilih huruf istimewa","toolbar":"Masukkan Huruf Istimewa"},"scayt":{"btn_about":"About SCAYT","btn_dictionaries":"Dictionaries","btn_disable":"Disable SCAYT","btn_enable":"Enable SCAYT","btn_langs":"Languages","btn_options":"Options","text_title":""},"stylescombo":{"label":"Stail","panelTitle":"Formatting Styles","panelTitle1":"Block Styles","panelTitle2":"Inline Styles","panelTitle3":"Object Styles"},"table":{"border":"Saiz Border","caption":"Keterangan","cell":{"menu":"Cell","insertBefore":"Insert Cell Before","insertAfter":"Insert Cell After","deleteCell":"Buangkan Sel-sel","merge":"Cantumkan Sel-sel","mergeRight":"Merge Right","mergeDown":"Merge Down","splitHorizontal":"Split Cell Horizontally","splitVertical":"Split Cell Vertically","title":"Cell Properties","cellType":"Cell Type","rowSpan":"Rows Span","colSpan":"Columns Span","wordWrap":"Word Wrap","hAlign":"Horizontal Alignment","vAlign":"Vertical Alignment","alignBaseline":"Baseline","bgColor":"Background Color","borderColor":"Border Color","data":"Data","header":"Header","yes":"Yes","no":"No","invalidWidth":"Cell width must be a number.","invalidHeight":"Cell height must be a number.","invalidRowSpan":"Rows span must be a whole number.","invalidColSpan":"Columns span must be a whole number.","chooseColor":"Choose"},"cellPad":"Tambahan Ruang Sel","cellSpace":"Ruangan Antara Sel","column":{"menu":"Column","insertBefore":"Insert Column Before","insertAfter":"Insert Column After","deleteColumn":"Buangkan Lajur"},"columns":"Jaluran","deleteTable":"Delete Table","headers":"Headers","headersBoth":"Both","headersColumn":"First column","headersNone":"None","headersRow":"First Row","invalidBorder":"Border size must be a number.","invalidCellPadding":"Cell padding must be a positive number.","invalidCellSpacing":"Cell spacing must be a positive number.","invalidCols":"Number of columns must be a number greater than 0.","invalidHeight":"Table height must be a number.","invalidRows":"Number of rows must be a number greater than 0.","invalidWidth":"Table width must be a number.","menu":"Ciri-ciri Jadual","row":{"menu":"Row","insertBefore":"Insert Row Before","insertAfter":"Insert Row After","deleteRow":"Buangkan Baris"},"rows":"Barisan","summary":"Summary","title":"Ciri-ciri Jadual","toolbar":"Jadual","widthPc":"peratus","widthPx":"piksel-piksel","widthUnit":"width unit"},"undo":{"redo":"Ulangkan","undo":"Batalkan"},"wsc":{"btnIgnore":"Biar","btnIgnoreAll":"Biarkan semua","btnReplace":"Ganti","btnReplaceAll":"Gantikan Semua","btnUndo":"Batalkan","changeTo":"Tukarkan kepada","errorLoading":"Error loading application service host: %s.","ieSpellDownload":"Pemeriksa ejaan tidak dipasang. Adakah anda mahu muat turun sekarang?","manyChanges":"Pemeriksaan ejaan siap: %1 perkataan diubah","noChanges":"Pemeriksaan ejaan siap: Tiada perkataan diubah","noMispell":"Pemeriksaan ejaan siap: Tiada salah ejaan","noSuggestions":"- Tiada cadangan -","notAvailable":"Sorry, but service is unavailable now.","notInDic":"Tidak terdapat didalam kamus","oneChange":"Pemeriksaan ejaan siap: Satu perkataan telah diubah","progress":"Pemeriksaan ejaan sedang diproses...","title":"Spell Check","toolbar":"Semak Ejaan"}};########################################################
# Euclid_lensing likelihood
########################################################
# written by Benjamin Audren
# (adapted from J Lesgourgues's old COSMOS likelihood for CosmoMC)
#
# Modified by S. Clesse in March 2016 to add an optional form of n(z)
# motivated by ground based exp. (Van Waerbeke et al., 2013)
# See google doc document prepared by the Euclid IST - Splinter 2
#
# Modified by J. Lesgourgues in March 2016 to vectorise and speed up

from montepython.likelihood_class import Likelihood
import io_mp
#import time

import scipy.integrate
from scipy import interpolate as itp
import os
import numpy as np
import math
import warnings

class euclid_lensing(Likelihood):

    def __init__(self, path, data, command_line):

        Likelihood.__init__(self, path, data, command_line)

        # Force the cosmological module to store Pk for redshifts up to
        # max(self.z) and for k up to k_max
        self.need_cosmo_arguments(data, {'output': 'mPk'})
        self.need_cosmo_arguments(data, {'z_max_pk': self.zmax})
        self.need_cosmo_arguments(data, {'P_k_max_h/Mpc': self.k_max_h_by_Mpc})

        # Compute non-linear power spectrum if requested
        if (self.use_halofit):
            self.need_cosmo_arguments(data, {'non linear':'halofit'})

        # Define array of l values, and initialize them
        # It is a logspace
        # find nlmax in order to reach lmax with logarithmic steps dlnl
        self.nlmax = np.int(np.log(self.lmax/self.lmin)/self.dlnl)+1
        # redefine slightly dlnl so that the last point is always exactly lmax
        self.dlnl = np.log(self.lmax/self.lmin)/(self.nlmax-1)
        self.l = self.lmin*np.exp(self.dlnl*np.arange(self.nlmax))

        ########################################################
        # Find distribution of dn_dz (not normalized) in each bin
        ########################################################
        # Assuming each bin contains the same number of galaxies, we find the
        # bin limits in z space
        # Compute the total number of galaxies until zmax (no normalization
        # yet), that is the integral of the galaxy distribution function from 0
        # to self.zmax
        n_tot, error = scipy.integrate.quad(
            self.galaxy_distribution, 0, self.zmax)
        assert error <= 1e-7,  (
            "The integration of the galaxy distribution is not as "
            "precise as expected.")

        # For each bin, compute the limit in z space

        # Create the array that will contain the z boundaries for each bin. The
        # first value is already correctly set to 0.
        self.z_bin_edge = np.zeros(self.nbin+1, 'float64')

        for Bin in xrange(self.nbin-1):
            bin_count = 0.
            z = self.z_bin_edge[Bin]
            while (bin_count <= n_tot/self.nbin):
                gd_1 = self.galaxy_distribution(z)
                gd_2 = self.galaxy_distribution(z+self.dz)
                bin_count += 0.5*(gd_1+gd_2)*self.dz
                z += self.dz
            self.z_bin_edge[Bin+1] = z
        self.z_bin_edge[self.nbin] = self.zmax

        # Fill array of discrete z values
        self.z = np.linspace(0, self.zmax, num=self.nzmax)

        # Fill distribution for each bin (convolving with photo_z distribution)
        self.eta_z = np.zeros((self.nzmax, self.nbin), 'float64')
        gal = self.galaxy_distribution(self.z, True)
        for Bin in xrange(self.nbin):
            low = self.z_bin_edge[Bin]
            hig = self.z_bin_edge[Bin+1]
            for nz in xrange(self.nzmax):
                z = self.z[nz]
                integrand = gal*self.photo_z_distribution(z, self.z, True)
                integrand = np.array([
                    elem if low <= self.z[index] <= hig else 0
                    for index, elem in enumerate(integrand)])
                self.eta_z[nz, Bin] = scipy.integrate.trapz(
                    integrand,
                    self.z)

        # integrate eta(z) over z (in view of normalizing it to one)
        self.eta_norm = np.zeros(self.nbin, 'float64')
        for Bin in xrange(self.nbin):
            self.eta_norm[Bin] = np.sum(0.5*(
                self.eta_z[1:, Bin]+self.eta_z[:-1, Bin])*(
                self.z[1:]-self.z[:-1]))

        ################
        # Noise spectrum
        ################

        # Number of galaxies per steradian
        self.noise = 3600.*self.gal_per_sqarcmn*(180./math.pi)**2

        # Number of galaxies per steradian per bin
        self.noise = self.noise/self.nbin

        # Noise spectrum (diagonal in bin*bin space, independent of l and Bin)
        self.noise = self.rms_shear**2/self.noise

        ###########
        # Read data
        ###########

        # If the file exists, initialize the fiducial values
        # It has been stored flat, so we use the reshape function to put it in
        # the right shape.
        self.Cl_fid = np.zeros((self.nlmax, self.nbin, self.nbin), 'float64')
        self.fid_values_exist = False
        fid_file_path = os.path.join(self.data_directory, self.fiducial_file)
        if os.path.exists(fid_file_path):
            self.fid_values_exist = True
            flat_Cl = np.loadtxt(fid_file_path)
            self.Cl_fid = flat_Cl.reshape((self.nlmax, self.nbin, self.nbin))

        return

    def galaxy_distribution(self, z, array=False):
        """
        Galaxy distribution returns the function D(z) from the notes

        If the array flag is set to True, z is then interpretated as an array,
        and not as a single value.

        Modified by S. Clesse in March 2016 to add an optional form of n(z) motivated by ground based exp. (Van Waerbeke et al., 2013)
        See google doc document prepared by the Euclid IST - Splinter 2
        """

        zmean = 0.9
        z0 = zmean/1.412

        if not array:
            galaxy_dist = z**2*math.exp(-(z/z0)**(1.5))
        elif self.nofz_method==1:
            return z**2*np.exp(-(z/z0)**(1.5))
        else:
            return self.a1*np.exp(-(z-0.7)**2/self.b1**2.)+self.c1*np.exp(-(z-1.2)**2/self.d1**2.)


        return galaxy_dist

    def photo_z_distribution(self, z, zph, array=True):
        """
        Photo z distribution

        If the array flag is set to True, z is then interpretated as an array,
        and not as a single value.
        """

        # Standard error on dz/(1+z)
        sigma_ph = 0.05

        # Note: you must normalize it yourself to one if you want to get nice
        # plots of the galaxy distribution function in each bin (otherwise, the
        # spectra will remain correct, but each D_i(x) will loot strangely
        # normalized when compared to the original D(z)
        if not array:
            photo_z_dist = math.exp(-0.5*(
                (z-zph)/sigma_ph/(1.+z))**2)/sigma_ph/(1.+z)/math.sqrt(
                2.*math.pi)
        else:
            photo_z_dist = np.exp(-0.5*(
                (z-zph)/sigma_ph/(1.+z))**2)/sigma_ph/(1.+z)/math.sqrt(
                2.*math.pi)

        return photo_z_dist

    def loglkl(self, cosmo, data):

        #start = time.time()

        # One wants to obtain here the relation between z and r, this is done
        # by asking the cosmological module with the function z_of_r
        self.r = np.zeros(self.nzmax, 'float64')
        self.dzdr = np.zeros(self.nzmax, 'float64')

        self.r, self.dzdr = cosmo.z_of_r(self.z)

        # Compute now the selection function eta(r) = eta(z) dz/dr normalized
        # to one. The np.newaxis helps to broadcast the one-dimensional array
        # dzdr to the proper shape. Note that eta_norm is also broadcasted as
        # an array of the same shape as eta_z
        self.eta_r = self.eta_z*(self.dzdr[:, np.newaxis]/self.eta_norm)

        # Compute function g_i(r), that depends on r and the bin
        # g_i(r) = 2r(1+z(r)) int_0^+\infty drs eta_r(rs) (rs-r)/rs
        # TODO is the integration from 0 or r ?
        g = np.zeros((self.nzmax, self.nbin), 'float64')
        for Bin in xrange(self.nbin):
            for nr in xrange(1, self.nzmax-1):
                fun = self.eta_r[nr:, Bin]*(self.r[nr:]-self.r[nr])/self.r[nr:]
                g[nr, Bin] = np.sum(0.5*(
                    fun[1:]+fun[:-1])*(self.r[nr+1:]-self.r[nr:-1]))
                g[nr, Bin] *= 2.*self.r[nr]*(1.+self.z[nr])

        # Get power spectrum P(k=l/r,z(r)) from cosmological module
        kmin_in_inv_Mpc = self.k_min_h_by_Mpc * cosmo.h()
        kmax_in_inv_Mpc = self.k_max_h_by_Mpc * cosmo.h()
        pk = np.zeros((self.nlmax, self.nzmax), 'float64')
        for index_l in xrange(self.nlmax):
            for index_z in xrange(1, self.nzmax):

        # These lines would return an error when you ask for P(k,z) out of computed range
        #        if (self.l[index_l]/self.r[index_z] > self.k_max):
        #            raise io_mp.LikelihoodError(
        #                "you should increase euclid_lensing.k_max up to at least %g" % (self.l[index_l]/self.r[index_z]))
        #        pk[index_l, index_z] = cosmo.pk(
        #            self.l[index_l]/self.r[index_z], self.z[index_z])

        # These lines set P(k,z) to zero out of [k_min, k_max] range
                k_in_inv_Mpc =  self.l[index_l]/self.r[index_z]
                if (k_in_inv_Mpc < kmin_in_inv_Mpc) or (k_in_inv_Mpc > kmax_in_inv_Mpc):
                    pk[index_l, index_z] = 0.
                else:
                    pk[index_l, index_z] = cosmo.pk(self.l[index_l]/self.r[index_z], self.z[index_z])

        # Recover the non_linear scale computed by halofit. If no scale was
        # affected, set the scale to one, and make sure that the nuisance
        # parameter epsilon is set to zero
        k_sigma = np.zeros(self.nzmax, 'float64')
        if (cosmo.nonlinear_method == 0):
            k_sigma[:] = 1.e6
        else:
            k_sigma = cosmo.nonlinear_scale(self.z, self.nzmax)

        # Define the alpha function, that will characterize the theoretical
        # uncertainty. Chosen to be 0.001 at low k, raise between 0.1 and 0.2
        # to self.theoretical_error
        alpha = np.zeros((self.nlmax, self.nzmax), 'float64')
        # self.theoretical_error = 0.1
        if self.theoretical_error != 0:
            for index_l in range(self.nlmax):
                k = self.l[index_l]/self.r[1:]
                alpha[index_l, 1:] = np.log(1.+k[:]/k_sigma[1:])/(
                    1.+np.log(1.+k[:]/k_sigma[1:]))*self.theoretical_error

        # recover the e_th_nu part of the error function
        e_th_nu = self.coefficient_f_nu*cosmo.Omega_nu/cosmo.Omega_m()

        # Compute the Error E_th_nu function
        if 'epsilon' in self.use_nuisance:
            E_th_nu = np.zeros((self.nlmax, self.nzmax), 'float64')
            for index_l in range(1, self.nlmax):
                E_th_nu[index_l, :] = np.log(
                    1.+self.l[index_l]/k_sigma[:]*self.r[:]) / (
                    1.+np.log(1.+self.l[index_l]/k_sigma[:]*self.r[:]))*e_th_nu

        # Add the error function, with the nuisance parameter, to P_nl_th, if
        # the nuisance parameter exists
                for index_l in range(self.nlmax):
                    epsilon = data.mcmc_parameters['epsilon']['current']*(
                        data.mcmc_parameters['epsilon']['scale'])
                    pk[index_l, :] *= (1.+epsilon*E_th_nu[index_l, :])

        # Start loop over l for computation of C_l^shear
        Cl_integrand = np.zeros((self.nzmax, self.nbin, self.nbin), 'float64')
        Cl = np.zeros((self.nlmax, self.nbin, self.nbin), 'float64')
        # Start loop over l for computation of E_l
        if self.theoretical_error != 0:
            El_integrand = np.zeros((self.nzmax, self.nbin, self.nbin),
                                    'float64')
            El = np.zeros((self.nlmax, self.nbin, self.nbin), 'float64')

        for nl in xrange(self.nlmax):

            # find Cl_integrand = (g(r) / r)**2 * P(l/r,z(r))
            for Bin1 in xrange(self.nbin):
                for Bin2 in xrange(Bin1,self.nbin):
                    Cl_integrand[1:, Bin1, Bin2] = g[1:, Bin1]*g[1:, Bin2]/(
                        self.r[1:]**2)*pk[nl, 1:]
                    if self.theoretical_error != 0:
                        El_integrand[1:, Bin1, Bin2] = g[1:, Bin1]*(
                            g[1:, Bin2])/(
                            self.r[1:]**2)*pk[nl, 1:]*alpha[nl, 1:]

            # Integrate over r to get C_l^shear_ij = P_ij(l)
            # C_l^shear_ij = 9/16 Omega0_m^2 H_0^4 \sum_0^rmax dr (g_i(r)
            # g_j(r) /r**2) P(k=l/r,z(r))
            # It it then multiplied by 9/16*Omega_m**2 to be in units of Mpc**4
            # and then by (h/2997.9)**4 to be dimensionless
            for Bin1 in xrange(self.nbin):
                for Bin2 in xrange(Bin1,self.nbin):
                    Cl[nl, Bin1, Bin2] = np.sum(0.5*(
                        Cl_integrand[1:, Bin1, Bin2] +
                        Cl_integrand[:-1, Bin1, Bin2])*(
                        self.r[1:]-self.r[:-1]))
                    Cl[nl, Bin1, Bin2] *= 9./16.*(cosmo.Omega_m())**2
                    Cl[nl, Bin1, Bin2] *= (cosmo.h()/2997.9)**4

                    if self.theoretical_error != 0:
                        El[nl, Bin1, Bin2] = np.sum(0.5*(
                            El_integrand[1:, Bin1, Bin2] +
                            El_integrand[:-1, Bin1, Bin2])*(
                            self.r[1:]-self.r[:-1]))
                        El[nl, Bin1, Bin2] *= 9./16.*(cosmo.Omega_m())**2
                        El[nl, Bin1, Bin2] *= (cosmo.h()/2997.9)**4
                    if Bin1 == Bin2:
                        Cl[nl, Bin1, Bin2] += self.noise

        # Write fiducial model spectra if needed (exit in that case)
        if self.fid_values_exist is False:
            # Store the values now, and exit.
            fid_file_path = os.path.join(
                self.data_directory, self.fiducial_file)
            with open(fid_file_path, 'w') as fid_file:
                fid_file.write('# Fiducial parameters')
                for key, value in data.mcmc_parameters.iteritems():
                    fid_file.write(
                        ', %s = %.5g' % (key, value['current']*value['scale']))
                fid_file.write('\n')
                for nl in range(self.nlmax):
                    for Bin1 in range(self.nbin):
                        for Bin2 in range(self.nbin):
                            fid_file.write("%.8g\n" % Cl[nl, Bin1, Bin2])
            print '\n'
            warnings.warn(
                "Writing fiducial model in %s, for %s likelihood\n" % (
                    self.data_directory+'/'+self.fiducial_file, self.name))
            return 1j

        # Now that the fiducial model is stored, we add the El to both Cl and
        # Cl_fid (we create a new array, otherwise we would modify the
        # self.Cl_fid from one step to the other)

        # Spline Cl[nl,Bin1,Bin2] along l
        spline_Cl = np.empty((self.nbin, self.nbin), dtype=(list, 3))
        for Bin1 in xrange(self.nbin):
            for Bin2 in xrange(Bin1, self.nbin):
                spline_Cl[Bin1, Bin2] = list(itp.splrep(
                    self.l, Cl[:, Bin1, Bin2]))
                if Bin2 > Bin1:
                    spline_Cl[Bin2, Bin1] = spline_Cl[Bin1, Bin2]

        # Spline El[nl,Bin1,Bin2] along l
        if self.theoretical_error != 0:
            spline_El = np.empty((self.nbin, self.nbin), dtype=(list, 3))
            for Bin1 in xrange(self.nbin):
                for Bin2 in xrange(Bin1, self.nbin):
                    spline_El[Bin1, Bin2] = list(itp.splrep(
                        self.l, El[:, Bin1, Bin2]))
                    if Bin2 > Bin1:
                        spline_El[Bin2, Bin1] = spline_El[Bin1, Bin2]

        # Spline Cl_fid[nl,Bin1,Bin2]    along l
        spline_Cl_fid = np.empty((self.nbin, self.nbin), dtype=(list, 3))
        for Bin1 in xrange(self.nbin):
            for Bin2 in xrange(Bin1, self.nbin):
                spline_Cl_fid[Bin1, Bin2] = list(itp.splrep(
                    self.l, self.Cl_fid[:, Bin1, Bin2]))
                if Bin2 > Bin1:
                    spline_Cl_fid[Bin2, Bin1] = spline_Cl_fid[Bin1, Bin2]

        # Compute likelihood

        # Prepare interpolation for every integer value of l, from the array
        # self.l, to finally compute the likelihood (sum over all l's)
        dof = 1./(int(self.l[-1])-int(self.l[0])+1)

        ells = range(int(self.l[0]), int(self.l[-1])+1)

        # Define cov theory, observ and error on the whole integer range of ell
        # values
        Cov_theory = np.zeros((len(ells), self.nbin, self.nbin), 'float64')
        Cov_observ = np.zeros((len(ells), self.nbin, self.nbin), 'float64')
        Cov_error = np.zeros((len(ells), self.nbin, self.nbin), 'float64')

        for Bin1 in xrange(self.nbin):
            for Bin2 in xrange(Bin1, self.nbin):
                Cov_theory[:, Bin1, Bin2] = itp.splev(
                    ells, spline_Cl[Bin1, Bin2])
                Cov_observ[:, Bin1, Bin2] = itp.splev(
                    ells, spline_Cl_fid[Bin1, Bin2])
                if self.theoretical_error > 0:
                    Cov_error[:, Bin1, Bin2] = itp.splev(
                        ells, spline_El[Bin1, Bin2])
                if Bin2 > Bin1:
                    Cov_theory[:, Bin2, Bin1] = Cov_theory[:, Bin1, Bin2]
                    Cov_observ[:, Bin2, Bin1] = Cov_observ[:, Bin1, Bin2]
                    Cov_error[:, Bin2, Bin1] = Cov_error[:, Bin1, Bin2]

        chi2 = 0.

        # chi2 computation in presence of theoretical error
        # (in absence of it, computation more straightforward, see below)
        # TODO parallelize this
        if (self.theoretical_error > 0):

            for index, ell in enumerate(ells):

                det_theory = np.linalg.det(Cov_theory[index, :, :])
                det_observ = np.linalg.det(Cov_observ[index, :, :])

                det_cross_err = 0
                for i in range(self.nbin):
                    newCov = np.copy(Cov_theory)
                    newCov[:, i] = Cov_error[:, i]
                    det_cross_err += np.linalg.det(newCov)

                # Newton method to minimise chi2 over nuisance parameter epsilon_l
                # (only when using theoretical error scheme of 1210.2194)
                # Find starting point for the method:
                start = 0
                step = 0.001*det_theory/det_cross_err
                error = 1
                old_chi2 = -1.*data.boundary_loglike
                error_tol = 0.01
                epsilon_l = start
                while error > error_tol:
                    vector = np.array([epsilon_l-step,
                                       epsilon_l,
                                       epsilon_l+step])
                # Computing the function on three neighbouring points
                    function_vector = np.zeros(3, 'float64')
                    for k in range(3):
                        Cov_theory_plus_error = Cov_theory+vector[k]*Cov_error
                        det_theory_plus_error = np.linalg.det(
                            Cov_theory_plus_error)
                        det_theory_plus_error_cross_obs = 0
                        for i in range(self.nbin):
                            newCov = np.copy(Cov_theory_plus_error)
                            newCov[:, i] = Cov_observ[:, i]
                            det_theory_plus_error_cross_obs += np.linalg.det(
                                newCov)
                        function_vector[k] = (2.*ell+1.)*self.fsky*(det_theory_plus_error_cross_obs/det_theory_plus_error + math.log(det_theory_plus_error/det_observ) - self.nbin ) + dof*vector[k]**2

                    # Computing first
                    first_d    = (function_vector[2]-function_vector[0]) / (vector[2]-vector[0])
                    second_d = (function_vector[2]+function_vector[0]-2*function_vector[1]) / (vector[2]-vector[1])**2

                    # Updating point and error
                    epsilon_l = vector[1] - first_d/second_d
                    error = abs(function_vector[1] - old_chi2)
                    old_chi2 = function_vector[1]
                # End Newton

                Cov_theory_plus_error = Cov_theory + epsilon_l * Cov_error
                det_theory_plus_error = np.linalg.det(Cov_theory_plus_error)

                det_theory_plus_error_cross_obs = 0
                for i in range(self.nbin):
                    newCov = np.copy(Cov_theory_plus_error)
                    newCov[:, i] = Cov_observ[:, i]
                    det_theory_plus_error_cross_obs += np.linalg.det(newCov)

                chi2 += (2.*ell+1.)*self.fsky*(det_theory_plus_error_cross_obs/det_theory_plus_error + math.log(det_theory_plus_error/det_observ) - self.nbin ) + dof*epsilon_l**2


        # chi2 computation in absence of theoretical error (vectorized)
        else:

            det_theory = np.zeros(len(ells), 'float64')
            det_observ = np.zeros(len(ells), 'float64')
            det_cross_term = np.zeros((self.nbin, len(ells)), 'float64')
            det_cross = np.zeros(len(ells), 'float64')

            det_theory[:] = np.linalg.det(Cov_theory[:, :, :])
            det_observ[:] = np.linalg.det(Cov_observ[:, :, :])

            for i in xrange(self.nbin):
                newCov = np.copy(Cov_theory)
                newCov[:,:, i] = Cov_observ[:,:, i]
                det_cross_term[i,:] = np.linalg.det(newCov[:,:,:])

            det_cross = np.sum(det_cross_term,axis=0)

            for index, ell in enumerate(ells):
                chi2 += (2.*ell+1.)*self.fsky*(det_cross[index]/det_theory[index] + math.log(det_theory[index]/det_observ[index]) - self.nbin)

        # Finally adding a gaussian prior on the epsilon nuisance parameter, if
        # present
        if 'epsilon' in self.use_nuisance:
            epsilon = data.mcmc_parameters['epsilon']['current'] * \
                data.mcmc_parameters['epsilon']['scale']
            chi2 += epsilon**2

        #end = time.time()
        #print "Time in s:",end-start

        return -chi2/2.
paths:
    tests: tests
    log: tests/_output
    data: tests/_data
    helpers: tests/_support
settings:
    bootstrap: _bootstrap.php
    colors: false
    silent: false
    log: false
extensions:
    enabled: [MyGroupHighlighter, SkipGroup, Group\CountEvents]
modules:
    config:
        Db:
            dsn: ''
            user: ''
            password: ''
            dump: tests/_data/dump.sql
Laravel 5 Shortcode
==============

Official documentation is located [here](http://sky.pingpong-labs.com/docs/2.0/shortcode)<?php
namespace Codeception\Lib\Connector;

use Symfony\Component\BrowserKit\Client;
use Symfony\Component\BrowserKit\Response;
use Symfony\Component\BrowserKit\Request as BrowserKitRequest;

class ZF1 extends Client
{
    use Shared\PhpSuperGlobalsConverter;

    /**
     * @var \Zend_Controller_Front
     */
    protected $front;

    /**
     * @var \Zend_Application
     */
    protected $bootstrap;

    /**
     * @var  \Zend_Controller_Request_HttpTestCase
     */
    protected $zendRequest;

    public function setBootstrap($bootstrap)
    {
        $this->bootstrap = $bootstrap;

        $this->front = $this->bootstrap
            ->getBootstrap()
            ->getResource('frontcontroller');
        $this->front
            ->throwExceptions(true)
            ->returnResponse(false);
    }

    public function doRequest($request)
    {

        // redirector should not exit
        $redirector = \Zend_Controller_Action_HelperBroker::getStaticHelper('redirector');
        $redirector->setExit(false);

        // json helper should not exit
        $json = \Zend_Controller_Action_HelperBroker::getStaticHelper('json');
        $json->suppressExit = true;

        $zendRequest = new \Zend_Controller_Request_HttpTestCase();
        $zendRequest->setMethod($request->getMethod());
        $zendRequest->setCookies($request->getCookies());
        $zendRequest->setParams($request->getParameters());
        // Sf2's BrowserKit does not distinguish between GET, POST, PUT etc.,
        // so we set all parameters in ZF's request here to not break apps
        // relying on $request->getPost()
        $zendRequest->setPost($request->getParameters());
        $zendRequest->setRawBody($request->getContent());

        $uri = $request->getUri();
        $queryString = parse_url($uri, PHP_URL_QUERY);
        $requestUri = parse_url($uri, PHP_URL_PATH);
        if (!empty($queryString)) {
            $requestUri .= '?' . $queryString;
        }
        $zendRequest->setRequestUri($requestUri);

        $zendRequest->setHeaders($this->extractHeaders($request));
        $_FILES  = $this->remapFiles($request->getFiles());
        $_SERVER = array_merge($_SERVER, $request->getServer());

        $zendResponse = new \Zend_Controller_Response_HttpTestCase;
        $this->front->setRequest($zendRequest)->setResponse($zendResponse);

        ob_start();
        try {
            $this->bootstrap->run();
            $_GET = $_POST = [];
        } catch (\Exception $e) {
            ob_end_clean();
            $_GET = $_POST = [];
            throw $e;
        }
        ob_end_clean();

        $this->zendRequest = $zendRequest;

        $response = new Response(
            $zendResponse->getBody(),
            $zendResponse->getHttpResponseCode(),
            $this->formatResponseHeaders($zendResponse)
        );

        return $response;
    }

    /**
     * Format up the ZF1 response headers into Symfony\Component\BrowserKit\Response headers format.
     *
     * @param \Zend_Controller_Response_Abstract $response The ZF1 Response Object.
     * @return array the clean key/value headers
     */
    private function formatResponseHeaders(\Zend_Controller_Response_Abstract $response)
    {
        $headers = array();
        foreach ($response->getHeaders() as $header) {
            $name = $header['name'];
            if (array_key_exists($name, $headers)) {
                if ($header['replace']) {
                    $headers[$name] = $header['value'];
                }
            } else {
                $headers[$name] = $header['value'];
            }
        }
        return $headers;
    }


    /**
     * @return \Zend_Controller_Request_HttpTestCase
     */
    public function getZendRequest()
    {
        return $this->zendRequest;
    }

    private function extractHeaders(BrowserKitRequest $request)
    {
        $headers = [];
        $server = $request->getServer();

        $contentHeaders = array('Content-Length' => true, 'Content-Md5' => true, 'Content-Type' => true);
        foreach ($server as $header => $val) {
            $header = implode('-', array_map('ucfirst', explode('-', strtolower(str_replace('_', '-', $header)))));

            if (strpos($header, 'Http-') === 0) {
                $headers[substr($header, 5)] = $val;
            } elseif (isset($contentHeaders[$header])) {
                $headers[$header] = $val;
            }
        }
        return $headers;
    }
}
-- Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; version 2 of the License.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

--
-- View: x$statements_with_sorting
--
-- Lists all normalized statements that have done sorts,
-- ordered by total_latency descending.
--
-- mysql> select * from x$statements_with_sorting\G
-- *************************** 1. row ***************************
--             query: SELECT * FROM `schema_object_overview` SELECT `information_schema` . `routines` . `ROUTINE_SCHEMA` AS ... truncated
--                db: sys
--        exec_count: 2
--     total_latency: 16751388791000
-- sort_merge_passes: 0
--   avg_sort_merges: 0
-- sorts_using_scans: 12
--  sort_using_range: 0
--       rows_sorted: 168
--   avg_rows_sorted: 84
--        first_seen: 2014-03-07 13:13:41
--         last_seen: 2014-03-07 13:13:48
--            digest: 54f9bd520f0bbf15db0c2ed93386bec9
--

CREATE OR REPLACE
  ALGORITHM = MERGE
  DEFINER = 'root'@'localhost'
  SQL SECURITY INVOKER 
VIEW x$statements_with_sorting (
  query,
  db,
  exec_count,
  total_latency,
  sort_merge_passes,
  avg_sort_merges,
  sorts_using_scans,
  sort_using_range,
  rows_sorted,
  avg_rows_sorted,
  first_seen,
  last_seen,
  digest
) AS
SELECT DIGEST_TEXT AS query,
       SCHEMA_NAME db,
       COUNT_STAR AS exec_count,
       SUM_TIMER_WAIT AS total_latency,
       SUM_SORT_MERGE_PASSES AS sort_merge_passes,
       ROUND(IFNULL(SUM_SORT_MERGE_PASSES / NULLIF(COUNT_STAR, 0), 0)) AS avg_sort_merges,
       SUM_SORT_SCAN AS sorts_using_scans,
       SUM_SORT_RANGE AS sort_using_range,
       SUM_SORT_ROWS AS rows_sorted,
       ROUND(IFNULL(SUM_SORT_ROWS / NULLIF(COUNT_STAR, 0), 0)) AS avg_rows_sorted,
       FIRST_SEEN as first_seen,
       LAST_SEEN as last_seen,
       DIGEST AS digest
  FROM performance_schema.events_statements_summary_by_digest
 WHERE SUM_SORT_ROWS > 0
 ORDER BY SUM_TIMER_WAIT DESC;
#!/usr/bin/env perl

BEGIN {
   die "The PERCONA_TOOLKIT_BRANCH environment variable is not set.\n"
      unless $ENV{PERCONA_TOOLKIT_BRANCH} && -d $ENV{PERCONA_TOOLKIT_BRANCH};
   unshift @INC, "$ENV{PERCONA_TOOLKIT_BRANCH}/lib";
};

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Test::More;

use PerconaTest;
use Sandbox;
require "$trunk/bin/pt-table-sync";

my $output;
my $dp = new DSNParser(opts=>$dsn_opts);
my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
my $master_dbh = $sb->get_dbh_for('master');
my $slave_dbh  = $sb->get_dbh_for('slave1');

if ( !$master_dbh ) {
   plan skip_all => 'Cannot connect to sandbox master';
}
elsif ( !$slave_dbh ) {
   plan skip_all => 'Cannot connect to sandbox slave';
}
else {
   plan tests => 2;
}

$sb->wipe_clean($master_dbh);
$sb->wipe_clean($slave_dbh);

# #############################################################################
# Issue 218: Two NULL column values don't compare properly w/ Stream/GroupBy
# #############################################################################
$sb->create_dbs($master_dbh, [qw(issue218)]);
$sb->use('master', '-e "CREATE TABLE issue218.t1 (i INT)"');
$sb->use('master', '-e "INSERT INTO issue218.t1 VALUES (NULL)"');
qx($trunk/bin/pt-table-sync --no-check-slave --print --database issue218 h=127.1,P=12345,u=msandbox,p=msandbox P=12346);
ok(!$?, 'Issue 218: NULL values compare as equal');

# #############################################################################
# Done.
# #############################################################################
$sb->wipe_clean($master_dbh);
$sb->wipe_clean($slave_dbh);
ok($sb->ok(), "Sandbox servers") or BAIL_OUT(__FILE__ . " broke the sandbox");
exit;
<?php
/**
 * This file is part of the <name> project.
 *
 * (c) <yourname> <youremail>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Application\Sonata\InvoiceBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;


/**
 * This file has been generated by the EasyExtends bundle ( http://sonata-project.org/easy-extends )
 *
 * References :
 *   bundles : http://symfony.com/doc/current/book/bundles.html
 *
 * @author <yourname> <youremail>
 */
class ApplicationSonataInvoiceBundle extends Bundle
{
    /**
     * {@inheritdoc}
     */
    public function getParent()
    {
        return 'SonataInvoiceBundle';
    }
}###################################################################################
# This test cases evaluates the mixture of non-transactional and transcational
# tables. For further details, please, read WL#2687 and WL#5072.
###################################################################################
--source include/big_test.inc
--source include/have_binlog_format_statement.inc
--source include/master-slave.inc
--source include/have_innodb.inc
--source include/not_gtid_enabled.inc

let $engine_type=Innodb;
let $database_name=test;
--source extra/rpl_tests/rpl_mixing_engines.test

#
# BUG#49522: Replication problem with mixed MyISAM/InnoDB
#

--source include/rpl_reset.inc
-- connection master

CREATE TABLE `t1` ( 
  `c1` int(10) unsigned NOT NULL AUTO_INCREMENT, 
  `c2` tinyint(1) unsigned DEFAULT NULL, 
  `c3` varchar(300) DEFAULT NULL, 
  `c4` int(10) unsigned NOT NULL, 
  `c5` int(10) unsigned DEFAULT NULL, 
  PRIMARY KEY (`c1`)) ENGINE=MyISAM DEFAULT CHARSET=latin1;

--source include/sync_slave_sql_with_master.inc
ALTER TABLE `t1` Engine=InnoDB;

-- connection master
SET AUTOCOMMIT=0;

INSERT INTO t1 (c1,c2,c3,c4,c5) VALUES (1, 1, 'X', 1, NULL);
COMMIT;
ROLLBACK;
SET AUTOCOMMIT=1;

--source include/sync_slave_sql_with_master.inc

-- let $diff_tables= master:t1, slave:t1
-- source include/diff_tables.inc

-- connection master
DROP TABLE `t1`;
--source include/sync_slave_sql_with_master.inc

--source include/rpl_end.inc
#
# This test must examine integrity of current system database
#

set @name="This is a very long string, that mustn't find room in a system field like Table_name. Thus it should be cut by the actual size of the field. So we can use this string to find out the actual length of the field and to use it in any compare queries";

#
# If this part is wrong, most likely you've done wrong modification of system database "mysql"
#

create table test_db select * from mysql.db;
delete from test_db;
--disable_warnings
insert into test_db (Host,Db,User) values (@name,@name,@name);
--enable_warnings

create table test_user select * from mysql.user;
delete from test_user;
--disable_warnings
insert into test_user (Host,User) values (@name,@name);
--enable_warnings

create table test_func select * from mysql.func;
delete from test_func;
--disable_warnings
insert into test_func (name) values (@name);
--enable_warnings

create table test_tables_priv select * from mysql.tables_priv;
delete from test_tables_priv;
--disable_warnings
insert into test_tables_priv (Host,Db,User,Table_name) values (@name,@name,@name,@name);
--enable_warnings

create table test_columns_priv select * from mysql.columns_priv;
delete from test_columns_priv;
--disable_warnings
insert into test_columns_priv (Host,Db,User,Table_name,Column_name) values (@name,@name,@name,@name,@name);
--enable_warnings

# 'Host' field must be the same for all the tables:

select
 if(isnull(test_db.Host),'WRONG!!!','ok') as test_db_Host,
 if(isnull(test_user.Host),'WRONG!!!','ok') as test_user_Host,
 if(isnull(test_tables_priv.Host),'WRONG!!!','ok') as test_tables_priv_Host,
 if(isnull(test_columns_priv.Host),'WRONG!!!','ok') as test_columns_priv_Host

from      test_db
left join test_user         on test_db.Host=test_user.Host
left join test_tables_priv  on test_db.Host=test_tables_priv.Host
left join test_columns_priv on test_db.Host=test_columns_priv.Host;

# 'Db' field must be the same for all the tables:

select
 if(isnull(test_db.Db),'WRONG!!!','ok') as test_db_Db,
 if(isnull(test_tables_priv.Db),'WRONG!!!','ok') as test_tables_priv_Db,
 if(isnull(test_columns_priv.Db),'WRONG!!!','ok') as est_columns_priv_Db

from      test_db
left join test_tables_priv  on test_db.Db=test_tables_priv.Db
left join test_columns_priv on test_db.Db=test_columns_priv.Db;

# 'User' field must be the same for all the tables:

select
 if(isnull(test_db.User),'WRONG!!!','ok') as test_db_User,
 if(isnull(test_user.User),'WRONG!!!','ok') as test_user_User,
 if(isnull(test_tables_priv.User),'WRONG!!!','ok') as test_tables_priv_User,
 if(isnull(test_columns_priv.User),'WRONG!!!','ok') as test_columns_priv_User

from      test_db
left join test_user         on test_db.User=test_user.User
left join test_tables_priv  on test_db.User=test_tables_priv.User
left join test_columns_priv on test_db.User=test_columns_priv.User;

# 'Table_name' field must be the same for all the tables:

select
 if(isnull(test_tables_priv.User),'WRONG!!!','ok') as test_tables_priv_User,
 if(isnull(test_columns_priv.User),'WRONG!!!','ok') as test_columns_priv_User
from      test_tables_priv
left join test_columns_priv on test_tables_priv.Table_name=test_columns_priv.Table_name;

drop table test_columns_priv;
drop table test_tables_priv;
drop table test_func;
drop table test_user;
drop table test_db;

# End of 4.1 tests
<?xml version="1.0" encoding="utf-8"?>
<doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping" xsi="http://www.w3.org/2001/XMLSchema-instance" schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping http://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">
    <!--
         This file has been generated by the EasyExtends bundle ( http://sonata-project.org/easy-extends )

         References :
            xsd                  : https://github.com/doctrine/doctrine2/blob/master/doctrine-mapping.xsd
            xml mapping          : http://www.doctrine-project.org/projects/orm/2.0/docs/reference/xml-mapping/en
            association mapping  : http://www.doctrine-project.org/projects/orm/2.0/docs/reference/association-mapping/en
    -->
    <entity
        name="Application\Sonata\PageBundle\Entity\Site"
        table="page__site"
        >

        <id name="id" type="integer" column="id">
            <generator strategy="AUTO"/>
        </id>

    </entity>
</doctrine-mapping>